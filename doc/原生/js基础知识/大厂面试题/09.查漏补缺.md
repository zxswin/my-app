## 查漏补缺

## requestIdleCallback 是干什么用的

- 浏览器帧绘制机制

```ts
/**
 * 一般的浏览器每秒钟会绘制60帧，也就是每帧需要16ms左右，如果js计算任务长时间占用线程那个，会导致一些ui无法及时得到渲染，出现卡顿。
 * 一帧内需要完成如下六个步骤的任务：
 * 1.处理用户的交互
 * 2.JS 解析执行
 * 3.帧开始。窗口尺寸变更，页面滚去等的处理
 * 4.requestAnimationFrame(rAF)
 * 5.布局
 * 6.绘制
 */
```

```ts
/**
 * 使用setTimeout的缺点
 * 我们可以使用setTimout，对这些任务进行延迟处理。但是我们并不知道，setTimeout在执行回调时，是否是浏览器空闲的时候
 *
 * requestIdleCallback 的callback会在浏览器的空闲时间运行
 *
 * 空闲时间
 * 1.第一种空闲时间
 * 如果执行一段动画,第一帧已经渲染到屏幕上了，到第二帧开始渲染，这段时间内属于空闲时间
 * 如果浏览器1s内屏幕刷新60次的。那么空闲时间会小于16ms（1000ms / 16）
 * 2.另外一种空闲时间，当用户属于空闲状态（没有与网页进行任何交互），并且没有屏幕中也没有动画执行。
 * 此时空闲时间是无限长的。但是为了避免不可预测的事（用户突然和网页进行交互），空闲时间最大应该被限制在50ms以内
 * 为什么最大是50ms？人类对100ms内的响应会认为是瞬时的。将空闲时间限制在50ms以内
 * 是为了避免，空闲时间内执行任务，从而导致了对用户操作响应的阻塞，使用户感到明显的响应滞后。
 *
 * 只会在帧末尾有空闲时间时会执行，不应该期望每一次帧结束都会执行requestIdleCallback。
 * 更新DOM，以及Promise的回调（会使帧超时）不适合放到 requestIdleCallback 的callback中
 */

// console
// 空闲时间1
// 等待了1000ms
// 空闲时间2
// Promise 会在空闲时间1接受后立即执行，即使没有空闲时间了也是如此。拖延了进入下一帧的时间

requestIdleCallback(() => {
  console.log('空闲时间1');
  Promise.resolve().then(() => {
    sleep(1000);
    console.log('等待了1000ms');
  });
});

requestIdleCallback(() => {
  console.log('空闲时间2');
});
```

- requestIdleCallback API 简介

```ts
/**
 * requestIdleCallback的第一个参数时callback当callback被调用时，
 *
 * 一个参数 deadline
 * deadline是一个对象，对象上有两个属性
 * timeRemaining，timeRemaining属性是一个函数，函数的返回值表示当前空闲时间还剩下多少时间
 * didTimeout，didTimeout属性是一个布尔值，如果didTimeout是true，那么表示本次callback的执行是因为超时的原因
 *
 * 第二个参数是options
 * options是一个对象，可以用来配置超时时间
 */
requestIdleCallback(
  (deadline) => {
    // deadline.timeRemaining() 返回当前空闲时间的剩余时间
    if (deadline.timeRemaining() > 0) {
      task();
    }
  },
  {
    timeout: 500,
  }
);
```

- 多个 callback 的执行机制

```ts
/**
 * 执行机制
 * 在空闲期间，callback的执行顺序是以FIFO（先进先出）的顺序。
 * 如果在空闲时间内依次执行callback时，有一个callback的执行时间，已经将空闲时间用完了，剩下的callback将会在下一次的空闲时间执行。
 */
const task1 = () => console.log('执行任务1');
const task2 = () => console.log('执行任务2');
const task3 = () => console.log('执行任务3');

// console
// 执行任务1
// 执行任务2
// 执行任务3
requestIdleCallback(task1);
requestIdleCallback(task2);
requestIdleCallback(task3);
```

- 把任务带到下一个空闲时间周期运行

```ts
/**
 * 如果当前的任务所需要的执行时间，超过了当前空闲时间周期内的剩余时间，我们也可以将任务带到下一个空闲时间周期内执行。
 * 在下一个空闲周期开始后，新添加的callback会被添加到callback列表的末尾
 *
 * 当我们网页处于不可见的状态时（比如切换到其他的tag），我们空闲时间将会每10s, 触发一次空闲期。
  */
const startTask = (deadline) {
    // 如果 `task` 花费的时间是20ms
    // 超过了当前空闲时间的剩余毫秒数，我们等到下一次空闲时间执行task
    if (deadline.timeRemaining() <= 20) {
        // 将任务带到下一个空闲时间周期内
        // 添加到下一个空闲时间周期callback列表的末尾
        requestIdleCallback(startTask)
    } else {
        // 执行任务
        task()
    }
}
```

- callback 的超时执行

```ts
/**
 * 如果指定了timeout，但是浏览器没有在timeout指定的时间内，执行callback。在下次空闲时间时，callback会强制执行。
 * 并且callback的参数，deadline.didTimeout等于true, deadline.timeRemaining()返回0。
 */
requestIdleCallback(
  (deadline) => {
    // true
    console.log(deadline.didTimeout);
  },
  {
    timeout: 1000,
  }
);

// 这个操作大概花费5000ms
for (let i = 0; i < 3000; i++) {
  document.body.innerHTML = document.body.innerHTML + `<p>${i}</p>`;
}
```

- requestIdleCallback 实践：在 requestIdleCallback 中打点(完成数据上报)

```ts
const datas = [];
let isReport = false;

function onClick() {
  // ... 一些业务逻辑

  datas.push({
    date: Date.now(),
  });

  handleDataReport();
}

function handleDataReport() {
  if (isReport) {
    return;
  }

  isReport = true;

  // 在空闲周期时，完成数据上报
  requestIdleCallback(dataReport);
}

function dataReport(deadline) {
  isReport = false;

  while (deadline.timeRemaining() > 0 && datas.length > 0) {
    const data = datas.pop();
    // 上报数据
    get(data);
  }

  if (datas.length) {
    // 如果有数据，没有上报完成，等待进入下一个空闲周期
    handleDataReport();
  }
}
```

## requestAnimationFrame(rAF)

- 屏幕刷新频率

```ts
/**
 * 即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)
 * 对于一般笔记本电脑，这个频率大概是60Hz
 *
 * 电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率正在不断的更新屏幕上的图像
 * 因为人的眼睛有视觉停留效应所以并不会感受到页面的闪烁
 */
```

- setTimeout

```ts
/**
 * setTimeout 通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的
 * setTimeout会出现卡顿、抖动的现象的原因
 * 1.setTimeout的执行时间并不是确定的。
 * setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，
 * 才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些
 * 2. setTimeout设置的固定时间间隔，不一定和屏幕的刷新时间相同
 * 导致setTimeout的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象
 */
```

- requestAnimationFrame

```ts
/**
 *
 * 特点：
 * 与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机
 * requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次
 * 这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题
 *
 * 优势
 * 1.CPU节能
 * 使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务,浪费CPU资源
 * requestAnimationFrame当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，requestAnimationFrame也会停止渲染，
 * 当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。
 *
 * 2.函数节流
 * 在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，
 * 使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。
 */
var progress = 0;

//回调函数

function render() {
  progress += 1; //修改图像的位置

  if (progress < 100) {
    //在动画没有结束前，递归渲染

    window.requestAnimationFrame(render);
  }
}

//第一帧渲染

window.requestAnimationFrame(render);
```

- cancelAnimationFrame 方法用于取消定时器

```ts
//控制台什么都不输出
var timer = requestAnimationFrame(function () {
  console.log(0);
});
cancelAnimationFrame(timer);
```

- 简单的进制度效果(setInterval)

```ts
function(){
    clearInterval(timer);
    myDiv.style.width = '0';
    timer = setInterval(function(){
        if(parseInt(myDiv.style.width) < 500){
            myDiv.style.width = parseInt(myDiv.style.width) + 5 + 'px';
            myDiv.innerHTML =     parseInt(myDiv.style.width)/5 + '%';
        }else{
            clearInterval(timer);
        }
    },16);
}
```

- 简单的进制度效果(setTimeout)

```ts
function(){
    clearTimeout(timer);
    myDiv.style.width = '0';
    timer = setTimeout(function fn(){
        if(parseInt(myDiv.style.width) < 500){
            myDiv.style.width = parseInt(myDiv.style.width) + 5 + 'px';
            myDiv.innerHTML =     parseInt(myDiv.style.width)/5 + '%';
            timer = setTimeout(fn,16);
        }else{
            clearTimeout(timer);
        }
    },16);
}
```

- 简单的进制度效果(requestAnimationFrame)

```ts
function(){
    myDiv.style.width = '0';
    cancelAnimationFrame(timer);
    timer = requestAnimationFrame(function fn(){
        if(parseInt(myDiv.style.width) < 500){
            myDiv.style.width = parseInt(myDiv.style.width) + 5 + 'px';
            myDiv.innerHTML =     parseInt(myDiv.style.width)/5 + '%';
            timer = requestAnimationFrame(fn);
        }else{
            cancelAnimationFrame(timer);
        }
    });
}
```

## JS 中的循环引用及问题

```ts
/**
 * 通过引用计数的策略进行垃圾回收会造成内存泄露
 * JSON.stringify会报错
 */
```

## event.target 和 event.currtager 的区别

```ts
/**
 * event.target代表的是触发事件的元素，而event.currentTarget代表的是那个绑定了事件处理函数的元素
 */
```

- base64 编码

```ts
/**
 * 把大图片编码到 html / css 中，会造成后者体积明显增加，明显影响网页的打开速度。
 */

window.btoa('china is so nb'); // 编码
// "Y2hpbmEgaXMgc28gbmI="
window.atob('Y2hpbmEgaXMgc28gbmI='); // 解码
// "china is so nb"
var user_icon = document.getElementById('icon');
user_icon.src = img_path; //指定图片路径
user_icon.onload = function () {
  base64 = getImageBase64(user_icon, fileExt); //base64编码
};
```

贪心算法
回溯算法
双指针操作
动态规划（一般为加分题）

## 单词

```pug
idle 空闲
deadline 截止日期
remaining 剩下的
```
