## 框架部分

## 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么

```ts
/**
 * key的作用主要是为了高效的更新虚拟DOM
 * 在diff算法中 key是为了在diff算法执行时更快的找到对应的节点，提高diff速度
 *
 * 当页面的数据发生变化时，Diff算法只会比较同一层级的节点：
 * 如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。
 * 如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。
 */
```

- React 的 diff 过程

```ts
/**
 * 1.在React中，两棵DOM树只会对同一层的节点进行比较，若发现节点已不存在，则该节点及其子节点会被完全删除，不会用于进一步的比较
 * 这样，只需要对树进行一次遍历，就能完成整个DOM树的比较
 *
 * 2.对于同层节点，React在数组遍历的增减关键字Key,若节点本身完全相同(类型相同，属性相同)，只是位置不同，
 * 则React只需要考虑同层节点的位置变换，不需要进行节点的销毁和重新创建
 *
 * 3.对于不同层的节点，即使节点本身完全相同（类型相同且属性相同），也只能销毁和重新创建。
 */
```

## React 中 setState 什么时候是同步的，什么时候是异步

- React 中 setState 更新 state

```tsx
/**
 * React中constructor是唯一可以初始化state的地方
 * 使用this.setState()更新状态
 */

// 方式1直接传入对象更新状态
// 由React控制的事件处理程序，以及生命周期函数调用setState不会同步更新state
// React控制之外的事件中调用setState是同步更新的。比如原生js绑定的事件，setTimeout/setInterval等。
// 多个setState调用会合并处理
show = () => {
  setTimeout(() => {
    this.setState({
      isshow: true,
    });
    console.log(this.state.isshow);
  }, 1000);
};

// 方式2使用函数产生更新
// 接收两个函数，第二个函数式设置成功后的回调函数
const change = (preState, props) => {
  console.log('state', preState);
  console.log('props', props);
  return {
    isshow: !preState.isshow,
  };
};
const callback = () => {
  console.log('状态已经改变', this.state);
};
this.setState(change, callback);

// setState的同步与异步
class Example extends React.Component {
  constructor() {
    super();
    this.state = {
      val: 0,
    };
  }

  componentDidMount() {
    // setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，
    // 只是合成事件和钩子函数的调用顺序在更新之前，
    // 导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”
    this.setState({ val: this.state.val + 1 });
    console.log(this.state.val); // 第 1 次 log 0

    this.setState({ val: this.state.val + 1 });
    console.log(this.state.val); // 第 2 次 log 0

    setTimeout(() => {
      // 上面两次 setState
      // 在 react 内部会被合并掉，只执行后面那一次。设置完成后 state.val 值为 1。
      this.setState({ val: this.state.val + 1 });
      console.log(this.state.val); // 第 3 次 log 2

      this.setState({ val: this.state.val + 1 });
      console.log(this.state.val); // 第 4 次 log 3
    }, 0);
  }

  render() {
    return null;
  }
}
```

## 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作

```ts
/**
 *
 * Redux有三大原则：
 * 单一数据源，也就是state
 * state 是只读，Redux并没有暴露出直接修改state的接口，必须通过action来触发修改
 * 使用纯函数来修改state，reducer必须是纯函数
 *
 * vuex和redux都是一种状态管理机制，然后他们会有自己的state和修改state的方法
 * vuex的处理方式是同步在mutation里面，异步在actions里面。
 *
 * 因为更改state的函数必须是纯函数，纯函数既是统一输入就会统一输出，没有任何副作用；
 * 如果是异步则会引入额外的副作用，导致更改后的state不可预测；
 */
```

## 在 Vue 中，子组件为何不可以修改父组件传递的 Prop

```ts
/**
 *
 * 如果在子组件里修改的是prop是基础类型,则会触发警告且不会影响到父级的数据
 * 如果在子组件里面修改的prop是引用类型,如果只修改其属性则不会触发警告且可以修改父组件的数据源
 *
 * 为何不可以修改：
 * 为了保证数据的单向流动，便于对数据进行追踪，避免数据混乱。
 * 子组件像要改 prop 只能委托父组件帮它。从而保证数据修改源唯一
 */
```

## 双向绑定和 vuex 是否冲突

```ts
/**
 * 当直接使用v-model双向绑定来修改Vuex中的state值的时候,会抛出错误
 * 变通的实现
 * 1、在input中绑定value(vuex中的state)，然后监听input的change或者input事件
 * 2.在事件回调中调用mutation修改state的值
 */
```

## Vue 的响应式原理中 Object.defineProperty 有什么缺陷

```ts
/**
 * 1.Object.defineProperty无法监控到数组下标的变化，
 * 导致直接通过数组的下标给数组设置值，不能实时响应。
 * 为了解决这个问题，经过vue内部处理后可以使用以下几种方法来监听数组
 *
 * push()
 * pop()
 * shift()
 * unshift()
 * splice()
 * sort()
 * reverse()
 * 由于只针对了以上八种方法进行了hack处理,所以其他数组的属性也是检测不到的，还是具有一定的局限性。
 *
 * 2.Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。
 * Vue 2.x里，是通过 递归 + 遍历 data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,
 * 显然如果能劫持一个完整的对象是才是更好的选择
 *
 * 3.而要取代它的Proxy有以下两个优点;
 * 可以劫持整个对象，并返回一个新对象
 * 有13种劫持操作
 */
```

## Vue 的父组件和子组件生命周期钩子执行顺序是什么

```ts
/**
 * 加载渲染过程 父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
 * 子组件更新过程 父beforeUpdate->子beforeUpdate->子updated->父updated
 * 父组件更新过程 父beforeUpdate->父updated
 * 销毁过程 父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
 */
```

## react-router 里的 <Link> 标签和 <a> 标签有什么区别

```ts
/**
 * 从最终渲染的 DOM 来看，这两者都是链接，都是 <a> 标签
 * 区别
 * 1.<Link> 是 react-router 里实现路由跳转的链接，一般配合 <Route> 使用
 * 2.react-router 阻止默认的链接跳转行为，区别于传统的页面跳转
 * 3.<Link> 的“跳转”行为只会触发相匹配的 <Route> 对应的页面内容更新，而不会刷新整个页面
 * 4.<a> 标签就是普通的超链接了，用于从当前页面跳转到 href 指向的另一个页面
 */
```

## vue 如何优化首页的加载速度

```ts
/**
 * 原因： vue是spa，进入首页的时候会把所有的js，css等资源下载，引起白屏问题。
 * 优化方案
 * ssr技术
 * 首页骨架图
 * 一些三方资源可以上cdn
 * 可以尝试多页面（工作中使用vue多页面，有很大的改善）
 * 开始gzip压缩
 * 使用iconfont或者雪碧图
 * 接口响应时间的优化
 * 路由懒加载
 */
```

## React、Vue、Angular 对比 ---- 介绍及优缺点

- React

```ts
/**
 * 1.速度快
 * 2.跨浏览器兼容
 * 3.模块化
 * 4.单向数据流
 * 5.灵活
 */
```

- Vue

```ts
/**
 * 1.轻量级的框架
 * 2.双向数据绑定
 * 3.指令
 * 4.插件化
 */
```

- Angular

```ts
/**
 * 1.良好的应用程序结构
 * 2.双向数据绑定
 * 3.指令
 * 4.HTML模板
 * 5.包含服务，模板，数据双向绑定，模块化，路由，过滤器，依赖注入等所有功能
 * 6.概念比较多,入门成本高
 * 7.也是单向数据流
 */
```

## angular2 脏检查

```ts
/**
 * 一个Angular 2 应用就是一颗组件树。
 * 每一个组件都有一个变更检测器（change detector ），负责检测模板中所定义的数据绑定。
 * 变更检测系统会按照从根到叶子的顺序传播数据绑定。
 * 默认情况下，变更检测系统会遍历整棵组件树。
 * 但是，如果你使用不可变对象或者可观察对象，你就可以享受到它们带来的优势，只要检测组件树里面“真正发生变化”的部分即可。
 */
```
