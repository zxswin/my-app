## 大厂面试题汇总

##

- HTML5

```ts
/**
 * 语意化标签
 * 音视频处理
 * canvas / webGL
 * history API
 * requestAnimationFrame
 * web scoket
 */
```

- JS 底层原理

```ts
/**
 * 堆栈内存
 * 闭包作用域AONVO/GO/EC/ECSTACK
 * 面向对象00P
 * THIS
 * EventLoop
 * 浏览器洁染原理
 * 回流重绘
 */
```

- 网络通讯层

```ts
/**
 * AJAX / Fetch / axios
 * HTTP1.0/2.0
 * TCP
 * 跨域处理方案
 * 性能优化
 */
```

- Hybrid 或者 APP 再或者小程序

```ts
/**
 * Hybrid
 * uni-app
 * RN
 * Flutter
 * 小程序MPVUE
 * Weex
 * PWA
 */
```

- 工程化方面

```ts
/**
 * webpack
 * git
 * linux / nginx
 */
```

- 全栈方面

```ts
/**
 * node
 * express
 * koa2
 * mongodb
 * nuxt.js/next.js
 */
```

- 框架方面

```ts
/**
 * Angular
 * Vue
 *   基础知识
 *   核心原理
 *   vue-router
 *   vue-cli
 *   vuex
 *   element ui
 *   vant
 *   cube
 *   SSR
 *   优化
 *
 * React
 *   基础知识
 *   核心原理
 *   react-router-dom
 *   redux
 *   react-redux
 *   dva
 *   umi
 *   mobx
 *   anid
 *   anid pro
 *   SSR
 *   优化
 *
 */
```

- 游戏方向
- 可视化或者 AI 方向

- 常见面试题

```bash
# 让一个元素水平居中的5种方案
# 标准盒子模型 IE盒子模型(怪异盒子模型)
# flex盒模型
# 掌握几大经典布局方案
#   圣杯布局
#   双飞翼布局
#   左右固定 中间自适应

# 移动端响应式布局开发的三大方案
#    media
#    rem
#    flex
#    vh / vw

# .box a 选择器的渲染性能要比 a渲染性能要低
#  因为选择器从右向左找 先找全部的a 再去找.box下面的a
```

- 算法题

```ts
/**
 * 1.数组去重和排序的多种实现算法
 * 2.数组扁平化的N种实现方案
 * 3.斐波那契数列
 */
```

## JS 基础题部分

- ['1', '2', '3'].map(parseInt) 的运行结果

```ts
// 实际执行的的代码是
['1', '2', '3'].map((item, index) => {
  return parseInt(item, index);
});

// 即返回的值分别为：
parseInt('1', 0); // 1
parseInt('2', 1); // NaN
parseInt('3', 2); // NaN, 3 不是二进制

// 所有
['1', '2', '3'].map(parseInt);
// 1, NaN, NaN
```

- 什么是防抖和节流？有什么区别？如何实现？

```ts
/**
 * 防抖：
 * 事件被触发,n秒后执行事件处理函数
 * 在这段时间内，如果事件又被触发，则重新等待n秒再执行事件处理函数
 *
 * 快速书写一个防抖函数
 * @description 只要一直调用, callback 将不会被触发
 * 在一次调用结束后, 只有等待 timeout ms 时间, 才能继续调用 callback
 * immediate 决定触发时机
 * @example
 * 1. 点击按钮发送请求（保存数据之类的）
 * 2. 搜索时自动联想
 * 3. 自动保存
 */
function debounce(callback, timeout, immediate) {
  let timer;
  return function () {
    const context = this; // 持有执行上下文
    const args = arguments; // 记录传参
    const later = function () {
      timer = null; // 贤者时间过了，重振旗鼓，重置为初始状态
      if (!immediate) callback.apply(context, args); // 设置为尾部调用才延时触发
    };
    const callNow = immediate && !timer; // 如果确认允许首部调用，且首次调用，那么本次立即触发
    clearTimeout(timer); // 杀掉上次的计时器，重新计时
    timer = setTimeout(later, timeout); // 重启一个计时器，过了贤者时间之后才触发
    callNow && callback.apply(context, args); // 设置为首部调用立即触发
  };
}

/**
 *
 * 节流：
 * 事件被触发,n秒之内只执行一次事件处理函数
 *
 *
 * 快速书写一个节流函数
 * @description 一直调用 callback, 每隔 timeout ms 时间 callback 触发一次
 * 在 timeout ms 时间内的调用将不触发
 * @example
 * 1.控制疯狂按钮的响应频率
 * 2.控制 API 的调用频率
 * 3.控制频繁触发事件的相应频率
 */
// solution1 记录时间比较
function throttle(callback, timeout) {
  let triggerTime; // 记录每次真正触发时间
  return function () {
    const context = this; // 持有执行上下文
    const args = arguments; // 记录传参
    if (
      triggerTime === undefined || // 首次调用
      Date.now() - triggerTime > timeout
    ) {
      // 贤者时间已经过去
      triggerTime = Date.now(); // 记录真正触发时间
      callback.apply(context, args); // 可以触发回调
    }
  };
}
// solution2 间隔时间反转标志位
function throttle(callback, timeout) {
  let disable; // 触发回调是否禁用
  return function () {
    const context = this; // 持有执行上下文
    const args = arguments; // 记录传参
    if (!disable) {
      // 首次调用或者贤者时间过了，禁用解除
      callback.apply(context, args); // 可以触发回调
      disable = true; // 马上禁用
      setTimeout((_) => (disable = false), timeout); // 贤者时间过了，禁用解除
    }
  };
}
```

## 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

- 一些容易混淆的知识点

```ts
/**
 * 1.数组是有序的
 * 3.Set中的元素是无序的,并且不能重复的
 * 3.object 是无序的
 * 4.Map 中的键值是有序的当对它进行遍历时，Map 对象是按插入的顺序返回键值。
 * Map 在涉及频繁增删键值对的场景下会有些性能优势
 */
```

- Set

```ts
/**
 * Set 是一种叫做集合的数据结构
 * ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值
 * Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用
 * 向 Set 加入值的时候，不会发生类型转换
 * 认为NaN是等于自身
 *
 * Set 实例属性
 * 1.constructor： 构造函数
 * 2.size：元素数量
 *
 * Set 实例方法
 * 1.add(value)：新增，相当于 array里的push
 * 2.delete(value)：存在即删除集合中value
 * 3.has(value)：判断集合中是否存在 value
 * 4.clear()：清空集合
 *
 * 遍历方法（遍历顺序为插入顺序）
 * 1.keys()：返回一个包含集合中所有键的迭代器
 * 2.values()：返回一个包含集合中所有值得迭代器
 * 3.entries()：返回一个包含Set对象中所有元素得键值对迭代器
 * 4.forEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，
 * 如果提供了 thisArg 参数，回调中的this会是这个参数，没有返回值
 *
 * Set 可默认遍历，默认迭代器生成函数是 values() 方法
 * Set.prototype[Symbol.iterator] === Set.prototype.values	// true
 */

/* 数组转Set结构 */
const s = new Set()
[1, 2, 3, 4, 3, 2, 1].forEach(x => s.add(x))

for (let i of s) {
    console.log(i)	// 1 2 3 4
}

// 去重数组的重复对象
let arr = [1, 2, 3, 2, 1, 1]
[... new Set(arr)]	// [1, 2, 3]

/* Set 结构转为数组 */
const items = new Set([1, 2, 3, 2])
const array = Array.from(items)
console.log(array)	// [1, 2, 3]
// 或
const arr = [...items]
console.log(arr)	// [1, 2, 3]

/* 实现交集（Intersect）、并集（Union）、差集（Difference） */
let set1 = new Set([1, 2, 3])
let set2 = new Set([4, 3, 2])

let intersect = new Set([...set1].filter(value => set2.has(value)))
let union = new Set([...set1, ...set2])
let difference = new Set([...set1].filter(value => !set2.has(value)))

console.log(intersect)	// Set {2, 3}
console.log(union)		// Set {1, 2, 3, 4}
console.log(difference)	// Set {1}

/** 遍历方法的使用  */
let set = new Set([1, 2, 3])
console.log(set.keys())	// SetIterator {1, 2, 3}
console.log(set.values())	// SetIterator {1, 2, 3}
console.log(set.entries())	// SetIterator {1, 2, 3}

for (let item of set.keys()) {
  console.log(item);
}	// 1	2	 3
for (let item of set.entries()) {
  console.log(item);
}	// [1, 1]	[2, 2]	[3, 3]

set.forEach((value, key) => {
    console.log(key + ' : ' + value)
})	// 1 : 1	2 : 2	3 : 3
console.log([...set])	// [1, 2, 3]
```

- WeakSet

```ts
/**
 * WeakSet 对象允许你将弱引用对象储存在一个集合中
 * WeakSet 与 Set 的区别
 * 1.WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以
 * 2.WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用
 * 3.如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉
 * 4.WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，
 * 运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了）
 * 5.WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素
 *
 * 属性
 * constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数
 *
 * 方法：
 * add(value)：在WeakSet 对象中添加一个元素value
 * has(value)：判断 WeakSet 对象中是否包含value
 * delete(value)：删除元素 value
 * clear()：清空所有元素，注意该方法已废弃
 */

/* 创建一个WeakSet实例  */
const arr = [
  [1, 2],
  [3, 4],
];
const weakset = new WeakSet(arr);
console.log(weakset);

/* WeakSet的方法使用 */
var ws = new WeakSet();
var obj = {};
var foo = {};

ws.add(window);
ws.add(obj);

ws.has(window); // true
ws.has(foo); // false

ws.delete(window); // true
ws.has(window); // false
```

- Map

```ts
/**
 * 集合 与 字典 的区别：
 * 共同点：集合、字典 可以储存不重复的值
 * 不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存
 *
 * 1.任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数
 * 2.如果读取一个未知的键，则返回undefined。
 * 3.只有对同一个对象的引用，Map 结构才将其视为同一个键
 * Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键
 * 4.NaN不严格相等于自身，但 Map 将其视为同一个键
 *
 * 属性
 * constructor：构造函数
 * size：返回字典中所包含的元素个数
 *
 * 方法
 * set(key, value)：向字典中添加新元素
 * get(key)：通过键查找特定的数值并返回
 * has(key)：判断字典中是否存在键key
 * delete(key)：通过键 key 从字典中移除对应的数据
 * clear()：将这个字典中的所有元素删除
 *
 * 遍历方法
 * keys()：将字典中包含的所有键名以迭代器形式返回
 * values()：将字典中包含的所有数值以迭代器形式返回
 * entries()：返回所有成员的迭代器
 * forEach()：遍历字典的所有成员
 *
 * Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。
 * map[Symbol.iterator] === map.entries
 *
 * Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）
 */

/* 创建一个map的实例 */
const set = new Set([
  ['foo', 1],
  ['bar', 2],
]);
const m1 = new Map(set);
m1.get('foo'); // 1

const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz'); // 3

/* 简单类型的键 */
let map = new Map();

map.set(-0, 123);
map.get(+0); // 123

map.set(true, 1);
map.set('true', 2);
map.get(true); // 1

map.set(undefined, 3);
map.set(null, 4);
map.get(undefined); // 3

map.set(NaN, 123);
map.get(NaN); // 123

/* Map 结构转为数组结构 */
const map = new Map([
  [1, 1],
  [2, 2],
  [3, 3],
]);
console.log([...map]); // [[1, 1], [2, 2], [3, 3]]

/* Array 转 Map */
const map = new Map([
  [1, 1],
  [2, 2],
  [3, 3],
]);
console.log(map); // Map {1 => 1, 2 => 2, 3 => 3}

/* Map 转 Object */
function mapToObj(map) {
  let obj = Object.create(null);
  for (let [key, value] of map) {
    obj[key] = value;
  }
  return obj;
}
const map = new Map().set('name', 'An').set('des', 'JS');
mapToObj(map); // {name: "An", des: "JS"}

/* Object 转 Map */
function objToMap(obj) {
  let map = new Map();
  for (let key of Object.keys(obj)) {
    map.set(key, obj[key]);
  }
  return map;
}

objToMap({ name: 'An', des: 'JS' }); // Map {"name" => "An", "des" => "JS"}

/* Map 转 JSON */
function mapToJson(map) {
  return JSON.stringify([...map]);
}

let map = new Map().set('name', 'An').set('des', 'JS');
mapToJson(map); // [["name","An"],["des","JS"]]

/* JSON 转 Map */
function jsonToStrMap(jsonStr) {
  return objToMap(JSON.parse(jsonStr));
}

jsonToStrMap('{"name": "An", "des": "JS"}'); // Map {"name" => "An", "des" => "JS"}
```

- WeakMap

```ts
/**
 * WeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。
 * 注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用
 *
 * WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，
 * 这个对象将会被垃圾回收（相应的key则变成无效的）
 * WeakMap 的 key 是不可枚举的。
 *
 * 属性：
 * constructor：构造函数
 *
 * 方法
 * has(key)：判断是否有 key 关联对象
 * get(key)：返回key关联对象（没有则则返回 undefined）
 * set(key)：设置一组key关联对象
 * delete(key)：移除 key 的关联对象
 */

let myElement = document.getElementById('logo');
let myWeakmap = new WeakMap();

myWeakmap.set(myElement, { timesClicked: 0 });

myElement.addEventListener(
  'click',
  function () {
    let logoData = myWeakmap.get(myElement);
    logoData.timesClicked++;
  },
  false
);
```

- 总结

```ts
/**
 * Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构
 *
 * 集合 与 字典 的区别：
 * 共同点：集合、字典 可以储存不重复的值
 * 不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存
 *
 *
 * Set
 * 1.成员唯一、无序且不重复
 * 2.[value, value]，键值与键名是一致的（或者说只有键值，没有键名）
 * 3.可以遍历，方法有：add、delete、has
 *
 * WeakSet
 * 1.成员都是对象
 * 2.成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏
 * 3.不能遍历，方法有add、delete、has
 *
 * Map
 * 1.本质上是键值对的集合，类似集合
 * 2.可以遍历，方法很多可以跟各种数据格式转换
 *
 * WeakMap
 * 1.只接受对象作为键名（null除外），不接受其他类型的值作为键名
 * 2.键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的
 * 3.不能遍历，方法有get、set、has、delete
 */
```

## ES5/ES6 的继承除了写法以外还有什么区别

- ES5 的继承

```ts
/**
 * 寄生组合式继承(圣杯模式)
 */
function User(name) {
  this.name = name;
}

function Admin(...args) {
  User.call(this, ...args); // 继承实例属性
}

Admin.prototype = Object.create(User.prototype); // 继承原型方法
let hd = new Admin('后盾人');
console.log(hd);
```

- ES6 的继承

```ts
/**
 *
 * ES6 的继承
 * 1.Class之间通过使用extends关键字实现继承
 * 2.子类必须在constructor方法中调用super方法，否则新建实例时会报错
 * 3.这是因为子类没有自己的this对象，而是父类构造函数创建出this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象
 * 4.因此，只有调用super之后，才可以使用this关键字。
 *
 * prototype 和__proto__
 * 一个继承语句同时存在两条继承链：一条实现属性继承，一条实现方法的继承
 *
 * super 实际上就是 A.__proto__
 * B.prototype 叫做原型对象
 * A.__proto__ 这个叫原型指针
 */
class A extends B {}
A.__proto__ === B; // 继承实例属性
A.prototype.__proto__ == B.prototype; // 继承原型方法
```

- 区别

```ts
/**
 *
 * ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。
 * Sub.__proto__ === Function.prototype;
 *
 * ES6的继承
 * 子类必须在constructor方法中调用super方法，否则新建实例时会报错。
 * 这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，
 * 然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。
 *
 * ES6 的继承机制实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法）
 * 然后再用子类的构造函数修改this。
 * Sub.__proto__ === Super;
 */
```

- super 关键字原理

```ts
class A {
  constructor() {
    console.log(new.target.name);
  }
}
class B extends A {
  constructor() {
    super(); //这里的super相当于A类的constructor构造函数，会执行A的constructor,但是此时的this指
    //向的是B,所以打印出B
    //换一种方法理解是：在执行super时，A把constructor方法给了B，此时B有了A的功能，但是执
    //行的是B的内容，也就是es5的A.prototype.constructor.call(this)。
  }
}
new A(); // A
new B(); // B
```

## 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣

- Object.prototype.toString.call()

```ts
/**
 * 每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [Object type]，其中 type 为对象的类型。
 * 但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时，会直接返回都是内容的字符串
 * 所以我们需要使用call或者apply方法来改变toString方法的执行上下文。
 */

const an = ['Hello', 'An'];
an.toString(); // "Hello,An"
Object.prototype.toString.call(an); // "[object Array]"

// 这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。
// Object.prototype.toString.call() 常用于判断浏览器内置对象时

Object.prototype.toString.call('An'); // "[object String]"
Object.prototype.toString.call(1); // "[object Number]"
Object.prototype.toString.call(Symbol(1)); // "[object Symbol]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(function () {}); // "[object Function]"
Object.prototype.toString.call({ name: 'An' }); // "[object Object]"
```

- instanceof

```ts
/**
 * instanceof  的内部机制是通过判断对象的原型链中是不是能找到类型的 prototype
 * 使用 instanceof判断一个对象是否为数组，instanceof 会判断这个对象的原型链上是否会找到对应的 Array 的原型，
 * 找到返回 true，否则返回 false。
 */
[] instanceof Array; // true

// 但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。
[] instanceof Object; // true
```

- Array.isArray()

```ts
/**
 * 功能：用来判断对象是否为数组
 * 当检测Array实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes
 */

const arr = [];

Array.isArray(arr); // true

// Array.isArray()是ES5新增的方法，当不存在 Array.isArray() ，
// 可以用 Object.prototype.toString.call() 实现。
if (!Array.isArray) {
  Array.isArray = function (arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
```

## 介绍模块化发展历程

```ts
/**
 * 模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。
 */
```

## CommonJS 模块与 ES6 模块的区别

- ES6 的模块化 与 CommonJS 规范的区别

```js
/**
 * 主要区别
 * import是ES6标准中的模块化解决方案，require是node中遵循CommonJS规范的模块化解决方案
 *
 * import 不支持动态引入但是已经有提案
 * require支持动态引入，也就是require(${path}/xx.js)
 *
 * import是关键词，require不是
 *
 * import是编译时加载，必须放在模块顶部，在性能上会比后者好一些，
 * require是运行时加载，理论上来说放在哪里都可以
 *
 * import采用的是实时绑定方式，即导入和导出的值都指向同一个内存地址，所以导入值会随着导出值变化。
 * require在导出时是值的拷贝，就算导出的值变化了，导入的值也不会变化，如果想要更新值就要重新导入
 *
 * import会编译成require/exports来执行

 * 代码是在模块作用域,模块内部的顶层变量，外部不可见。
 * 模块脚本自动采用严格模式，不管有没有声明use strict。
 * 模块之中，可以使用import命令加载其他模块 .js后缀不可省略
 * 也可以使用export命令输出对外接口
 * 模块之中，顶层的this关键字返回undefined，而不是指向window。
 * 同一个模块如果加载多次，将只执行一次。
 */
```

- ES6 模块化的优势

```js
/**
 * CommonJS 和 AMD 模块，都只能在运行时确定依赖关系
 * CommonJS 模块就是对象，输入时必须查找对象属性。
 * 导致完全没办法在编译时做“静态优化”。

 * ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
 * ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。
 */

// ES6模块
// 实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载
import { stat, exists, readFile } from 'fs';
```

## 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？

```ts
/**
 * 在ES5中，顶层对象的属性和全局变量是等价的，var 命令和 function 命令声明的全局变量，自然也是顶层对象。
 */
var a = 12;
function f() {}

console.log(window.a); // 12
console.log(window.f); // f(){}

/**
 * 但ES6规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，
 * 但 let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。
 */
let aa = 1;
const bb = 2;

console.log(window.aa); // undefined
console.log(window.bb); // undefined

/**
 * 在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中
 * 怎么获取？在定义变量的块级作用域中就能获取啊，既然不属于顶层对象，那就不加 window（global）呗。
 */
let aa = 1;
const bb = 2;

console.log(aa); // 1
console.log(bb); // 2

/** 测试代码部分  */
const a = 1;
let b = 2;
var c = 3;

console.dir(new Function());
// [[Scopes]]: Scopes[2]
// 0: Script {a: 1, b: 2}
// 1: Global {0: global, window: Window, self: Window, document: document, name: "", location: Location, …}
```

## 非匿名自执行函数，函数名只读

```ts
/*
 * 在非匿名自执行函数中，函数名为只读状态无法修改
 * 作为函数名的标识符（在这里是 A ）只能从函数体内部访问，在函数外部访问不到
 * 绑定为函数名的标识符（在这里是A）不能再绑定为其它值，即该标识符绑定是不可更改的（immutable），
 * 所以在 NFE 函数体内对 A 重新赋值是无效的。

 * 1. 对于第一问 console.log(b) => 由于自执行非匿名函数的原因 b这个变量不可写,因此输出 f b(){...}
 * (在严格模式下 这种输出是会报错的)
 *
 * 2.第二问 很明显 window.b 输出全局对象上的信息,因此输出 10;
 *
 */

var b = 10;
(function b() {
  b = 20;
  console.log(b);
  console.log(window.b);
})();

// 一道变形的题目
var b = 10;
(function b() {
  var b = 20; // IIFE内部变量
  console.log(b); // 20
  console.log(window.b); // 10
})();
```

## sort() 对数组的排序

```ts
/**
 * 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。
 * 要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。
 */

// 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果
[3, 15, 8, 29, 102, 22].sort();
// [102, 15, 22, 29, 3, 8]
```

## call 和 apply 的区别是什么，哪个性能更好一些

```ts
/**
 *
 * 作用：都是用来改变this指向；
 * 区别：接收参数的方式不同；
 * call（）接收的参数是逐个列举出来的；
 * apply（）接收的是参数数组。
 *
 * 性能对比：
 * call性能比apply好那么一些（尤其是传递给函数的参数超过3个的时候），所以开发时可以用call好一点。
 *
 * 为什么call 比apply 快
 * call 方法比 apply 快的原因是 call 方法的参数格式正是内部方法所需要的格式
 * apply中定义的参数格式（数组），使得被调用之后需要做更多的事，需要将给定的参数格式改变
 * 同时也有一些对参数的检查
 */
```

## 操作符的优先级

```ts
/**
 * . 的优先级高于 = 的优先级
 * = 具有右结合性（执行的方向是从右往左，先执行 = 右边的表达式，然后把结果赋值给 = 左边的表达式，
 * 从这里可以得出 = 属于二元操作符），多个 = 的执行过程，可以类比成"递归"的过程
 */
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };

console.log(a.x); // undefined
console.log(b.x); // {n:2}
```

## 箭头函数与普通函数的区别

```ts
// 箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？

/**
 *
 * 普通函数与箭头函数的this指向
 * 1.普通函数的this：指向它的调用者，如果没有调用者则默认指向window.
 * 2.箭头函数的this: 指向箭头函数定义时所处的对象，而不是箭头函数使用时所在的对象，默认使用父级的this.
 * 箭头函数中的this,首先从它的父级作用域中找，如果父级作用域还是箭头函数，再往上找，如此直至找到this的指向
 *
 * 箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：
 * 1、函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。
 * 2、不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
 * 3、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。
 * 4、不可以使用 new 命令，因为：
 * 没有自己的 this，无法调用 call，apply。
 * 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 __proto__
 */

// new 的过程
function newFunc(father, ...rest) {
  var result = {};
  result.__proto__ = father.prototype;
  var result2 = father.apply(result, rest);
  if (
    (typeof result2 === 'object' || typeof result2 === 'function') &&
    result2 !== null
  ) {
    return result2;
  }
  return result;
}

/** 在全局中这么写this指向Window */

let a = {
  type: 'aaa',
  b: () => {
    console.log('b', this); // this指向Window
  },
};
a.b();

/**  this指向类  */
class B {
  obj = {
    b: () => {
      console.log('bbbb', this); // this指向B
    },
  };
}

let b = new B();

b.obj.b();
```

## a.b.c.d 和 a['b']['c']['d']，哪个性能更高

```ts
/**
 * a.b.c.d 比 a['b']['c']['d'] 性能高点，后者还要考虑 [ ] 中是变量的情况，
 * 再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。
 * a.b.c.d的AST语法树要比a['b']['c']['d']的语法树要简单
 */
```

## ES6 代码转成 ES5 代码的实现思路是什么

```ts
/**
 * 什么是AST
 * AST : 全称为 Abstract Syntax Tree，意为抽象语法树，他是源代码语法结构的一种抽象表示
 * 1.词法分析阶段：将字符组成的字符串分解成一个个代码块（词法单元），例子中代码会被解析成 const、a、=、1 四个词法单元。
 * 2.语法分析阶段：将词法单元流转换成一个由元素逐级嵌套组成的语法结构树，即所谓的抽象语法树。
 * 3.代码生成阶段：将 AST 转换成一系列可执行的机器指令代码
 *
 * 那么 Babel 是如何把 ES6 转成 ES5 呢，其大致分为三步：
 * 1.将代码字符串解析成抽象语法树，即所谓的 AST
 * 2.对 AST 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码
 * 3.根据处理后的 AST 再生成代码字符串
 */
```

## 为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因

```ts
/**
 * for 循环没有任何额外的函数调用栈和上下文
 * forEach函数调用带来的堆栈创建内存分配则不可避免。 绝对意义上，for比forEach快
 * 这个差距缩小到多一层函数调用而已，不是特别严格的地方，还是用forEach好一点。
 * 因为forEach不止可以访问一个数组或List这样循环时能确定长度的集合，也可以访问可迭代的类型，
 * 对于一些不需要最开始就确定长度的，这样甚至效率更高
 * 因为不需要在循环开始之前就准备好要循环的数据，而是每次foreach循环获取下一个数据。
 */

// 在10万这个级别下， forEach 的性能是 for的十倍

// for: 2.263ms
// forEach: 0.254ms

// 在100万这个量级下， forEach 的性能是和for的一致

// for: 2.844ms
// forEach: 2.652ms

// 在1000万级以上的量级上 ， forEach 的性能远远低于for的性能

// for: 8.422ms
// forEach: 30.328m
```

## 数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少

```ts
/**
 * 无论是取第 1 个还是取第 10 万个元素，都是用 key 精确查找哈希表的过程，其消耗时间大致相同。
 * 数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)
 * 消耗时间几乎一致，差异可以忽略不计
 *
 * javascript中的数组
 * 数组( Array )在内存中用一串连续的区域来存放一些值。
 * 在 JavaScript 中，数组是哈希映射。
 * 现代浏览器的JavaScript 引擎已经在为同种数据类型的数组分配连续的存储空间了
 *
 *
 * 类型化数组
 * ArrayBuffer 会有一大块连续的存储位置，你能用它做任何你想做的事情。不过，直接处理内存涉及非常底层的操作，相当复杂。
 */
```

## 对象键名的转换

```ts
/**
 * 对象的键名的转换。
 * 对象的键名只能是字符串和 Symbol 类型。
 * 其他类型的键名会被转换成字符串类型。
 * 对象转字符串默认会调用 toString 方法。
 */
```

- example 1

```ts
var a = {},
  b = '123',
  c = 123;
a[b] = 'b';

// c 的键名会被转换成字符串'123'，这里会把 b 覆盖掉。
a[c] = 'c';

// 输出 c
console.log(a[b]);
```

- example 2

```ts
var a = {},
  b = Symbol('123'),
  c = Symbol('123');

// b 是 Symbol 类型，不需要转换。
a[b] = 'b';

// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。
a[c] = 'c';

// 输出 b
console.log(a[b]);
```

- example 3

```ts
var a = {},
  b = { key: '123' },
  c = { key: '456' };

// b 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。
a[b] = 'b';

// c 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。
a[c] = 'c';

// 输出 c
console.log(a[b]);
```

## input 搜索框如何实现防抖?如何实现中文输入?

```ts
/**
 * DOM0级事件处理：
 * 同时绑定几个不同的事件
 * 但是不能同时绑定多个相同的事件
 * 比如onclick；会覆盖，只会执行最后一个的函数
 *
 * DOM2级事件处理：
 * 优点：同时绑定几个事件（相同或不同），然后顺序执行，不会覆盖。
 * 比如addEventListener
 *
 */

// input事件
// 只要用户输入内容就会触发，即便输入中文输入法还没有将中文汉字填入搜索框内也会一直触发
dom.addEventListenter('input', function (e) {
  console.log(e);
});

// change 事件
// 在搜索框内容改变，并且失去焦点的时候触发
dom.addEventListener('change', function (e) {
  console.log(e);
});

// 中文输入
// 这三个事件是DOM2级别事件
// compositionstart：在中文输入的开始时触发一次
// compositionupdate：在中文输入过程中不断触发，效果类似oninput事件
// compositionend：在输入完毕通过输入法选择中文汉字填入搜索框时触发一次

var dom = document.getElementById('input1');

dom.addEventListener('change', function (e) {
  console.log('changed');
});

dom.addEventListener('compositionstart', function (e) {
  console.log('start');
  e.target.composing = true;
});

dom.addEventListener('compositionend', function (e) {
  console.log('end');
  e.target.composing = false;

  // 手动触发input事件
  var event = new Event('input');
  e.target.dispatchEvent(event);
});

dom.addEventListener('compositionupdate', function (e) {
  console.log('update');
});
```

## var、let 和 const 区别的实现原理是什么

```ts
/**
 * 区别
 * 1.var与let是可以声明变量，const不能声明变量，只能声明只读的常量。
 * 2.var声明的变量不存在块级作用域，他在全局内有效。let与const的声明只在其所在的代码块中有效。
 * 3.let/const不能在同一个作用域中声明相同变量/常量，var可以多次重复声明。
 * 4.var能先使用在声明，但是let const必须先声明再使用。
 * 5.let/const存在暂时性死区(所谓暂时死区，就是不能在初始化之前，使用变量 不然会报错)
 * Script snippet %236:5 Uncaught ReferenceError: Cannot access 'a' before initialization
 * 6.const声明时必须初始化赋值，一旦声明，其声明赋值的值就不允许改变，更不可以重复声明。
 * 如 const 声明了一个复合类型的常量，其存储的是一个引用地址，不允许改变的是这个地址，而对象本身是可变的。
 *
 *
 * 原理
 * var
 * 会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量
 * 如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针。
 *
 * let
 * 是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错。
 *
 * const
 * 也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。
 * 不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值
 * 对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性
 *
 *
 * 关于变量的提升
 * 1.let 的「创建」过程被提升了，但是初始化没有提升。
 * 2.var 的「创建」和「初始化」都被提升了。
 * 3.function 的「创建」「初始化」和「赋值」都被提升了。
 * 4.const 只有「创建」和「初始化」，没有「赋值」过程。
 *
 */
```

## 介绍下前端加密的常见场景和方法

```ts
/**
 * 1.HTTPS协议进行通信
 *
 * 2.加密分两种方式
 * 对称加密
 * 特点是文件加密和解密使用相同的密钥加密
 *
 * 非对称加密
 * 非对称加密算法需要两个密钥：公钥（publickey）和私钥（privatekey）
 * 如果用公钥对数据进行加密，只有用对应的私钥才能解密；
 * 如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。
 *
 * 甲方生成一对密钥并将其中的一把作为公钥向其它方公开；
 * 得到该公钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；
 * 甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。
 */
```

- 第一种就是 base64 格式的加密与解密

```ts
var str = 'RUNOOB';
var enc = window.btoa(str); //编码成base64的
var dec = window.atob(enc); //把base64解码
var res = '编码字符串为: ' + enc + '<br>' + '解码后字符串为: ' + dec;
console.log(res);

// 当遇到中文时，需要先对中文转码否则会乱码。
var str = btoa(encodeURIComponent('中文汉字'));
//还可以解码回来
decodeURIComponent(atob(enc)); // =>  中文汉字
```

- 第二种 MD5 加密

```html
<!-- 首先引入相关js,对要加密的内容直接加密 -->

<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
  var b =$("#logPassword");
  $.md5(b.val())

  // MD5没有解密算法，或者说解密算法很复杂，所以可以在数据库中存放经过两次MD5加密的的内容，也可以再配合加‘盐’。
  console.log(md5(md5("Condor Hero") + "a"));
<script>

```

- 第三种加密 RSA 用公钥私钥加密解密

```html
<!-- 先引入相关配置文件 -->
<script src="js/jsencrypt.js"></script>

<script>
  // 前端在向后台发起登录请求之前，先请求后台获取公钥的方法
  var publicKey = null;
  $.ajax({
    url: 'xxx',
    type: 'post',
    dataType: 'text',
    success: function (data) {
      var encrypt = new JSEncrypt();
      if (data) {
        publicKey = data;
      }
    },
  });

  // 通过公钥对用户名和密码加密
  encrypt.setPublicKey(publicKey);
  var username;
  var password;
  username = encrypt.encrypt(vm.username.trim());
  password = encrypt.encrypt(vm.password.trim());

  // 接下来就是用加密后的用户名密码请求后台，用户名密码传输时千万不要字符串拼接方式传输
  $.ajax({
    type: 'POST',
    url: 'xxxxxx',
    data: {
      username: username,
      password: password,
    },
    dataType: 'json',
    success: function (result) {
      if (result.code == 0) {
        //登录成功
        parent.location.href = 'index.html';
      } else {
        vm.error = true;
        vm.errorMsg = result.msg;
        vm.refreshCode();
      }
    },
  });
</script>
```

- 第四种加密 sha1

```html
<!-- 引入配置文件 -->
<script type="text/ecmascript" src="sha1.js"></script>

<script>
  // sha1加密是一种不可逆的加密方式，将明文转换成一段散列值（摘要），
  // 将报文摘要加密后与明文一起传送给接受方，接受方将接受的明文产生新的报文摘要与发送方的发来报文摘要解密比较，
  // 比较结果一致表示明文未被改动，如果不一致表示明文已被篡改。
  var sha = hex_sha1('mima123465');
  console.log(sha);
</script>
```

## 以下表达式的运行结果

```txt
加性操作符：如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来
1 + "1" // 11 字符串

乘性操作符：如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值
2 * "2" // 4 数字

Javascript中所有对象基本都是先调用valueOf方法，如果不是数值，再调用toString方法
[1, 2] + [2, 1] // 1,22,1 // 字符串

后边的“+”将作为一元操作符，如果操作数是字符串，将调用Number方法将该操作数转为数值，如果操作数无法转为数值，则为NaN。
"a" + + "b" // "aNaN"
```

## 为什么 for 循环嵌套顺序会影响性能

```ts
// 循环一
// 第一个循环的 j 的初始化次数是 100 次，k 的初始化次数是 10w 次
var t1 = new Date().getTime();
for (let i = 0; i < 100; i++) {
  for (let j = 0; j < 1000; j++) {
    for (let k = 0; k < 10000; k++) {}
  }
}
var t2 = new Date().getTime();
console.log('first time', t2 - t1); // first time 327

// 循环二
// 第二个循环的 j 的初始化次数是 1w 次， k 的初始化次数是 1000w 次
for (let i = 0; i < 10000; i++) {
  for (let j = 0; j < 1000; j++) {
    for (let k = 0; k < 100; k++) {}
  }
}
var t3 = new Date().getTime();
console.log('two time', t3 - t2); // two time 509

// 结论: 所以相同循环次数，外层越大，越影响性能
```

## 理解消息队列

```ts
// new Promise(xx)相当于同步任务, 会立即执行
function wait() {
  return new Promise((resolve) => setTimeout(resolve, 10 * 1000));
}

async function main() {
  console.time();
  const x = wait();
  const y = wait();
  const z = wait();
  await x;
  await y;
  await z;
  console.timeEnd();
  // x,y,z 三个任务是几乎同时开始的, 最后的时间依然是10*1000ms (比这稍微大一点点)
  // 10001.6748046875 ms
}
main();
```

## 如何实现骨架屏

```ts
/**
 * 骨架屏是结合了懒加载功能，在页面没有加载完成之前，先呈现页面基本结构。
 * Skeleton Screen 能给人一种页面内容“已经渲染出一部分”的感觉，
 * 相较于传统的 loading 效果，在一定程度上可提升用户体验。
 *
 * 实现方案
 * 1.方案1
 * 在页面元素后面增加一个骨架div，当页面加载完成后就隐藏这个div
 * 缺点：但是面对视觉设计的改版以及需求的更迭，我们对骨架屏的跟进修改会非常被动
 * 2.方案2
 * 在页面元素结构中先嵌入骨架div，当页面加载完成后就替换这个div
 * 3.通过伪元素实现骨架样式，通过操作样式实现骨架和页面的动态切换
 */
```

## 单词

```pug
recursion 递归
memorization 记忆
radix 基数
debounce 去抖动
throttle 节流
intersect 交集
clash 冲突
collection 收藏
recast 改动
composition 作品
crypto 密码
skeleton 骨架
yield 让步
generator 发电机;发生器
```
