## 工程化

## 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块

- npm 模块安装机制

```ts
/**
 * Node模块的安装过程
 * 1.发出npm install命令
 * 安装之前，npm install会先检查，node_modules目录之中是否已经存在指定模块。
 * 如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此
 * npm 都要强制重新安装，可以使用-f或--force参数
 * npm install <packageName> --force
 *
 * 2.npm 向 registry 查询模块压缩包的网址
 * 3.下载压缩包，存放在~/.npm目录
 * 从 registry 下载压缩包之后，都存放在本地的缓存目录。
 * 4.解压压缩包到当前项目的node_modules目录
 *
 * 离线安装的解决方案
 * 第一类，Registry 代理。
 * 都是在本机起一个 Registry 服务，所有npm install命令都要通过这个服务代理
 * # npm-proxy-cache
 * $ npm --proxy http://localhost:8080 \
 *  --https-proxy http://localhost:8080 \
 *  --strict-ssl false \
 *  install
 *
 * # local-npm
 * $ npm set registry http://127.0.0.1:5080
 *
 * # npm-lazy
 * $ npm --registry http://localhost:8080/ install socket.io
 */
```

- npm install 的执行流程

```ts
/**
 * 1.执行工程自身的preinstall,如果有定义preinstall钩子此时会被执行
 * 2.确认首层依赖模块,也就是package.json中dependencies和devDependencies属性中指定的模块
 * npm会开启多进程从每个首层依赖模块逐步寻找更深层级的依赖节点
 * 3.递归获取模块
 * 获取模块信息,确定下载模块版本(优先从pakage-lock.json文件中获取,没有则从仓库中获取)
 * 获取模块实体,从模块信息中得到模块的压缩包地址,npm会用此地址检查本地缓存,缓存中有拿缓存中的,没有则从仓库中下载
 * 查询该模块的依赖,如果有依赖则回到第一步,没有则停止
 * 4.模块扁平化
 * 处理重复模块,会遍历所有节点,将模块逐个放到node_modules的第一层,当发现重复模块(模块名称相同且版本兼容)就会去掉
 * 如果存在不兼容版本则模块依然留在模块树中
 * 5.安装模块
 * 更新工程中的node_modules并执行模块中的生命周期函数
 * 6.执行工程自身生命周期,并生成或更新版本描述文件
 * npm install过程完成
 */
```

## 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的

```ts
/**
 * webpack热更新，也称热替换
 * 让web项目可以在开发环境下，每次更改文件后无需重刷浏览器，即可看见更改的效果
 *
 * webpack-dev-server
 * 1.一个基于node.js和webpack的简易服务器
 * 2.webpack-dev-middleware
 * 一个中间件，用于与webpack的compiler对象绑定，在dev-server启动时会调用
 * 通过watch mode，监听资源变更，然后自动打包
 * 打包后的文件存入内存中，而不是磁盘。
 * 支持HMR
 *
 *
 * webpack-dev-server/client entry
 * 注入热更新代码,保证服务端和客户端能够通信
 * 会在入口文件中注入一个用于与服务端进行一个websocket连接的脚本，并对服务端的消息作出响应及消息传递。
 *
 * 关于HMR.runtime：
 * HotModuleReplacementPlugin插件提供，用于在浏览器端请求更新后的资源以及进行热替换操作。
 *
 * 关于webpack/hot/dev-server：
 * 根据webpack-dev-server/client传递的消息，决定是进行live reload浏览器刷新还是热更新。
 */
```

- 热更新流程

```ts
/**
 * 1.在webpack watch模式下更新代码，webpack会自动进行构建。
 * 2.webpack-dev-middleware对webpack进行监控并告诉webpack将资源打包到内存中，保存为一个Javascript对象
 * 3.如果更该的是静态文件即在非入口文件如.html文件,则直接更新浏览器
 * 4.如果文件有变化则WDS服务端会传递的新模块hash值给HMR.runtime，告诉它有文件更新了
 * JsonpMainTemplate.runtime向server端发送Ajax请求，请求返回所有要更新的模块的列表
 * 通过jsonp请求，获取到最新的模块代码
 * 5.更新模块，HMR会对新旧模块进行对比，决定是否更新模块，
 * 决定更新后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用
 * 6.如果上一步HMR更新失败，则回退到浏览器刷新的操作
 *
 * 问题
 * 在webpack中，监听一个文件发生变化的原理是定时获取该文件的最后编辑时间
 * WDS修改了webpack配置中的entry属性，在里面添加了webpack-dev-server/client的代码，
 * 这样在最后生成的bundle.js文件中就有了这一部分的代码
 */
```
