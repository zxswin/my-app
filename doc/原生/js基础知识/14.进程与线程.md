## 进程与线程

- 进程与线程

```ts
/**
 * 进程(process)
 * 程序的一次执行 它占有一片独有的内存空间
 * 可以通过window任务管理器查看进程
 *
 * 线程(thread)
 * 是进程内的一个独立执行单元
 * 是程序执行的一个完整流程
 * 是CPU的最小的调度单元
 *
 * 1.运用程序必须运行在某个进程的某个线程上
 * 2.一个进程中至少有一个运行的线程：主线程 在线程启动后自动创建
 * 3.一个进程中也可以同时运行多个线程 我们会说程序是多线程运行的
 * 4.一个进程内的数据可以供其中的多个线程直接共享
 * 5.多个进程之间的数据是不能直接共享的
 * 6.线程池(thread):保存多个线程对象的容器,实现线程对象的反复利用
 *
 * 问题1:何为多进程和多线程
 * 多进程运行：一个应用程序可以同时启动多个(进程)实例运行
 * 多线程：在一个进程内,同时有多个线程运行
 *
 * 问题2:比较单线程和多线程
 * 多线程：优点
 * 1.能有效提升cup的利用率
 * 多线程：缺点
 * 1.创建多线程的开销
 * 2.线程间的切换开销
 * 3.死锁与状态同步问题
 *
 * 单线程(优点)
 * 顺序编程简单易懂
 *
 * 单线程(缺点)
 * 效率低
 *
 *
 * 问题3:JS是单线程还是多线程
 * js是单线程运行的
 * 但使用H5中的Web Workers可以多线程运行
 *
 * 问题4:浏览器运行是单线程还是多线程
 * 浏览器是多线程运行的
 *
 *
 * 问题5:浏览器运行是单进程还是多进程
 * 有的是单进程例如firefox 和老版本的IE
 * 有的是多进程的如chrome 和新版的IE
 *
 */
```

- 浏览器内核

```ts
/**
 * 1.什么是浏览器的内核
 * 支持浏览器运行的核心程序
 *
 * 2.不同浏览器可能不一样
 * Chrome , Safari : webkit
 * firefox: Gecko
 * IE: Trident
 * 360 搜狗等国内浏览器: Trident + webkit
 *
 * 3.内核由很多模块组成
 * - 主线程
 * js引擎模块:负责js程序的编译与运行
 * html,css文档解析模块:负责页面文本的解析
 * DOM/CSS模块:负责dom/css在内存中的相关处理
 * 布局和渲染模块:负责页面的布局和效果的绘制(内存中的对象)
 * - 分线程
 * 定时器模块: 负责定时器的管理
 * DOM事件响应模块: 负责事件的处理
 * 网络请求模块: 负责ajax请求
 * 其他模块
 */
```

- 关于定时器

```ts
/**
 * 1.定时器真的是定时执行的吗
 * 定时器并不能保证真正定时执行
 * 一般会延迟一丁点（可以接受）,也可能延迟很长事件(不能接受)
 * 2.定时器回调函数是在那个线程执行的
 * 在主线程中执行,js是单线程的
 * 3.定时器是如何实现的
 * 通过事件循环模型
 *
 * alert()
 * 暂停当前主线程的执行 回同时暂停计时 点击确认后 恢复程序执行和计时
 */

let start = Date.now();

setTimeout(() => {
  console.log(`定时器执行了${Date.now() - start}`);
}, 200);
```

- 如何说明 JS 运行是单线程的

```ts
/**
 * 1.如何证明js执行是单线程的
 * setTimeout()的回调函数是在主线程上执行的
 * 定时器的回调函数只有在运行栈中的代码全部执行完后才有可能执行
 *
 * 2.为什么js要用单线程模式 而不用多线程模式
 * javaScript的单线程与它的用途有关
 * 作为浏览器脚本语言 javaScript的主要用途是与用户互动以及操作DOM
 * 这决定了它只能是单线程的 否则回带来很复杂的同步问题
 * 只能有一个线程去更新界面

 * 3.代码的分类
 * 初始化代码
 * 回调代码
 *
 * 4.js引擎执行代码的基本流程
 * 先执行初始化的代码:包含一些特别的代码
 * 设置定时器
 * 绑定监听
 * 发生ajax请求
 * 后面在某个时刻才会执行回调代码
 */
```

- 事件循环模型

```ts
/**
 * 1.所有代码分类
 * 初始化执行代码(同步代码):包括绑定dom事件监听 设置定时器 发送ajax请求的代码
 * 回调执行代码(异步代码) 处理回调逻辑
 *
 * 2.js 引擎执行代码的基本流程
 * 初始化代码===> 回调代码
 * 3.模型有两个重要的组成部分:
 * 事件管理模块(定时器/DOM事件/Ajax)
 * 回调队列
 * 4.模型的运转流程
 * 执行初始化代码,将事件回调函数交给对应的模块管理
 * 当事件发生时，管理模块会将回调函数及其数据添加到回调队列中
 * 只有当初始化代码执行完后(可能需要一定的时间) 事件循环机制才回遍历读取回调队列中的回调函数执行
 *
 *
 * 相关重要概念
 * 1.执行栈
 * execution stack 所有代码都是在此空间中执行
 * 2.浏览器内核
 * js引擎模块(在主线程处理)
 * 其他模块(在主/分线程处理)
 *
 * - callback queue 回调队列
 * 3.任务队列 task queue
 * 4.消息队列 message queue
 * 5.事件队列 event queue
 *
 * 6.事件轮询
 * event loop 从任务队列中循环取出回调函数放入执行栈中处理(一个接一个)
 *
 * 7.事件驱动模型
 * event-driven interaction model
 * 8.事件响应模型
 * request-response model
 */
```

- H5 中的 Web Workers 可以多线程运行

```ts
/**
 * 1.H5规范提供了js分线程的实现 取名为Web Workers
 * 我们可以将一些大计算量的代码交由web Worker运行而不冻结用户界面
 * 但是子线程完全受主线程控制,且不得操作DOM
 * 所以,这个新标准并没有改变JavaScript单线程的本质
 * 2.相关API
 * Worker:构造函数 加载分线程执行的js文件
 * Worker.prototype.onmessage: 用于接收另一个线程的回调函数
 * Worker.prototype.postMessage:向另一个线程发送消息
 *
 * 3.不足
 * worker内代码不能操作DOM(更新ui)
 * 不能跨域加载JS
 * 不是每个浏览器都支持这个新特性
 */
```

- 多线程 workers 的简单用例子

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>worker多线程代码测试用例</title>
  </head>
  <body>
    <input id="input1" type="text" />
    <button id="btn1">计算</button>
    <script src="./index.js"></script>
  </body>
</html>
```

```js
// 主线程代码
const inputel = document.querySelector('#input1');
const btn = document.querySelector('#btn1');
btn.addEventListener('click', () => {
  console.log('点击按钮了');
  const num = inputel.value;
  console.log('num', num);

  // 执行多线程
  const worker = new Worker('./worker.js');
  worker.onmessage = (event) => {
    console.log('主线程接收到子进程的消息', event.data);
    console.log('最后算出来的结果', event.data);
  };

  // 主线程向子线程发送消息
  worker.postMessage(num);
});
```

```js
// 子线程代码
function countFn(num) {
  return num < 2 ? 1 : countFn(num - 1) + countFn(num - 2);
}

// 子线程监听主进程事件
// self.addEventListener(
//   'message',
//   function (event) {
//     console.log('子线程的this', this);
//     console.log('子进程接收到主线程发送过来的数据', event.data);
//     const num = event.data;
//     const result = countFn(num);
//     // 向主线程发送计算结果
//     self.postMessage(result);
//     self.close();
//   },
//   false
// );

// 也可以这么写
self.onmessage = (event) => {
  console.log('子线程的this', this);
  console.log('子进程接收到主线程发送过来的数据', event.data);
  const num = event.data;
  const result = countFn(num);
  // 向主线程发送计算结果
  self.postMessage(result);
  self.close();
};
```
