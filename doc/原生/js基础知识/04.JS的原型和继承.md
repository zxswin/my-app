## JS 的原型和继承

- 原型初步认识

```ts
let hd = {};
let xj = {};

// hd 和 xj 这两个对象拥有同一个原型链
console.log(Object.getPrototypeOf(hd) === Object.getPrototypeOf(xj));
```

- 没有原型的对象也是存在的

```ts
// 创建一个没有原型的对象
// 完全数据字典对象
let hd = Object.create(null, {
  name: {
    value: "abc",
  },
});

console.log(hd); // 打印出没有原型的对象
console.log(hd.hasOwnProperty("name")); // 此处会报错
```

- 原型方法与对象方法优先级别

```ts
// 会优先执行对象方法
let hd = {
  show() {},
  render() {
    console.log("a");
  },
};
console.log(hd);
hd.__proto__.render = () => {
  console.log("b");
};

hd.render(); // 打印出a
```

- 函数拥有多个长辈

```ts
function User() {}

console.log(User);
console.dir(User); // dir可以打印出函数的详细结构

// prototype 构造函数实例化出来对象的原型链
User.prototype.show = function () {
  console.log("a");
};
let hd = new User();
hd.show();
console.log(User.prototype === hd.__proto__); // true
// __proto__: 构造函数自己的原型链

User.__proto__.view = function () {
  console.log("b");
};

User.view(); // 可以打印出b
```

- 原型关系详解与属性继承实例

```ts
let hd = new Object();
hd.name = "后盾人";

Object.prototype.show = function () {
  console.log("a");
};

function User() {}
console.dir(User);

console.log(User.prototype.__proto__ === User.__proto__.__proto__);

// Object 的原型链最终指向null
console.dir(Object.prototype.__proto__); // null
```

- 系统构造函数的原型体现

```ts
let arr = [];
console.log(arr.__proto__ === Array.prototype);

let str = "";
console.log(str.__proto__ === String.prototype);

let bool = true;
console.log(bool.__proto__ === Boolean.prototype);

let reg = /a/i;

console.log(reg.__proto__ === RegExp.prototype);
```

- 自定义原型的对象设置

```ts
// 设置对象的原型
let hd = { name: "a" };
let parent = { name: "parent" };
Object.setPrototypeOf(hd, parent);
console.log(hd);
Object.getPrototypeOf(hd); // 获取对象的原型
```

- 原型中 constructor 的引用

```ts
function User(name) {
  this.name = name;
}

// 往原型中添加方法 第一种方式
User.prototype.show = function () {
  console.log(this.name);
};

// 往原型种添加方法的第二种方式
User.prototype = {
  // 因为是指向新的引用对象 所以要从新设置constructor属性并指向自己
  constructor: User,
  show() {
    console.log(this.name + "aaa");
  },
};

console.dir(User);

console.log(User.prototype.__proto__ === Object.prototype);

// User 的 constructor 构造函数指向它自己
console.log(User.prototype.constructor === User); // true

// 可以通过下面的方式来创建对象
let list = new User.prototype.constructor("李四");

console.log(list);

list.show();
```

- 给我一个对象,还你一个世界

```ts
function User(name) {
  this.name = name;
}

User.prototype = {
  // 因为是指向新的引用对象 所以要从新设置constructor属性并指向自己
  constructor: User,
  show() {
    console.log(this.name + "aaa");
  },
};

let hd = new User("后盾人");

function createByObject(obj, ...args) {
  const constructor = Object.getPrototypeOf(obj).constructor;

  return new constructor(...args);
}
let xj = createByObject(hd, "bbbb");

xj.show();
```

- 总结一些原形链

```ts
let arr = [];
console.log(arr);
// length: 0
// __proto__: Array(0)

console.log(arr.__proto__.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__); // null
```

- 原型链检测之 instanceof

```ts
// instanceof 检测对象的原型链上是否有另一个构造函数对象的prototype属性
// 用于判断构造函数
// 一个比较简单的例子
function A() {}
function B() {}

let b = new B();
A.prototype = b;
let a = new A();

console.log(a instanceof A); // true
console.log(a instanceof B); // false

// 一个比较复杂的例子
function A() {
  this.name = "a";
}
function B() {
  this.name = "b";
}
function C() {
  this.name = "c";
}

let c = new C();
B.prototype = c;
let b = new B();
A.prototype = b;
let a = new A();

console.log(a);

console.log(a instanceof A); // true
console.log(a instanceof B); // true
console.log(a instanceof C); // true
console.log(b instanceof A); // false
```

- 原型检测 Object.isPrototypeOf

```ts
// 检测一个对象是否在另一个对象的原型链上
// 用于对象判断
let a = {};
let b = {};
let c = {};
Object.setPrototypeOf(b, c); // 设置原型
Object.setPrototypeOf(a, b); // 设置原型

console.log(b.isPrototypeOf(a)); // true
console.log(c.isPrototypeOf(a)); // true
console.log(c.isPrototypeOf(b)); // true
```

- in 与 hasOwnProperty 的属性检测差异

```ts
// in 用于检测某个属性是否在某个对象上或者在某个对象的原型链上
let a = { url: "www.abc.com" };
let b = { name: "abc" };
console.log("url" in a); // true

Object.setPrototypeOf(a, b);
console.log("name" in a); // true

Object.prototype.web = "www.aaa.com";
console.log("web" in a); // true

// hasOwnPrototype 用于检测自身上面的属性
for (const key in a) {
  console.log("in key", key);
  if (a.hasOwnProperty(key)) {
    console.log("a hasOwnProperty", key);
  }
}
```

- 使用 call 和 apply 借用原型链

```ts
let hd = {
  data: [1, 2, 3, 34, 5, 7],
};

Object.setPrototypeOf(hd, {
  max() {
    return this.data.sort((a, b) => b - a)[0];
  },
});

console.log(hd.max());

let xj = {
  lessons: { js: 87, php: 63, node: 99, linux: 88 },

  get data() {
    return Object.values(this.lessons);
  },
};

console.log(hd.max.apply(xj));
```

- 优化方法借用

```ts
let hd = {
  data: [1, 2, 3, 34, 5, 7],
};

console.log(Math.max.apply(null, hd.data));

let xj = {
  lessons: { js: 87, php: 63, node: 99, linux: 88 },
};

console.log(Math.max.apply(null, Object.values(xj.lessons)));
```

- DOM 节点借用 Array 原型方法

```ts
let btns = document.querySelectorAll("button");

// 第一种使用方法
btns = Array.prototype.filter.call(btns, (item) => {
  return item.hasAttribute("class");
});

// 第二种使用方法
btns = [].filter.call(btns, (item) => {
  return item.hasAttribute("class");
});

console.log(btns);
```

- 合理的构造函数方法声明

```ts
function User(name) {
  this.name = name;
}

User.prototype = {
  constructor: User,
  show() {
    console.log(this.name);
  },
  get() {
    console.log("get...");
  },
};

let list = new User("李四");

let xj = new User("向军");

list.show();
xj.show();
```

- this 和 原型没有关系的

```ts
// 方法中的this永远指向调用它的对象
let hd = {
  name: "后盾人",
};

let User = {
  name: "向军",
  show() {
    console.log(this.name);
  },
};

Object.setPrototypeOf(hd, User);
hd.show(); // 后盾人
```

- Object.create 与 '**proto**'

```ts
// Object.create 与 __proto__

// Object.create 只能定义对象的原型 不能获取

let user = {
  show() {
    return this.name;
  },
};

let hd = Object.create(user, {
  name: {
    value: "abc",
  },
});
console.log(hd.show());

// 第二种定义对象原型的方法 非官方
let hd = { name: "后盾人" };
hd.__proto__ = user;
console.log(hd.show());

// 使用 setPrototypeOf 推荐
Object.setPrototypeOf(hd, user);
console.log(hd.show());
console.log(Object.getPrototypeOf(hd)); // 获取到原型
```

- --proto--原来是属性访问器

```ts
// __proto__原来是属性访问器
// __proto__ getter setter
// get __proto__: ƒ __proto__()
// set __proto__: ƒ __proto__()
// 访问或设置__proto__时候实际上经过来属性拦截器
// __proto__ 只能设置为对象 字符串是设置不进去的
let hd = { name: "abc" };
hd.__proto__ = {
  show() {
    console.log(this.name);
  },
};

hd.__proto__ = 99; // 设置无效 只有对象才可以设置进去
hd.show();

// __proto__拦截器实现原理
let hd = {
  action: {},
  get proto() {
    return this.action;
  },
  set proto(obj) {
    if (obj instanceof Object) {
      this.action = obj;
    }
  },
};

hd.proto = "abc";
console.log(hd.proto);

// 一种让__proto__设置为字符串的方法
let hd = Object.create(null);
console.dir(hd);

hd.__proto__ = "后盾人";
console.dir(hd.__proto__);
```

- 改变构造函数原型并不是继承

```ts
// 继承是原型的继承
function User() {}
User.prototype.name = function () {
  console.log("user.name");
};

function Admin() {}

// 继承方法一
// Admin.prototype.__proto__ = User.prototype;

// 继承方法二
Admin.prototype = Object.create(User.prototype);
// 要记得重新设置constructor
// Admin.prototype.constructor = Admin;
// 禁止 constructor 被遍历
Object.defineProperty(Admin.prototype, "constructor", {
  value: Admin,
  enumerable: false,
});

// {__proto__:User.prototype,role:function(){}}
Admin.prototype.role = function () {
  console.log("admin.role");
};

let a = new Admin();
a.name();
a.role();

for (const key in a) {
  console.log(key);
}
```

- 方法重写与父级属性访问

```ts
function User() {}
User.prototype.show = function () {
  console.log("user.name");
};
User.prototype.site = function () {
  return "abc";
};

function Admin() {}
Admin.prototype = Object.create(User.prototype);

Admin.prototype.constructor = Admin;
Admin.prototype.show = function () {
  console.log(User.prototype.site() + "admin.show");
};

let hd = new Admin();
hd.show();
```

- 面向对象的多态

```ts
// 同一个show方法会显示不同的描述信息
function User() {}
User.prototype.show = function () {
  console.log(this.description());
};

function Admin() {}
Admin.prototype = Object.create(User.prototype);
Admin.prototype.description = function () {
  return "管理员";
};

function Member() {}
Member.prototype = Object.create(User.prototype);
Member.prototype.description = function () {
  return "会员";
};

for (const obj of [new Admin(), new Member()]) {
  obj.show(); // 不同的对象会显示不同的show描述信息
}
```

- 使用父类构造函数初始属性

```ts
function User(name, age) {
  this.name = name;
  this.age = age;
}

User.prototype.show = function () {
  console.log(this.name, this.age);
};

function Admin(...args) {
  // 使用父类构造函数初始属性
  User.apply(this, args);
}

Admin.prototype = Object.create(User.prototype);
let xj = new Admin("aaa", 18);
xj.show();
```

- 使用原型工厂封装继承

```ts
function extend(sub, sup) {
  sub.prototype = Object.create(sup.prototype);
  Object.defineProperty(sub.prototype, "constructor", {
    value: sub,
    enumerable: false,
  });
}

function User(name, age) {
  this.name = name;
  this.age = age;
}
User.prototype.show = function () {
  console.log(this.name, this.age);
};

function Admin(...args) {
  // 使用父类构造函数初始属性
  User.apply(this, args);
}

extend(Admin, User);

let a = new Admin("a", 18);
a.show();
```

- 对象方法派生对象并实现继承

```ts
function User(name, age) {
  this.name = name;
  this.age = age;
}
User.prototype.show = function () {
  console.log(this.name, this.age);
};

// 对象方法派生对象并实现继承
function admin(name, age) {
  const instance = Object.create(User.prototype);
  User.call(instance, name, age);
  instance.role = function () {
    console.log("role");
  };
  return instance;
}

let hd = admin("abc", 19);
hd.show();
hd.role();
```

- 多继承造成的困扰 使用 mixin 实现多继承

```ts
// js并不支持多继承

// 使用 mixin 实现多继承
function extend(sub, sup) {
  sub.prototype = Object.create(sup.prototype);
  Object.defineProperty(sub.prototype, "constructor", {
    value: sub,
    enumerable: false,
  });
}

function User(name, age) {
  this.name = name;
  this.age = age;
}

User.prototype.show = function () {
  console.log(this.name, this.age);
};

// 一些工具方法
const Credit = {
  total() {
    console.log("积分统计");
  },
};

const Request = {
  ajax() {
    console.log("请求后台");
  },
};

User.prototype = Object.assign(User.prototype, Credit, Request);

function Admin(...args) {
  // 使用父类构造函数初始属性
  User.apply(this, args);
}

extend(Admin, User);

let a = new Admin("a", 18);
a.show();
a.total();
a.ajax();
```

- mixin 的内部继承与 super 关键字

```ts
function extend(sub, sup) {
  sub.prototype = Object.create(sup.prototype);
  Object.defineProperty(sub.prototype, "constructor", {
    value: sub,
    enumerable: false,
  });
}

function User(name, age) {
  this.name = name;
  this.age = age;
}

User.prototype.show = function () {
  console.log(this.name, this.age);
};

// 一些工具方法

const Request = {
  ajax() {
    return "请求后台";
  },
};

const Credit = {
  __proto__: Request,
  total() {
    // super = this.__proto__
    console.log(super.ajax() + "积分统计");
  },
};

console.log("Credit", Credit);

User.prototype = Object.assign(User.prototype, Credit);

function Admin(...args) {
  // 使用父类构造函数初始属性
  User.apply(this, args);
}

extend(Admin, User);

let a = new Admin("a", 18);
a.show();
a.total();
```

- tab 选项卡显示效果基类开发

```ts
function extend(sub, sup) {
  sub.prototype = Object.create(sup.prototype);
  Object.defineProperty(sub.prototype, "constructor", {
    value: sub,
    enumerable: false,
  });
}

function Animation() {}

Animation.prototype.show = function () {
  this.style.display = "black";
};

Animation.prototype.hide = function () {
  this.style.display = "none";
};

Animation.prototype.background = function (color) {
  this.style.background = color;
};

let tab = document.querySelector(".tab");

// 使用this替换的方式来调用
Animation.prototype.background.call(tab, "red");

function Tab(el, callback) {
  this.tab = document.querySelector(el);
  this.links = this.tab.querySelectorAll("button");
  this.sections = this.tab.querySelectorAll("section");
  this.callback = callback; // 切换后的回调函数
}

extend(Tab, Animation);

Tab.prototype.run = function () {
  this.bindEvent();
  this.reset();
  this.action(0);
};

Tab.prototype.bindEvent = function () {
  this.links.forEach((el, i) => {
    el.addEventListener("click", () => {
      this.action(i);
    });
  });
};

Tab.prototype.action = function (i) {
  this.background.call(this.links[i], "red");
  this.show.call(this.sections[i]);
  this.callback();
};

// 重置方法
Tab.prototype.reset = function () {
  this.links.forEach((el, i) => {
    this.background.call(this.links[i], "blue");
    this.hide.call(this.sections[i]);
  });
};

new Tab(".tab", function () {
  console.log("切换后的回调函数");
}).run();
```

## 单词

```pug
credit 信用
member 会员
access 接近 权利 入口
mixin 混合 混入
```
