## 装饰器

- 基本概念

```ts
/**
 * 装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。
 * 这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。
 */
```

- 类装饰器

```ts
/**
 * 装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。
 */
@testable
class MyTestableClass {
  // ...
}

function testable(target) {
  target.isTestable = true;
}

MyTestableClass.isTestable; // true

/**
 * 原理剖析
 * 基本上，装饰器的行为就是下面这样
 */

@decorator
class A {}

// 等同于

class A {}
A = decorator(A) || A;

/**
 * 装饰器外面再封装一层函数,用于传入其他的参数
 */
function testable(isTestable) {
  return function (target) {
    target.isTestable = isTestable;
  };
}

@testable(true)
class MyTestableClass {}
MyTestableClass.isTestable; // true

@testable(false)
class MyClass {}
MyClass.isTestable; // false

/**
 * 通过目标类的prototype对象给类添加实例属性
 */
function testable(target) {
  target.prototype.isTestable = true;
}

@testable
class MyTestableClass {}

let obj = new MyTestableClass();
obj.isTestable; // true

/**
 * 通过装饰器来实现一个混合类
 */
// mixins.js
export function mixins(...list) {
  return function (target) {
    Object.assign(target.prototype, ...list);
  };
}

// main.js
import { mixins } from './mixins';

const Foo = {
  foo() {
    console.log('foo');
  },
};

@mixins(Foo)
class MyClass {}

let obj = new MyClass();
obj.foo(); // 'foo'
```

- 方法的装饰器

```ts
/**
 * 如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行
 * 装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升
 */

class Mathfn {
  @log
  add(a, b) {
    return a + b;
  }
}

console.dir(Mathfn);

function log(target, name, descriptor) {
  // 装饰器第一个参数是类的原型对象，Mathfn.ptotoType
  // 装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型
  // 第二个参数是所要装饰的属性名，
  // 第三个参数是该属性的描述对象
  console.log('target', target);
  var oldValue = descriptor.value;
  // descriptor对象原来的值如下
  // {
  //   value: specifiedFunction,
  //   enumerable: false,
  //   configurable: true,
  //   writable: true
  // };

  descriptor.value = function () {
    console.log(`Calling ${name} with`, arguments);
    // 后面math实例调用了这个方法,所有this指向了math的实例
    return oldValue.apply(this, arguments);
  };

  return descriptor;
}

const math = new Mathfn();

math.add(2, 4);
```

- 装饰器类不能用于装饰普通的方法

```ts
/**
 * 由于存在函数提升，使得装饰器不能用于函数。
 * 类是不会提升的，所以就没有这方面的问题
 */

var readOnly = require('some-decorator');

@readOnly
function foo() {}

// 实际代码运行是这样的
var readOnly;

@readOnly
function foo() {}

readOnly = require('some-decorator');

/**
 * 高阶函数的形式直接执行,装饰普通方法
 */
function doSomething(name) {
  console.log('Hello, ' + name);
}

function loggingDecorator(wrapped) {
  return function () {
    console.log('Starting');
    const result = wrapped.apply(this, arguments);
    console.log('Finished');
    return result;
  };
}

const wrapped = loggingDecorator(doSomething);
```

- 属性装饰器

```ts
/**
 * 属性装饰器表达式会在运行时当作函数被调用，
 * 传入下列2个参数：
 * 1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
 * 2、成员的名字。
 */

//属性装饰器
function logProperty(params: any) {
  return function (target: any, attr: any) {
    console.log(target); // 对于实例成员是类的原型对象。
    console.log(attr); // 要装饰的属性
    target[attr] = params;
  };
}

class HttpClient {
  @logProperty('http://loaderman.com')
  public url: any | undefined;
  constructor() {}
  getData() {
    console.log(this.url);
  }
}
var http = new HttpClient();
console.log('http', http);
http.getData();
```
