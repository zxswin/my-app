## ES6 中类

- class 声明类的语法

```ts
class User {
  constructor(name) {
    this.name = name;
  }
  // 方法后面是不需要加逗号的
  getName() {
    return this.name;
  }
}

let hd = new User("后盾人");

console.log(hd.getName());
```

- 对象属性的声明

```ts
class User {
  site = "aaa";

  constructor(name) {
    this.name = name; // 这里声明的属性值是实例对象独有的
  }
}

let hd = new User("ccc");

console.log(hd);
console.dir(hd);
```

- class 声明的方法为什么不能被遍历

```ts
// class声明的方法是不能被遍历的
class User {
  constructor(name) {
    this.name = name;
  }
  show() {}
}

let u = new User("abc");

console.dir(User);
console.log(
  JSON.stringify(
    Object.getOwnPropertyDescriptor(User.prototype, "show", null, 2)
  )
);

for (const key in u) {
  console.log(key); // 只打印出来name
}
```

- class 声明的类默认启用严格模式

```ts
class Hd {
  show() {
    function test() {
      console.log(this); // undefined 传统的构造函数非严格模式下是window
    }
    test();
  }
}

let hd = new Hd();
hd.show();
```

- 静态属性的使用

```ts
// 传统模式下的静态属性设置方法
function Web(url) {
  this.url = url;
}

Web.url = "abc.com"; // 设置静态属性
let hd = new Web("ccc.com");

console.log(hd);
console.log(Web.url); // 获取静态属性

// 使用class类设置静态属性
class Request {
  static host = "https://www.houdunren.com";
  api(url) {
    return Request.host + `/${url}`; // 静态属性的调用
  }
}

let obj = new Request();
console.log(obj.api("article"));
```

- 静态方法的实现原理

```ts
// 传统方式下定义静态方法
function User() {}

// 定义构造函数的原型方法
User.prototype.show = function () {
  console.log("prototype.show");
};

// 定义构造函数的静态方法(class是使用这种方式实现静态方法的设置)
User.show = function () {
  console.log("static.show");
};

// 或者这样定义构造函数的静态方法
User.__proto__.show = function () {
  console.log("static.show");
};

console.dir(User);
User.show();

/** 使用class来定义静态方法  */
class User {
  show() {
    console.log("prototype.show");
  }

  static show = function () {
    console.log("static.show");
  };
}

console.dir(User);

User.show();
let hd = new User();
hd.show();
```

- 静态方法的使用实例

```ts
class Member {
  constructor(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
  }
  static create(...args) {
    return new this(...args);
  }
}

let xj = Member.create("aa", 19, "男");
console.log(xj);
```

- 静态属性练习之课程管理类

```ts
const data = [
  { name: "js", price: 100 },
  { name: "mysql", price: 212 },
  { name: "vue.js", price: 98 },
];

class Lesson {
  constructor(data) {
    this.model = data;
  }

  // 获取课程价格
  price() {
    return this.model.price;
  }

  // 批量创建课程的实例化对象
  static createBatch(data) {
    return data.map((item) => new Lesson(item));
  }

  // 获取最贵的课程
  static maxPrice(data) {
    return data.sort((a, b) => b.price() - a.price())[0];
  }
}

let lessons = Lesson.createBatch(data);
console.log(lessons);
console.log(Lesson.maxPrice(lessons));
```

- 在类中使用访问器

```ts
class Request {
  constructor(host) {
    this.data = { host };
  }

  set host(url) {
    if (!/^https?:\/\//i.test(url)) {
      throw new Error("地址错误");
    }

    this.data.host = url;
  }

  get host() {
    return this.data.host;
  }
}

let hd = new Request("www.abc.com");
console.log(hd.host);
hd.host = "ccc.com";
```

- 使用命名规则保护属性

```ts
// public 公用的外部是可以访问到的
// protected 受保护的 只有自己和子类可以访问
// private 私有的只有自己可以访问 子类是不允许访问的 可以通过在属性名前面加#实现 例如#host
```

- class 属性继承原理

```ts
class User {
  constructor(name) {
    this.name = name;
  }
}

class Admin extends User {
  constructor(name) {
    super(name);
  }
}

let hd = new Admin("后盾人");
console.log(hd);
```

- 类的方法继承原理

```ts
class User {
  show() {
    console.log("后盾人");
  }
}

class Admin extends User {
  constructor(name) {
    super();
    this.name = name;
  }
}
console.log(Admin);
let hd = new Admin("aaa");
console.log(hd);
hd.show();
```

- super 原理分析

```ts
// super的使用实例
class User {
  show() {
    console.log(this.name);
  }
}

class Admin extends User {
  constructor(name) {
    super();
    this.name = name;
  }
  show() {
    super.show();
  }
}

console.dir(Admin);
let hd = new Admin("aaa");
hd.show();
// super的实现机制分析
let hd = {
  show() {
    console.log(this.name);
  },
};

let xj = {
  __proto__: hd,
  name: "xj.name",
  show() {
    this.__proto__.show.call(this);
  },
};

xj.show();
```

- 多重继承中 super 的魅力

```ts
// super的多重继承实现机制分析
let common = {
  show() {
    console.log(this.name + "aaa");
  },
};
let hd = {
  __proto__: common,
  show() {
    super.show();
  },
};

let xj = {
  __proto__: hd,
  name: "xj.name",
  show() {
    super.show(); // 不能在function(){}这种结构中使用
    // this.__proto__.show.call(this);
  },
};

xj.show();
```

- 为什么要在子类的 constrctor 中执行 super

```ts
// super的使用
class User {
  constructor(name) {
    this.name = name;
  }
}

class Admin extends User {
  constructor(...args) {
    super(...args); // super一定要写在最前面
    this.name = "hdr"; // 这个要写在后面
  }
}

let hd = new Admin("后盾人");
console.log(hd);
// 原理分析
function User(name) {
  this.name = name;
}

function Admin(...args) {
  User.call(this, ...args);
}

Admin.prototype = Object.create(User.prototype);
let hd = new Admin("后盾人");
console.log(hd);
```

- 使用 super 访问父类方法

```ts
class Controller {
  constructor() {
    console.log("父类的构造方法执行了...");
  }

  sum() {
    return this.data.reduce((t, c) => t + c.price, 0);
  }

  getByKey(key) {
    return this.data.filter((item) => item.name.includes(key));
  }
}

class Lesson extends Controller {
  constructor(data) {
    super();
    this.data = data;
  }
  info() {
    return {
      totalPrice: super.sum(), // 使用父类的方法
      data: this.data,
    };
  }

  // 重写父类的方法
  getByKey(key) {
    return super.getByKey(key).map((item) => item.name);
  }
}

let data = [
  { name: "js", price: 100 },
  { name: "mysql", price: 110 },
];

let hd = new Lesson(data);
console.log(hd.info());
console.log(hd.getByKey("js"));
```

- 静态继承原理

```ts
// 静态方法在类中的使用
class User {
  static site = "abc.com";
  static show() {
    console.log("user.static show");
  }
}

class Admin extends User {}
console.dir(Admin);
console.log(Admin.site);
Admin.show();

// 原理分析
function User() {}
User.site = "abc.com";
User.show = function () {
  console.log("user.static show");
};

function Admin() {}

Admin.__proto__ = User;

console.dir(Admin);
console.log(Admin.site);
Admin.show();
```

- 使用 instanceof 检测对象实现

```ts
class User {}
class Admin extends User {}

function checkPrototype(obj, constructor) {
  if (!obj.__proto__) return false;
  if (obj.__proto__ === constructor.prototype) return true;

  return checkPrototype(obj.__proto__, constructor);
}

let hd = new Admin();
console.log(checkPrototype(hd, User));

// 只有在实例化对象的原型链上有就返回true
console.log(hd instanceof User);
```

- 使用 isPrototypeOf 检测继承关系

```ts
let a = {};
let b = {
  __proto__: a,
};
let c = {
  __proto__: b,
};

// a 是否在 b 的原型链上
console.log(a.isPrototypeOf(b)); // true
// a 是否在c的原型链上
console.log(a.isPrototypeOf(c)); // true
// c  是否在b的原型链上
console.log(c.isPrototypeOf(b)); // false

/* class 类的使用方法 */
class Common {}
class User extends Common {}
class Admin extends User {}
let hd = new Admin();

console.log(Admin.prototype.isPrototypeOf(hd)); // true
console.log(Common.prototype.isPrototypeOf(hd)); // true

// 使用这种方法会更加方便一点
console.log(hd instanceof Common); // true
```

- 内置类继承的原型实现

```ts
function Arr(...args) {
  args.forEach((item) => this.push(item));

  this.first = function () {
    return this[0];
  };
  this.max = function () {
    return this.sort((a, b) => b - a)[0];
  };
}

Arr.prototype = Object.create(Array.prototype);
let hd = new Arr(99, 1, 2, 3, 195);
console.log(hd.max());
```

- 使用继承增强内置类

```ts
class Arr extends Array {
  constructor(...args) {
    super(...args);
  }
  first() {
    return this[0];
  }
  max() {
    return this.sort((a, b) => b - a)[0];
  }
  add(item) {
    this.push(item);
  }

  remove(value) {
    let pos = this.findIndex((item) => item === value);
    this.splice(pos, 1);
  }
}

let hd = new Arr(99, 1, 2, 3, 195);
console.log(hd.max());
hd.add(66);

hd.remove(1);

console.log(hd);
```

- mixin 混合模式使用技巧

```ts
let Tool = {
  max(key) {
    return this.data.sort((a, b) => b[key] - a[key])[0];
  },
};

let Arr = {
  count(key) {
    return this.data.reduce((t, c) => t + c[key], 0);
  },
};

class Lesson {
  constructor(lessons) {
    this.lessons = lessons;
  }
  get data() {
    return this.lessons;
  }
}

const data = [
  { name: "js", price: 100, click: 188 },
  { name: "mysql", price: 212, click: 34 },
  { name: "vue.js", price: 98, click: 89 },
];
// 实现混合方法的继承
Object.assign(Lesson.prototype, Tool, Arr);

let hd = new Lesson(data);
console.log(hd.count("click"));
```

- 灵活的动画处理类

```ts
// 选项卡面板的隐藏与显示
class Animation {
  constructor(el) {
    this.timeout = 5;
    this.el = el;
    this.isShow = true;
    this.defalutHeight = this.height;
  }

  hide(callback) {
    this.isShow = false;
    let id = setInterval(() => {
      if (this.height <= 0) {
        clearInterval(id);
        callback && callback();
        return;
      }
      this.height = this.height - 1;
    }, this.timeout);
  }

  show(callback) {
    this.isShow = true;
    let id = setInterval(() => {
      if (this.height >= this.defalutHeight) {
        clearInterval(id);
        callback && callback();
        return;
      }
      this.height = this.height + 1;
    }, this.timeout);
  }

  get height() {
    // 乘以1变成一个数字类型
    return window.getComputedStyle(el).height.slice(0, -2) * 1;
  }

  set height(height) {
    this.el.style.height = height + "px";
  }
}

let el = document.querySelector(".s1");
let hd = new Animation(el);

hd.hide(() => {
  console.log("隐藏完了");
  hd.show(() => {
    console.log("显示完了");
  });
});

class Slide {
  constructor(el) {
    this.el = document.querySelector(el);
    this.links = this.el.querySelectorAll("dt");
    this.panels = [...this.el.querySelectorAll("dd")].map((item) => {
      return new Panel(item);
    });
    this.bind();
  }

  bind() {
    this.links.forEach((item, i) => {
      item.addEventListener("click", () => {
        this.action(i);
      });
    });
  }

  action(i) {
    Panel.hideAll(Panel.filter(this.panels, i), () => {
      this.panels[i].show();
    });
  }
}

class Panel extends Animation {
  static num = 0;
  // 隐藏多个面板
  static hideAll(items, callback) {
    if (Panel.num > 0) return;
    items.forEach((item) => {
      Panel.num++;
      item.hide(() => {
        Panel.num--;
      });
    });

    callback && callback();
  }
  static filter(items, i) {
    return items.filter((item, index) => index !== i);
  }
}

let hd = new Slide(".s1");
```

## 单词

```pug
protected 受保护的
private 私有的
```
