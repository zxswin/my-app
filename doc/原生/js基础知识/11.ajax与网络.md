## ajax 与网络

- 域名

```bash
## 域名
域名级别:
顶级域名(-级域名) : jsplusplus.com
二级域名: www.jsplusplus.com study.splusplus.com
三级域名: qianduan.study.isplusplus.com
```

- DNS 解析

```bash
# DNS解析
DNS: Domain Name Server (域名服务器)
作用:域名与对应的Ip转换的服务器
特征: DNS中保存了一-张域名与对应的lp地址的表
一个域名对应-一个IP地址，一个IP地址可以对应多 个域名
gTLD: generic Top-Level DNS Server 顶级域名服务器
为所有.com、.net ....后缀做域名解析的服务器
```

- ip

```bash
IP
英文: Internet Protocol Address
中文:互联网协议地址、IP地址
作用:分配给用户上网使用的互联网协议
分类: IPv4 IPv6 其他
形式: 192.168.0.1 (长度32位(4个字节)，十进制表示) (IPv4)
V.: verson
4或6:版本号
优势: IPv6地址空间更大(8组(128位) ，十六进制)
路由表更小
组播支持以及对流支持增强
对自动配置的支持
更高的安全性
ABCD:EF01:2345:6789:ABCD:EF01:2345:6789
```

- ip 的端口号

```bash
IP端口号PORT
Ip地址:. 上海迪斯尼乐园的地址
IPv4或IPv6
端口号:乐园中的不同游乐设施
80、443
解释:找到一个IP就像找到了乐园的地址，你就可以到乐园，相当于可以访问到IP所对应的服务器，IP加端口号，相当于到乐园去玩儿不同的项目，每个项目其实就是一个端口号。
总结:每一个端口对应的是一一个服务器的一个业务，访问一个服务器的不同端口相当于访问不同的务。
端口号范围: 0- 65535
默认端口: http协议下(80) 、https协议下(443)、FTP协议下(20、21)
node展示端口不同，服务端不同的业务
```

- TCP

```bash
TCP (打电话)
TCP: Transmission Control Protocol 传输控制协议
特点:面向连接(收发数据前，必须建立可靠的连接)
建立连接基础:三次握手
应用场景:数据必须准确无误的收发
HTTP请求、FTP文件传输、邮件收发
优点:稳定、重传机制、拥塞控制机制、断开连接
缺点:速度慢、效率低、占用资源、容易被攻击(三次握手-> DOS、DDOS攻击)
TCP/IP协议组: 提供点对点的连接机制，制定了数据封装、定址、传输、路由、数据接收的标准。

```

- UDP

```bash
UDP (喇叭叫人)
UDP: User Data Protocol用户数据报协议|
特点:面向无连接(不可靠的协议，无状态传输机制)
无连接信息发送机制
应用场景:无需确保通讯质量且要求速度快、无需确保信息完整
消息收发、语音通话、直播(QQ)
优点:安全、快速、漏洞少(UDP flood攻击)
缺点:不可靠、不稳定、容易丢包
总结:只要目的源地址、端口号、地地址、端口号确定，则可以直接发送信息报文，但不能保证一定能收 到或收到完整的数据。
```

- HTTP 和 HTTPS

```bash
HTTP与HTTPS
HTTP: HyperText Transfer Protocol超文本传输协议
定义:客户端和服务器端请求和应答的标准，用于从WEB服务器传输超文本到本地浏览的传输协议。
HTTP请求:按照协议规则先向WEB服务器发送的将超文本传输到本地浏览器的请求
HTTPS: HyperText Transfer Protocol Secure超文本传输安全协议
定义: HTTP的安全版(安全基础是SSL/TLS )
SSL: Secure Sockets Layer 安全套接层
TLS: Transport Layer Security 传输层安全
为网络通信提供安全及数据完整性的一 种安全协议，对网络连接进行加密

HTTP与HTTPS
区别: (展示携程和腾讯课堂)
HtTP是不安全的(监听和中间人攻击等手段，获取网站账户信息和敏感信息)
HTTPS可防止被攻击
HTTP协议的传输内容都是明文，直接在TCP连接上运行，客户端和服务器都无法验证对方身份
HTTPS协议的传输内容都被SSLTLS加密， 且运行在SSLTLS.上，SSL/TLS运行在TPC连接上，所以数据传输是安全的。
```

- 建立 TCP 连接的前奏

```bash
建立TCP连接的前奏
●标志位:
SYN: Synchronize Sequence Numbers 同步序列编号
●ACK: Acknowledgement 确认字符

状态
●LISTEN: 侦听TCP端口的连接请求(我等着你发送连接请求呢)
SYN-SENT:在发送连接请求后等待匹配的连接请求(我发送了连接请求，我等你回复哈)
SYN-RECEIVED:在收到和发送一个连接请求后等待对连接请求的确认
我收到你的连接请求了哈，我等你回复我)
ESTABLISHED:代表-一个打开的连接，数据可以传送给用户
(建立建立了哈，我跟你说一- 下)
```

- 建立 TCP 的三次握手总结

```bash
建立TCP的三次握手总结
●第一次握手:客户端向服务器发送SYN标志位(序号是j)，并进入SYN_ SEND状态(等待服务器确认状态)。
●第二次握手:服务器收到来自客户端的SYNJ，服务端会确认该数据包已收到并发送ACK标志位(序号是j+1)和SYN标志位(序号是K)，服务器进入SYN_ RECV (请求接收并等待客户端确认状态)
●第三次握手:客户端进入连接建立状态后，向服务器发送ACK标志位(序号是K+1)确认客户端已收到建立连接确认，服务器收到ACK标志位后，服务端进入连接已建立状态。
```

- AJAX

```txt
AJAX-创建XMLHTTPREQUEST对象
原生XMLHttpRequest对象与ActiveX对象
作用: JS脚本发起HTTP请求的发起必须通过XMLHttpRequest对象
也是通过AJAX进行浏览器与服务器通信的接口
不局限于XML，可以发送任何格式的数据
XMLHttpRequest本身是一一个s引擎内置的构造函数
所有XMLHttpRequest对象都需要被实例化var xhr = new XMLHttpRequest();
兼容性: IE5/IE6使 用ActiveX对象
var xhr = new ActiveXObject('Microsoft.XMLHTTP');
```

- AJAX-发送 HTTP 请求

```txt
open方法(发送设置)
参数列表
method:请求方式
url:请求发送的地址
async: true异步 false同步


send方法(发送请求)
参数
发送POST请求体数据用，GET不填写
```

- AJAX-发送请求时的响应任务

```txt
onreadystatechange事件:挂载到XMLHttpRequest对象上的事件
readyState状态:通过XMLHttpRequest对象发送HTTP请求的各阶段状态码(0-4)
status状态:服务器响应的状态码(200 OK、404 未找到页面)
当readyState变化时，将触发onreadystatechange事件执行其回调函数
0:请求未初始化
1:服务器连接已建立
2:请求已接收
3:请求处理中
4:请求已完成，且响应已就绪
注意: readyState仅仅 是针对请求与响应的状态码，获取资源是否成功取决于status的状态
```

- AJAX-服务器响应

```txt
responseText:获取字符串数据
responseXML:获取XML数据
```

- AJAX 发起 GET 请求代码

```ts
let xhr;

if (window.XMLHttpRequest) {
  xhr = new XMLHttpRequest();
} else {
  xhr = new ActiveXObject('Microsoft.XMLHTTP');
}

console.log(xhr.readyState); // 0 请求未初始化

xhr.open('GET', 'http://localhost/network?param1=1', true); // 发生设置参数

xhr.send(); // 发生请求

console.log(xhr.readyState); // 1 服务器连接已建立

// 监听readyState状态
xhr.onreadystatechange = function () {
  // 2:请求已接收
  // 3:请求处理中
  // 4:请求已完成，且响应已就绪
  console.log(xhr.readyState);

  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(JSON.parse(xhr.responseText)); // 解析响应字符串
  }
};
```

- AJAX- POST 请求方式的注意事项

```txt
POST请求方式下，send方法参数中的格式: a=1&b=2&c=3
xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");
POST请求方式必须设置这个请求头信息，目的是将请求体中的数据转换为键值对，这样后端接收到a= 1&b=2&c=3这样的数据才知道是这是一-个POST方式传来的数据
```

- AJAX 发起 POST 请求代码

```ts
let xhr;

if (window.XMLHttpRequest) {
  xhr = new XMLHttpRequest();
} else {
  xhr = new ActiveXObject('Microsoft.XMLHTTP');
}

console.log(xhr.readyState); // 0 请求未初始化

xhr.open('POST', 'http://localhost/network', true); // 发生设置参数

// 设置请求头
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');

xhr.send('status=1&flag=1'); // 发生请求

console.log(xhr.readyState); // 1 服务器连接已建立

// 监听readyState状态
xhr.onreadystatechange = function () {
  // 2:请求已接收
  // 3:请求处理中
  // 4:请求已完成，且响应已就绪
  console.log(xhr.readyState);

  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(JSON.parse(xhr.responseText)); // 解析响应字符串
  }
};
```

- AJAX 请求的封装

```ts
let xhr = (function () {
  let o = window.XMLHttpRequest
    ? new XMLHttpRequest()
    : new ActiveXObject('Microsoft.XMLHTTP');

  if (!o) {
    throw new Error('您的浏览器不支持异步发起HTTP请求');
  }

  function _doAjax(opt) {
    opt = opt || {};
    let type = (opt.type || 'GET').toUpperCase();
    let async = opt.async || true;
    let url = opt.url;
    let data = opt.data || null;
    let error = opt.error || function () {};
    let success = opt.success || function () {};
    let complete = opt.complete || function () {};

    if (!url) {
      throw new Error('您没有填写url');
    }

    o.open(type, url, async);

    type === 'POST' &&
      o.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');

    o.send(type === 'GET' ? null : formatDatas(data));

    o.onreadystatechange = function () {
      if (o.readyState === 4 && o.status === 200) {
        success(JSON.parse(o.responseText));
      }

      if (o.status === 404) {
        error();
      }

      complete();
    };
  }

  function formatDatas(obj) {
    let str = '';
    for (let key of obj) {
      str += key + '=' + obj[key] + '&';
    }
    return str.replace(/&$/, '');
  }

  return {
    ajax: function (opt) {
      _doAjax(opt);
    },
    post: function (url, data, callback) {
      _doAjax({
        type: 'POST',
        url: url,
        data: data,
        success: callback,
      });
    },
    get: function (url, callback) {
      _doAjax({
        type: 'GET',
        url: url,
        success: callback,
      });
    },
  };
})();

console.log('xhr', xhr);

xhr.get(
  'https://api.apiopen.top/getJoke?page=1&count=2&type=video',
  function (data) {
    console.log('data', data);
  }
);
```

## 请求头与响应头

- 请求头

```ts
/**
 * HTTP消息头支持自定义， 自定义的专用消息头一般会添加'X-'前缀。
 *
 * 常用的HTTP请求头
 * 1.Accept	可接受的响应内容类型（Content-Types）
 * Accept: text/plain
 *
 * 2.Accept-Charset	可接受的字符集
 * Accept-Charset: utf-8
 *
 * 3.Accept-Encoding	可接受的响应内容的编码方式
 * Accept-Encoding: gzip, deflate
 *
 * 4.Accept-Language	可接受的响应内容语言列表
 * Accept-Language: en-US
 *
 * 5.Accept-Datetime	可接受的按照时间来表示的响应内容版本
 * Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT
 *
 * 6.Authorization	用于表示HTTP协议中需要认证资源的认证信息
 * Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==
 *
 * 7.Cache-Control	用来指定当前的请求/回复中的，是否使用缓存机制。
 * Cache-Control: no-cache
 *
 * 8.Connection	客户端（浏览器）想要优先使用的连接类型
 * Connection: keep-alive  或 Connection: Upgrade
 *
 * 9.Cookie	由之前服务器通过Set-Cookie（设置的一个HTTP协议Cookie
 * Cookie: $Version=1; Skin=new;
 *
 * 10.Content-Length	以8进制表示的请求体的长度
 * Content-Length: 348
 *
 *
 * 11.Content-Type	请求体的MIME类型 （用于POST和PUT请求中）
 * Content-Type: application/x-www-form-urlencoded
 *
 * 12.Date	发送该消息的日期和时间（以RFC 7231中定义的"HTTP日期"格式来发送）
 * Date: Dec, 26 Dec 2015 17:30:00 GMT
 *
 * 13.Expect	表示客户端要求服务器做出特定的行为
 * Expect: 100-continue
 *
 * 14.From	发起此请求的用户的邮件地址
 * From: user@itbilu.com
 *
 * 15.Host	表示服务器的域名以及服务器所监听的端口号。
 * 如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。
 * Host: www.itbilu.com:80
 * Host: www.itbilu.com
 *
 * 16.If-Match	仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。
 * 主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。
 * If-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd"
 *
 * 17.If-Modified-Since	允许在对应的资源未被修改的情况下返回304未修改
 * If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT
 *
 * 18.If-None-Match	允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ）
 * If-None-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd"
 *
 * 19.If-Range	如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体
 * If-Range: "9jd00cdj34pss9ejqiw39d82f20d0ikd"
 *
 * 20.If-Unmodified-Since	仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。
 * If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT
 *
 * 21.Max-Forwards	限制该消息可被代理及网关转发的次数。
 * Max-Forwards: 10
 *
 * 22.Origin	发起一个针对跨域资源共享的请求
 * （该请求要求服务器在响应中加入一个Access-Control-Allow-Origin的消息头，表示访问控制所允许的来源）。
 * Origin: http://www.itbilu.com
 *
 * 23.Pragma	与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。
 * Pragma: no-cache
 *
 * 24.Proxy-Authorization	用于向代理进行认证的认证信息。
 * Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2==
 *
 * 25.Range	表示请求某个实体的一部分，字节偏移以0开始。
 * Range: bytes=500-999	固定
 *
 * 26.Referer	表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。
 * Referer其实是Referrer这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用Referer了。
 * Referer: http://itbilu.com/nodejs
 *
 * 27.TE	浏览器预期接受的传输时的编码方式：可使用回应协议头Transfer-Encoding中的值
 * （还可以使用"trailers"表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。
 * TE: trailers,deflate
 *
 * 28.User-Agent	浏览器的身份标识字符串
 * User-Agent: Mozilla/……
 *
 * 29.Upgrade	要求服务器升级到一个高版本协议。
 * Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
 *
 * 30.Via	告诉服务器，这个请求是由哪些代理发出的。
 * Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)
 *
 * 31.Warning	一个一般性的警告，表示在实体内容体中可能存在错误。
 * Warning: 199 Miscellaneous warning
 *
 *
 */
```

- 响应头

```ts
/**
 * HTTP消息头支持自定义， 自定义的专用消息头一般会添加'X-'前缀。
 *
 * 1.Access-Control-Allow-Origin	指定哪些网站可以跨域源资源共享
 * Access-Control-Allow-Origin: *
 *
 * 2.Accept-Patch	指定服务器所支持的文档补丁格式
 * Accept-Patch: text/example;charset=utf-8
 *
 * 3.Accept-Ranges	服务器所支持的内容范围
 * Accept-Ranges: bytes
 *
 * 4.Age	响应对象在代理缓存中存在的时间，以秒为单位
 * Age: 12
 *
 * 5.Allow	对于特定资源的有效动作;
 * Allow: GET, HEAD
 *
 * 6.Cache-Control	通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒
 * Cache-Control: max-age=3600
 *
 *
 * 7.Connection	针对该连接所预期的选项
 * Connection: close
 *
 * 8.Content-Disposition	对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，
 * 如：将其下载或是打开。
 * Content-Disposition: attachment; filename="fname.ext"
 *
 * 7.Content-Encoding	响应资源所使用的编码类型。
 * Content-Encoding: gzip
 *
 * 8.Content-Language	响就内容所使用的语言
 * Content-Language: zh-cn
 *
 * 9.Content-Length	响应消息体的长度，用8进制字节表示
 * Content-Length: 348
 *
 * 10.Content-Location	所返回的数据的一个候选位置
 * Content-Location: /index.htm
 *
 * 11.Content-Range	如果是响应部分消息，表示属于完整消息的哪个部分
 * Content-Range: bytes 21010-47021/47022
 *
 * 12.Content-Type	当前内容的MIME类型	Content-Type: text/html; charset=utf-8
 *
 * 13.Date	此条消息被发送时的日期和时间(以RFC 7231中定义的"HTTP日期"格式来表示)
 * Date: Tue, 15 Nov 1994 08:12:31 GMT
 *
 * 14.ETag	对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列
 * ETag: "737060cd8c284d8af7ad3082f209582d"	固定
 *
 * 15.Expires	指定一个日期/时间，超过该时间则认为此回应已经过期
 * Expires: Thu, 01 Dec 1994 16:00:00 GMT	固定: 标准
 *
 * 16.Last-Modified	所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)
 * Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT
 *
 * 17.Link	用来表示与另一个资源之间的类型关系，此类型关系是在RFC 5988中定义
 * Link: ; rel="alternate"
 *
 * 18.Location	用于在进行重定向，或在创建了某个新资源时使用。
 * Location: http://www.itbilu.com/nodejs
 *
 * 19.P3P	P3P策略相关设置
 * P3P: CP="This is not a P3P policy!
 *
 * 18.Pragma	与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果
 * Pragma: no-cache
 *
 * 19.Proxy-Authenticate	要求在访问代理时提供身份认证信息。
 * Proxy-Authenticate: Basic
 *
 * 20.Public-Key-Pins	用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值
 * Public-Key-Pins: max-age=2592000; pin-sha256="……";
 *
 * 21.Refresh	用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。
 * Refresh: 5; url=http://itbilu.com
 *
 * 22.Retry-After	如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。
 * 其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。
 * 示例1:Retry-After: 120
 * 示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT
 *
 * 23.Server	服务器的名称	Server: nginx/1.6.3	固定
 *
 * 24.Set-Cookie	设置HTTP cookie
 * Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1
 *
 * 25.Status	通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。
 * Status: 200 OK
 *
 * 26.Trailer	Trailer用户说明传输中分块编码的编码信息
 * Trailer: Max-Forwards
 *
 * 27.Transfer-Encoding	用表示实体传输给用户的编码形式。
 * 包括：chunked、compress、 deflate、gzip、identity。
 * Transfer-Encoding: chunked
 *
 * 28.Upgrade	要求客户端升级到另一个高版本协议。
 * Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
 *
 * 29.Vary	告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，
 * 以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。
 * Vary: *
 *
 * 30.Via	告知代理服务器的客户端，当前响应是通过什么途径发送的。
 * Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)
 *
 * 31.Warning	一般性警告，告知在实体内容体中可能存在错误。
 * Warning: 199 Miscellaneous warning
 *
 * 32.WWW-Authenticate	表示在请求获取这个实体时应当使用的认证模式。
 * WWW-Authenticate: Basic
 */
```

- HTTP 工作原理

```ts
/**
 * HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）
 * HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。
 *
 * 1.HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。
 * 采用这种方式可以节省传输时间。
 *
 * 2.HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。
 * 客户端以及服务器指定使用适合的MIME-type内容类型。
 *
 * 3.HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。
 */
```

- HTTP 的消息结构

```ts
/**
 * 客户端请求消息
 * 1.请求行（request line）、
 * 请求方法 空格 URL 空格 协议版本 回车符 换行符
 * 2.请求头部（header）
 * 头部字段名:值 回车符 换行符
 * ... 有多个请求头字段
 * 3.空行
 * 回车符
 * 换行符
 * 4.请求数据四个部分组成
 *
 * 服务器响应消息
 * 1.状态行
 * 2.消息报头
 * 3.空行
 * 4.响应正文
 */
```

- HTTP 请求方法

```ts
/**
 * 1.GET	请求指定的页面信息，并返回实体主体。
 * 2.HEAD	类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
 * 3.POST	向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。
 * 4.PUT	从客户端向服务器传送的数据取代指定的文档的内容。
 * 5.DELETE	请求服务器删除指定的页面。
 * 6.CONNECT	HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
 * 7.OPTIONS	允许客户端查看服务器的性能。
 * 8.TRACE	回显服务器收到的请求，主要用于测试或诊断。
 * 9.PATCH	是对 PUT 方法的补充，用来对已知资源进行局部更新 。
 */
```

- 常见的 HTTP 状态码

```ts
/**
 * 200 - 请求成功
 * 301 - 资源（网页等）被永久转移到其它URL
 * 404 - 请求的资源（网页等）不存在
 * 500 - 内部服务器错误
 */
```

- Content-Type（内容类型）

```ts
/**
 * Content-Type，用于定义网络文件的类型和网页的编码
 * Content-Type 标头告诉客户端实际返回的内容的内容类型。
 *
 * 常见的媒体格式类型如下：
 * text/html ： HTML格式
 * text/plain ：纯文本格式
 * text/xml ： XML格式
 * image/gif ：gif图片格式
 * image/jpeg ：jpg图片格式
 * image/png：png图片格式
 *
 * 以application开头的媒体格式类型：
 * application/xhtml+xml ：XHTML格式
 * application/xml： XML数据格式
 * application/atom+xml ：Atom XML聚合格式
 * application/json： JSON数据格式
 * application/pdf：pdf格式
 * application/msword ： Word文档格式
 * application/octet-stream ： 二进制流数据（如常见的文件下载）
 * application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）
 *
 * 另外一种常见的媒体格式是上传文件之时使用的：
 * multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式
 */
```

## HTTP/1.0 、HTTP/1.1 、HTTP/2.0

```ts
/**
 * 目前共有三种协议分别是HTTP/1.0 、HTTP/1.1 、HTTP/2.0，其中HTTP/1.1是主流
 *
 * HTTP的基本优化基本思路
 * 1.浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。
 * 浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），
 * 超过浏览器最大连接数限制，后续请求就会被阻塞。
 * 2.DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。
 * 3.建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在
 * 第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，
 *
 * HTTP1.0和HTTP1.1的一些区别
 * HTTP1.0最早在网页中使用是在1996年
 * HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议
 * 1.HTTP1.1引入更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match
 * 等更多可供选择的缓存头来控制缓存策略
 * 2.带宽优化及网络连接的使用
 * HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分
 * 3.错误通知的管理
 * 在HTTP1.1中新增了24个错误状态响应码
 * 4.Host头处理
 * 在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址
 * HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
 * 5.长连接
 * HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，
 * 减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，
 * 一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
 *
 *
 *
 * HTTPS与HTTP的一些区别
 * 1.HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
 * 2.HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
 * 3.HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
 * 4.HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。
 *
 * HTTP2.0
 * 1.HTTP2.0的协议解析决定采用二进制格式
 * 2.多路复用（MultiPlexing），即连接共享
 * 3.header压缩
 * 4.服务端推送,推送js,css等资源而不用每次都要客户端去请求
 *
 *
 * 现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。
 * HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的
 *
 * HTTP2.0的多路复用
 * HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；
 */
```

## Cookie 与 Session 的使用

```ts
/**
 * 会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。
 * 常用的会话跟踪技术是Cookie与Session。
 * Cookie通过在客户端记录信息确定用户身份
 * Session通过在服务器端记录信息确定用户身份
 *
 *
 * HTTP协议是无状态的协议。
 * 一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。
 * 这就意味着服务器无法从连接上跟踪会话
 * 服务端推送
 *
 *
 */
```

- Cookie

```ts
/**
 * 1.HTTP 请求都是无状态的
 * 2.服务端可以通过响应头（set-cookie）将少量数据响应给客户端，浏览器会遵循协议将数据保存，并在下次请求同一个服务的时候带上
 * Cookie 一般是通过服务器端设置 保存在浏览器上的
 * Cookie 有长度限制限制 cookie的长度不能大于4kB 一般来说不要超过 4093 bytes
 * Cookie具有不可跨域名性
 *
 * 3.Cookie 的设置参数
 * maxAge(Number) 设置这个键值对在浏览器的最长保存时间。是一个从服务器当前时刻开始的毫秒数。
 * 浏览器会将maxAge为正数的Cookie持久化，即写到对应的Cookie文件中。无论客户关闭了浏览器还是电脑，只要还在maxAge秒之前，登录网站时该Cookie仍然有效。
 * maxAge为负数的Cookie，为临时性Cookie，不会被持久化，不会被写到Cookie文件中。
 * 删除时只需要把maxAge修改为0即可
 *
 * expires(Date) 设置这个键值对的失效时间，如果设置了 maxAge，expires 将会被覆盖。如果 maxAge 和 expires 都没设置，Cookie 将会在浏览器的会话失效（一般是关闭浏览器时）的时候失效。
 *
 * path(String) 设置键值对生效的 URL 路径，默认设置在根路径上（/），也就是当前域名下的所有 URL 都可以访问这个 Cookie。
 *
 * domain(String) 设置键值对生效的域名，默认没有配置，可以配置成只在指定域名才能访问。
 * 可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”
 *
 * httpOnly(Boolean) 设置键值对是否可以被 js 访问，默认为 true，不允许被 js 访问。
 * secure(Boolean) 设置键值对只在 HTTPS 连接上传输，框架会帮我们判断当前是否在 HTTPS 连接上自动设置 secure 的值。
 * 浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie。
 */
```

- Cookie 的 SameSite 属性

```ts
/**
 * Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪
 *
 * 什么是CSRF 攻击
 * Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击
 * 举例来说，用户登陆了银行网站your-bank.com，银行服务器发来了一个 Cookie。
 * 用户后来又访问了恶意网站malicious.com，上面有一个表单
 * 用户一旦被诱骗发送这个表单，银行网站就会收到带有正确 Cookie 的请求。为了防止这种攻击，
 * 表单一般都带有一个随机 token，告诉服务器这是真实请求。
 *
 * Cookie 的SameSite属性用来限制第三方 Cookie，从而减少安全风险。
 * 它可以设置三个值。
 * 1.Strict
 * Strict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。
 * 换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。
 * Set-Cookie: CookieName=CookieValue; SameSite=Strict;
 *
 * 2.Lax
 * Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。
 * Set-Cookie: CookieName=CookieValue; SameSite=Lax;
 *
 * 3.None
 * Chrome 计划将Lax变为默认设置。这时，网站可以选择显式关闭SameSite属性，将其设为None。
 * 不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送）
 * Set-Cookie: widget_session=abc123; SameSite=None; Secure
 */
```

- Session

```ts
/**
 *
 * Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。
 *
 *
 * 专门用做用户身份识别
 * 设置的 Session 存放在服务器端 客户端是看不到的
 * 服务器端设置session值后 服务器自动颁发一个key是EGG_SESS的cookie给浏览器 用于标识不同的浏览器
 * 浏览器EGG_SESS值是SessionID 不同浏览器是不一样的
 * cookies会通过请求传递给服务器 不同的浏览器可以获取不同的session值
 * Session存放在服务器的内存中，SessionID存放在服务器内存和客户机的Cookie里面。5万个用户就意味着服务器端存放了5W*n个Session
 * 当用户发出请求时，服务器将用户Cookie里面记录的SessionID和服务器内存中的SessionID进行比对，找到这个用户对应的Session进行操作。
 *
 */
```

- 不支持 Cookie 的解决方案

```ts
/**
 * 例如，绝大多数的手机浏览器都不支持Cookie。解决方案：URL地址重写。
 *
 * URL地址重写是对客户端不支持Cookie的解决方案。
 * URL地址重写的原理是将该用户Session的id信息重写到URL地址中。
 * 服务器能够解析重写后的URL获取Session的id。
 * 这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。写
 */
```

## jsonp 的实现原理

```ts
/**
 * 1.同源策略即：
 * 同一协议，同一域名，同一端口号。当其中一个不满足时，我们的请求即会发生跨域问题
 *
 * 2.script标签的src
 * img标签的src，
 * link标签的href他们没有被同源策略所限制
 * 同理img标签的src和link标签的href也会发送一个get请求去请求静态资源
 *
 *
 * 总结：
 * 1.其实jsonp的整个过程就类似于前端声明好一个函数，后端返回执行函数。执行函数参数中携带所需的数据
 * 2.jsonp跨域只能用get请求
 */
```

```html
<!-- 客户端代码 -->
<button id="btn">点击</button>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script>
  $('#btn').click(function () {
    var frame = document.createElement('script');
    frame.src =
      'http://localhost:3000/article-list?name=leo&age=30&callback=func';
    $('body').append(frame);
  });

  // jsonp 的callback回调函数
  function func(res) {
    alert(res.message + res.name + '你已经' + res.age + '岁了');
  }
</script>
```

```ts
// 服务端代码
router.get('/article-list', (req, res) => {
  console.log(req.query, '123');
  let data = {
    message: 'success!',
    name: req.query.name,
    age: req.query.age,
  };
  data = JSON.stringify(data);
  res.end('func(' + data + ')');
});
```

## CORS (跨域资源共享) 实现跨域请求

```ts
/**
 * CORS(Cross-Origin Resource Sharing)
 * CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。
 * 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
 * 如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。
 *
 * 实现原理
 * 浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求
 * 实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。
 *
 * 一.简单请求
 * 1) 请求方法是以下三种方法之一：HEAD GET POST
 * 2）HTTP的头信息不超出以下几种字段：
 * Accept
 * Accept-Language
 * Content-Language
 * Last-Event-ID
 * Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
 *
 * 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。
 * GET /cors HTTP/1.1
 * Origin: http://api.bob.com
 * Host: api.alice.com
 * Accept-Language: en-US
 * Connection: keep-alive
 * User-Agent: Mozilla/5.0…
 *
 * 服务器根据这个值，决定是否同意这次请求。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。
 * 浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），
 * 就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。
 * 注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。
 *
 * 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。
 * 1.Access-Control-Allow-Origin: http://api.bob.com
 * 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。
 *
 *
 * 2.Access-Control-Allow-Credentials: true
 * 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。
 * 默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，
 * Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。
 *
 * 3.Access-Control-Expose-Headers: FooBar
 * 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：
 * Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。
 * 如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。
 * 上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。
 *
 * 开发者必须在AJAX请求中打开withCredentials属性
 * 否则，即使服务器同意发送Cookie，浏览器也不会发送。
 * 或者，服务器要求设置Cookie，浏览器也不会处理。
 * 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。
 * 这时，可以显式关闭withCredentials。
 * 如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名
 *
 * var xhr = new XMLHttpRequest();
 * xhr.withCredentials = true;
 *
 * 4.Content-Type: text/html; charset=utf-8
 *
 *
 * 二.非简单请求
 * 1.预检请求
 * 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json
 * 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。
 * 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。
 * 只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。
 * var url = ‘http://api.alice.com/cors‘;
 * var xhr = new XMLHttpRequest();
 * xhr.open(‘PUT’, url, true);
 * xhr.setRequestHeader(‘X-Custom-Header’, ‘value’);
 * xhr.send();
 *
 * 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。
 * OPTIONS /cors HTTP/1.1
 * Origin: http://api.bob.com
 * Access-Control-Request-Method: PUT
 * Access-Control-Request-Headers: X-Custom-Header
 * Host: api.alice.com
 * Accept-Language: en-US
 * Connection: keep-alive
 * User-Agent: Mozilla/5.0…
 * “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。
 *
 * 除了Origin字段，”预检”请求的头信息包括两个特殊字段。
 * 1）Access-Control-Request-Method
 * 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。
 *
 * 2）Access-Control-Request-Headers
 * 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。
 *
 * 预检请求的回应
 * 服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method
 * 和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。
 * HTTP/1.1 200 OK
 * Date: Mon, 01 Dec 2008 01:15:39 GMT
 * Server: Apache/2.0.61 (Unix)
 * Access-Control-Allow-Origin: http://api.bob.com
 * Access-Control-Allow-Methods: GET, POST, PUT
 * Access-Control-Allow-Headers: X-Custom-Header
 * Content-Type: text/html; charset=utf-8
 * Content-Encoding: gzip
 * Content-Length: 0
 * Keep-Alive: timeout=2, max=100
 * Connection: Keep-Alive
 * Content-Type: text/plain
 *
 *
 * 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，
 * 但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，
 * 服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获
 *
 * 服务器回应的其他CORS相关字段
 * （1）Access-Control-Allow-Methods
 * 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。
 * 注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。
 *
 * （2）Access-Control-Allow-Headers
 * 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。
 * 它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。
 *
 * （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。
 *
 * （4）Access-Control-Max-Age
 * 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），
 * 即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。
 *
 * 一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。
 * 服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。
 * PUT /cors HTTP/1.1
 * Origin: http://api.bob.com
 * Host: api.alice.com
 * X-Custom-Header: value
 * Accept-Language: en-US
 * Connection: keep-alive
 * User-Agent: Mozilla/5.0…
 *
 * CORS与JSONP的对比
 * 1.CORS与JSONP的使用目的相同，但是比JSONP更强大。
 * 2.JSONP只支持GET请求，CORS支持所有类型的HTTP请求。
 * 3.JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。
 */
```

## websocket 的实现

```ts
/**
 * 什么是 WebSocket
 * 1.WebSocket 是 HTML5 新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，
 * 比如说，服务器可以在任意时刻发送消息给浏览器。
 * 2.HTTP 协议其实也能实现，比如用轮询或者 Comet
 * 3.HTML5 推出了 WebSocket 标准，让浏览器和服务器之间可以建立无限制的全双工通信，任何一方都可以主动发消息给对方。
 *
 * 4.WebSocket 协议
 * WebSocket 连接必须由浏览器发起，因为请求协议是一个标准的 HTTP 请求
 *
 *
 * GET ws://localhost:3000/ws/chat HTTP/1.1
 * Host: localhost
 * Upgrade: websocket
 * Connection: Upgrade
 * Origin: http://localhost:3000
 * Sec-WebSocket-Key: client-random-string
 * Sec-WebSocket-Version: 13
 *
 * 该请求和普通的 HTTP 请求有几点不同：
 * 1.GET 请求的地址不是类似/path/，而是以 ws://开头的地址；
 * 2.请求头 Upgrade: websocket 和 Connection: Upgrade 表示这个连接将要被转换为 WebSocket 连接；
 * 3.Sec-WebSocket-Key 是用于标识这个连接，并非用于加密数据；
 * 4.Sec-WebSocket-Version 指定了 WebSocket 的协议版本。
 *
 * 服务器如果接受该请求，就会返回如下响应：
 * 该响应代码 101 表示本次连接的 HTTP 协议即将被更改，更改后的协议就是 Upgrade: websocket 指定的 WebSocket 协议。
 * 版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用 WebSocket 的 API，就不需要关心这些。
 *
 * 5.WebSocket 实现原理
 * 实际上 HTTP 协议是建立在 TCP 协议之上的，TCP 协议本身就实现了全双工通信，但是 HTTP 协议的请求－应答机制限制了全双工通信。
 * WebSocket 连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用 HTTP 协议了，直接互相发数据吧。
 * 浏览器用 wss://xxx 创建 WebSocket 连接时，会先通过 HTTPS 创建安全的连接
 * 然后，该 HTTPS 连接升级为 WebSocket 连接，底层通信走的仍然是安全的 SSL/TLS 协议。
 *
 *
 * 6.服务器端实现 WebSocket
 * 由于 WebSocket 是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。
 * Node.js 本身支持的协议包括 TCP 协议和 HTTP 协议，要支持 WebSocket 协议，需要对 Node.js 提供的 HTTPServer 做额外的开发。
 * 已经有若干基于 Node.js 的稳定可靠的 WebSocket 实现，我们直接用 npm 安装使用即可。
 *
 */
```

- 一个简单的 WebSocket 实现案例

```ts
/**
 * 1.安装依赖
 * cnpm i ws -S
 */
// app.js 实例代码
// 导入 WebSocket 模块
const WebSocket = require('ws');

// 引用 Server 类
const WebSocketServer = WebSocket.Server;

// 实例化
const wss = new WebSocketServer({
  port: 3000, // 在 3000 端口上打开一个 WebSocket Server
});

// 如果有 WebSocket 请求接入 wws 对象可以响应 connection 事件来处理这个 WebSocket
wss.on('connection', function (ws) {
  console.log(`[SERVER] connection()`);
  ws.on('message', function (message) {
    console.log(`[SERVER] Received: ${message}`); //服务器接收到的信息
    setTimeout(() => {
      ws.send(`What's your name?`, (err) => {
        // 服务器发送信息
        if (err) {
          console.log(`[SERVER] error: ${err}`);
        }
      });
    }, 1000);
  });
});

console.log('ws server started at port 3000...');
```

```ts
// 客户端测试代码 实际代码中并不需要 仅用于测试
let count = 0;

let ws = new WebSocket('ws://localhost:3000/ws/chat');

ws.on('open', function () {
  console.log(`[CLIENT] open()`);
  ws.send('Hello!');
});

ws.on('message', function (message) {
  console.log(`[CLIENT] Received: ${message}`); // 客户端接收到的信息
  count++;
  if (count > 3) {
    ws.send('Goodbye!'); //客户端发送的信息
    ws.close();
  } else {
    setTimeout(() => {
      ws.send(`Hello, I'm Mr No.${count}!`); // 客户端发送的信息
    }, 1000);
  }
});
```

- 创建 WebSocket 连接(测试方法)

```ts
// 执行 JavaScript 代码的浏览器 Console，依次输入代码：
// 打开一个 WebSocket:
var ws = new WebSocket('ws://localhost:3000/test');
// 响应 onmessage 事件:
ws.onmessage = function (msg) {
  console.log(msg);
};
// 给服务器发送一个字符串:
ws.send('Hello!');
```

- 同源策略

```ts
/**
 * 从上面的测试可以看出，WebSocket 协议本身不要求同源策略（Same-origin Policy）
 * 也就是某个地址为http://a.com的网页可以通过WebSocket连接到ws://b.com。
 *
 * 但是，浏览器会发送 Origin 的 HTTP 头给服务器，服务器可以根据 Origin 拒绝这个 WebSocket 请求。
 * 所以，是否要求同源要看服务器端如何检查。
 */
```

- 编写聊天室

```ts
// 1.koa 和 WebSocketServer 可以共用一个端口
// 2.把 WebSocketServer 绑定到同一个端口的关键代码是先获取 koa 创建的 http.Server 的引用，再根据 http.Server 创建 WebSocketServer：
// koa app 的 listen()方法返回 http.Server:
let server = app.listen(3000);

// 创建 WebSocketServer:
let wss = new WebSocketServer({
  server: server,
});
```

- 配置反向代理

```bash
# 让 Nginx 理解该连接将使用 WebSocket 协议
server {
listen 80;
server_name localhost;

    # 处理静态资源文件:
    location ^~ /static/ {
        root /path/to/ws-with-koa;
    }

    # 处理WebSocket连接:
    location ^~ /ws/ {
        proxy_pass         http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header   Upgrade $http_upgrade;
        proxy_set_header   Connection "upgrade";
    }

    # 其他所有请求:
    location / {
        proxy_pass       http://127.0.0.1:3000;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

}

```

## 文件上传的实现

- 前端代码

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>fileApi实现Ajax上传文件</title>
    <link rel="stylesheet" href="" />
    <script src="../public/js/jquery-3.3.1.js"></script>
    <script>
      $(function () {
        console.log(`csrf {{ ctx.csrf | safe }}`);

        var formData = null;

        $('#file').on('change', function () {
          var fd = new FormData(); //创建FormData对象
          fd.append('name', '图片类型');
          fd.append('title', '文件上传');
          $('#debug').html('');
          var files = document.getElementsByTagName('input')[0].files; //js读取上传文件
          for (var i = 0; i < files.length; i++) {
            fd.append('files' + i, files[i]); //添加文件数据
            var img = document.createElement('img'); //动态创建img标签
            img.src = window.URL.createObjectURL(files[i]); //把二进制对象直接读出浏览器显示的资源
            var con = '<p>';
            con +=
              '文件名：' + files[i].name + '大小：' + files[i].size + '<br/>';
            con += '</p>';
            $('#debug').append(con);
            $('#debug').append(img);
          }

          formData = fd;
        });

        $('#btn').on('click', function () {
          console.log('点击上传');

          //ajax上传文件
          $.ajax({
            url: `api/upload?_csrf={{ ctx.csrf | safe }}`,
            type: 'POST',
            cache: false,
            data: formData,
            processData: false,
            contentType: false,
            dataType: 'json',
            beforeSend: function () {},
            success: function (data) {},
          });
        });
      });
    </script>
  </head>

  <body>
    <input id="file" type="file" name="pic" multiple="multiple" />
    <button id="btn">点击上传文件 {{name}}</button>
    <div id="debug"></div>
  </body>
</html>
```

- 服务器端 NodeJs 代码

```ts
// 注意：
// content-type: text/html; charset=utf-8 默认情况服务器会根据响应内容自动设置
const Koa = require('koa');
let Router = require('koa-router');
const koaBody = require('koa-body');
const fs = require('mz/fs');

const path = require('path');

const app = new Koa();
const router = new Router();

const uuidv1 = require('uuid/v1'); // 用于生成唯一值

// 打印请求的 url
app.use(async (ctx, next) => {
  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
  await next();
});

app.use(koaBody()); // 解析请求体参数 要不然服务器无法识别

// get 请求
router.get('/api/hello', async (ctx, next) => {
  // console.log(ctx.request.query); // { name: 'koa', password: '12345' } 获取链接上的参数
  ctx.response.body = ctx;
});

// post 请求
router.post('/api/pt', async (ctx, next) => {
  // console.log(ctx.request.query); // { name: 'koa', password: '12345' } 获取链接上的参数
  // console.log(ctx.request.body); // { id: 'test', manufacturer: '测试数据', name: '测试数据 1', price: 888888 } 获取 body 上的数据
  ctx.response.body = ctx;
});

// 文件上传接口
router.post(
  '/api/upload',
  koaBody({
    // 自定义 koaBody 配置选项
    multipart: true, // 是否支持 multipart-formdate 的表单 默认是 false (其实就是是否支持文件上传)
    encoding: 'gzip',
    formidable: {
      uploadDir: path.join(__dirname, 'uploads/files'), // 设置文件默认上传目录 自定义目录和名称可以不写
      keepExtensions: true, // 保持文件的后缀
      maxFieldsSize: 2 * 1024 * 1024, // 文件上传大小
      onFileBegin: (name, file) => {
        // 文件上传前的设置
        // name 是 input type='file' 的 name 属性值
        // file 为单个文件对象 多个文件上传 则 次文件会执行多次

        console.log('=============================');
        console.log(file);
        console.log('=============================');

        let date = new Date();
        let month = Number.parseInt(date.getMonth()) + 1;
        month = month.toString().length > 1 ? month : `0${month}`;
        let fileDir = `${date.getFullYear()}${month}${date.getDate()}`;

        let dir = path.join(__dirname, `uploads/files/${fileDir}`); // 设置文件上传路径 必须真实存在

        /**
         * 要生成文件在自定义的目录中 必须使用同步模式 要不然无法生成在自动目录 而是生成在默认目录下
         */
        try {
          fs.accessSync(dir);
          console.log('可读可写');
          upload();
        } catch (err) {
          console.error('不可访问');
          try {
            fs.mkdirSync(dir);
            upload();
          } catch (err) {
            console.log('err', err);
          }
        }

        function upload() {
          // 自定义生成文件
          let extname = path.extname(file.name);
          let fileName = uuidv1();
          let filePath = path.join(dir, file.name);
          file.path = filePath; // 指定文件生成路径 用于生成文件
        }
      },
    },
  }),
  async (ctx, next) => {
    console.log('上传成功');
    // console.log(ctx.request.files); // 获取上传后文件的信息
    // console.log(ctx.request.body); // 获取其他的表单字段
    ctx.response.body = JSON.stringify(ctx.request.files);
  }
);

// 添加路由中间件
app.use(router.routes()).use(router.allowedMethods());
app.listen(3000);
console.log('app started at port 3000...');
```

## 网络安全

- XSS 攻击

```ts
/**
 * XSS（cross-site scripting跨域脚本攻击）攻击是最常见的 Web 攻击，其重点是『跨域』和『客户端执行』。
 * XSS利用站点内的信任用户
 *
 * XSS 攻击：对 Web 页面注入脚本，使用 JavaScript 窃取用户信息，诱导用户操作。
 *
 * 1.Reflected XSS 反射型的 XSS 攻击
 * 反射型的 XSS 攻击，主要是由于服务端接收到客户端的不安全输入，在客户端触发执行从而发起 Web 攻击。
 * 解决方法: 对字符串进行 XSS 过滤
 * const str = '><script>alert("abc") </script><';
 * console.log(ctx.helper.escape(str));
 * // => &gt;&lt;script&gt;alert(&quot;abc&quot;) &lt;/script&gt;&lt;
 *
 * 2.Stored XSS 基于存储的 XSS 攻击
 * 基于存储的 XSS 攻击，是通过提交带有恶意脚本的内容存储在服务器上，当其他人看到这些内容时发起 Web 攻击。
 * 内容都是通过一些富文本编辑器编辑的，很容易插入危险代码。
 *
 * 3.JSONP XSS
 * JSONP 的 callback 参数非常危险，他有两种风险可能导致 XSS
 * callback 参数意外截断js代码，特殊字符单引号双引号，换行符均存在风险。
 * callback 参数恶意添加标签（如 <script> ），造成 XSS 漏洞。
 *
 * 防范JSONP XSS
 * callback 函数名词最长 50 个字符限制
 * callback 函数名只允许 [, ], a-zA-Z0123456789_, $,
 *
 * 其他 XSS 的防范方式
 * CSP(Content Security Policy) 内容安全策略
 * CSP是一种由开发者定义的安全性政策性申明，通过CSP所约束的的规责指定可信的内容来源
 * （这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源）。通过CSP协定，让WEB处于一个安全的运行环境中。
 */
```

- CSRF 攻击

```ts
/**
 * CSRF 攻击：伪造用户请求向网站发起恶意请求。
 * CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。
 * CSRF（Cross-site request forgery跨站请求伪造，也被称为 One Click Attack 或者 Session Riding，
 * 通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。
 * CSRF 攻击会对网站发起恶意伪造的请求，严重影响网站的安全
 *
 * 攻击原理
 * 1. 用户打开浏览器，访问受信任银行网站，输入用户名和密码请求登录网站；
 * 2.在用户信息通过验证后，银行网站产生Cookie信息并返回给浏览器，此时用户登录网站成功，可以正常发送请求到网站；
 * 3. 用户未退出银行网站之前，在同一浏览器中，打开一个TAB页访问其他网站B
 * 4. 这时候网站B 已被黑客注入诱导信息，加入是一张图片,图片地址指向
 * src=”http://bank.example/withdraw?account=bob&amount=1000000&for=黑客
 * 点击之后转账给黑客这个账户
 * 5. 浏览器在接收到这些攻击性代码请求后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，
 * 根据用户的Cookie信息以C的权限处理该请求，导致来自黑客请求恶意代码被执行。
 *
 * 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，
 * 但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，
 * 添加系统管理员，甚至于购买商品、虚拟货币转账等
 *
 *
 *
 *
 * 如何防御CSRF攻击
 *
 * 1.验证 HTTP Referer 字段
 * 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。
 * 也就是说，服务器会验证客户端的请求来源，如果本网站请求的则响应，否则不响应。
 * 但是即使这样，验证 HTTP Referer 字段 这种方式也存在安全隐患
 * - 对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值
 * - 用户自己可以设置浏览器使其在发送请求时不再提供 Referer
 *
 * 2.加验证码验证
 * 但这种方式涉及到页面交互，在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。
 * 因此验证码只能作为一种辅助手段，不能作为主要解决方案。
 *
 * 3.使用 token （Anti CSRF Token）
 * 可以理解是防伪
 * 用户访问某个表单页面。
 * 服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。
 * 在页面表单附带上Token参数。
 * 用户提交请求后， 服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。
 *
 * 这个Token的值必须是随机的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。
 * 另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。
 *
 */
```

- 安全威胁 XST

```ts
/**
 * XST 的全称是 Cross-Site Tracing，客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，
 * 则在 response body 里会返回此次请求的完整头信息。
 * 通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。
 *
 * 防范
 * 禁止 trace，track，options 三种危险类型请求
 */
```

- 安全威胁 钓鱼攻击 的防范

```ts
/**
 * 钓鱼有多种方式，这里介绍 url 钓鱼、图片钓鱼和 iframe 钓鱼。
 *
 * 1.url 钓鱼
 * 服务端未对传入的跳转 url 变量进行检查和控制，可能导致可恶意构造任意一个恶意地址，诱导用户跳转到恶意网站。
 * 防范
 * 对url进行校验再跳转
 * 判断 url 是否在应用授权的白名单内。
 *
 * 2.图片钓鱼
 * 如果可以允许用户向网页里插入未经验证的外链图片，这有可能出现钓鱼风险
 *
 * 3.iframe 钓鱼
 * iframe 钓鱼，通过内嵌 iframe 到被攻击的网页中，
 * 攻击者可以引导用户去点击 iframe 指向的危险网站，甚至遮盖，影响网站的正常功能，劫持用户的点击操作。
 *
 * 防范
 * 只允许同域把本页面当作 iframe 嵌入。
 */
```

- 安全威胁 HPP 的防范

```ts
/**
 * Http Parameter Pollution（HPP)，即 HTTP 参数污染攻击。
 *
 * 在HTTP协议中是允许同样名称的参数出现多次，而由于应用的实现不规范，
 * 攻击者通过传播参数的时候传输 key 相同而 value 不同的参数，从而达到绕过某些防护的后果
 *
 * HPP 可能导致的安全威胁有：
 * 绕过防护和参数校验。
 * 产生逻辑漏洞和报错，影响应用代码执行。
 * 在客户端传输 key 相同而 value 不同的参数时，强制使用第一个参数，因此不会导致 hpp 攻击
 */
```

- 中间人攻击与 HTTP / HTTPS

```ts
/**
 *
 * 内容请求和获取时会经过许多中间人，主要是网络环节，充当内容入口的浏览器、路由器厂商、WIFI提供商、通信运营商，
 * 如果使用了代理、翻墙软件则会引入更多中间人。由于 HTTP 请求的路径、参数默认情况下均是明文的，
 * 因此这些中间人可以对 HTTP 请求进行监控、劫持、阻挡。
 *
 *
 * 数据泄露、请求劫持、内容篡改等等问题，核心原因就在于 HTTP 是全裸式的明文请求，域名、路径和参数都被中间人们看得一清二楚。
 * 运营商可在用户发起请求时直接跳转到某个广告，或者直接改变搜索结果插入自家的广告。如果劫持代码出现了 BUG ，
 * 则直接让用户无法使用，出现白屏。
 *
 * HTTPS 做的就是给请求加密，让其对用户更加安全。对于自身而言除了保障用户利益外，还可避免本属于自己的流量被挟持，以保护自身利益。
 * 尽管 HTTPS 并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击。
 * 不过HTTPS是现行架构下最安全的解决方案，并且它大幅增加了中间人攻击的成本。
 */
```

- 安全威胁 SSRF 的防范

```ts
/**
 * 通过 Server-Side Request Forgery(SSRF) 攻击，攻击者可以发起网络请求访问或者操作内部网络的资源。
 *
 * 一般来说，SSRF 安全漏洞常见于开发者在服务端直接请求客户端传递进来的 URL 资源，
 * 一旦攻击者传入一些内部的 URL 即可发起 SSRF 攻击。
 *
 * 通常我们会基于内网 IP 黑名单的形式来防范 SSRF 攻击，
 * 通过对解析域名后得到的 IP 做过滤，禁止访问内部 IP 地址来达到防范 SSRF 攻击的目的。
 *
 * SSRF攻击通常针对外部网络无法直接访问的内部系统。
 * 攻击者想要访问主机B上的服务，但是由于存在防火墙或者主机B是属于内网主机等原因导致攻击者无法直接访问主机B。
 * 而服务器A存在SSRF漏洞，这时攻击者可以借助服务器A来发起SSRF攻击，通过服务器A向主机B发起请求，从而获取主机B的一些信息。
 *
 * 防范
 * 1、过滤返回的信息，如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。
 * 2、统一错误信息，避免用户可以根据错误信息来判断远程服务器的端口状态。
 * 3、限制请求的端口，比如80,443,8080,8090。
 * 4、禁止不常用的协议，仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp://等引起的问题。
 * 5、使用DNS缓存或者Host白名单的方式。
 *
 */
```
