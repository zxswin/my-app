## 观察者模式与发布订阅模式

- 观察者模式代码实现

```ts
/**
 * 模式特点
 * 1.一个目标者对象 Subject，拥有方法：添加 / 删除 / 通知 Observer；
 * 2.多个观察者对象 Observer，拥有方法：接收 Subject 状态变更通知并处理；
 * 3.目标对象 Subject 状态变更时，通知所有 Observer。
 *
 * 优点：
 * 1.目标者与观察者，功能耦合度降低，专注自身功能逻辑；
 * 2.观察者被动接收更新，时间上解耦，实时接收目标者更新状态。
 *
 * 缺点：
 * 观察者模式虽然实现了对象间依赖关系的低耦合，但却不能对事件通知进行细分管控，
 * 如 “筛选通知”，“指定主题事件通知” 。
 *
 * 观察者模式两个对象之间有很强的依赖关系；发布/订阅模式两个对象之间的耦合度底
 */
// 目标者类
class Subject {
  constructor() {
    this.observers = []; // 观察者列表
  }
  // 添加
  add(observer) {
    this.observers.push(observer);
  }
  // 删除
  remove(observer) {
    let idx = this.observers.findIndex((item) => item === observer);
    idx > -1 && this.observers.splice(idx, 1);
  }
  // 通知
  notify() {
    for (let observer of this.observers) {
      observer.update();
    }
  }
}

// 观察者类
class Observer {
  constructor(name) {
    this.name = name;
  }
  // 目标对象更新时触发的回调
  update() {
    console.log(`目标者通知我更新了，我是：${this.name}`);
  }
}

// 实例化目标者
let subject = new Subject();

// 实例化两个观察者
let obs1 = new Observer('前端开发者');
let obs2 = new Observer('后端开发者');

// 向目标者添加观察者
subject.add(obs1);
subject.add(obs2);

// 目标者通知更新
subject.notify();
// 输出：
// 目标者通知我更新了，我是前端开发者
// 目标者通知我更新了，我是后端开发者
```

- 发布订阅模式代码实现

```ts
/**
 * 发布订阅模式：
 * 基于一个事件（主题）通道，希望接收通知的对象 Subscriber 通过自定义事件订阅主题，
 * 被激活事件的对象 Publisher 通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象。
 *
 * 优势：
 * 对象间功能解耦，弱化对象间的引用关系；
 * 更细粒度地管控，分发指定订阅主题通知
 *
 * 缺点：
 * 对象间解耦后，代码阅读不够直观，不易维护；
 * 额外对象创建，消耗时间和内存（很多设计模式的通病
 */
// 事件中心
let pubSub = {
  list: {},
  subscribe: function (key, fn) {
    // 订阅
    if (!this.list[key]) {
      this.list[key] = [];
    }
    this.list[key].push(fn);
  },
  publish: function (key, ...arg) {
    // 发布
    for (let fn of this.list[key]) {
      fn.call(this, ...arg);
    }
  },
  unSubscribe: function (key, fn) {
    // 取消订阅
    let fnList = this.list[key];
    if (!fnList) return false;

    if (!fn) {
      // 不传入指定取消的订阅方法，则清空所有key下的订阅
      fnList && (fnList.length = 0);
    } else {
      fnList.forEach((item, index) => {
        if (item === fn) {
          fnList.splice(index, 1);
        }
      });
    }
  },
};

// 订阅
pubSub.subscribe('onwork', (time) => {
  console.log(`上班了：${time}`);
});
pubSub.subscribe('offwork', (time) => {
  console.log(`下班了：${time}`);
});
pubSub.subscribe('launch', (time) => {
  console.log(`吃饭了：${time}`);
});

// 发布
pubSub.publish('offwork', '18:00:00');
pubSub.publish('launch', '12:00:00');

// 取消订阅
pubSub.unSubscribe('onwork');
```

- 共同点及区别

```ts
/**
 * 类似点
 * 都是定义一个一对多的依赖关系，有关状态发生变更时执行相应的通知。
 *
 * 区别点
 * 发布订阅模式更灵活，是进阶版的观察者模式，指定对应分发。
 *
 *
 * 1.观察者模式维护单一事件对应多个依赖该事件的对象关系；
 * 2.发布订阅维护多个事件（主题）及依赖各事件（主题）的对象之间的关系；
 * 3.观察者模式是目标对象直接触发通知（全部通知），观察对象被迫接收通知。发布订阅模式多了个中间层（事件中心），由其去管理通知广播（只通知订阅对应事件的对象）；
 * 4.观察者模式对象间依赖关系较强，发布订阅模式中对象之间实现真正的解耦。
 */
```

- DOM 事件监听也是 “发布订阅模式” 的应用

```ts
let loginBtn = document.getElementById('#loginBtn');

// 监听回调函数（指定事件）
function notifyClick() {
  console.log('我被点击了');
}

// 添加事件监听
loginBtn.addEventListener('click', notifyClick);
// 触发点击, 事件中心派发指定事件
loginBtn.click();

// 取消事件监听
loginBtn.removeEventListener('click', notifyClick);
```

- jQuery 的 \$.Callback()

```ts
// jQuery 的 $.Callback() 更像是观察者模式的应用，不能更细粒度管控。
function notifyHim(value) {
  console.log('He say ' + value);
}

function notifyHer(value) {
  console.log('She say ' + value);
}

$cb = $.Callbacks(); // 声明一个回调容器：订阅列表

$cb.add(notifyHim); // 向回调列表添加回调：订阅
$cb.add(notifyHer); // 向回调列表添加回调：订阅

$cb.fire('help'); // 调用所有回调： 发布
```
