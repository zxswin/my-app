## 数组方法的重写

- forEach 重写

```ts
Array.prototype.myForEach = function (fn) {
  let arr = this;
  let len = arr.length;
  let arg2 = arguments[1] || window;

  for (var i = 0; i < len; i++) {
    fn.apply(arg2, [arr[i], i, arr]);
  }
};
// 测试代码
let arr = [1, 2, 3, 4];
arr.myForEach(
  function (item, index, arr) {
    console.log(item, this);
  },
  { a: 1 }
);
```

- filter 重写

```ts
/**
 * 返回一个新数组
 * 但是数组里面的项如果是引用类型,改变来引用类型也会影响到新的数组
 */
Array.prototype.myFilter = function (fn) {
  let arr = this;
  let len = arr.length;
  let arg2 = arguments[1] || window;
  let nArr = [];

  for (var i = 0; i < len; i++) {
    fn.apply(arg2, [arr[i], i, arr]) ? nArr.push(arr[i]) : '';
  }

  return nArr;
};
// 测试代码
let arr = [1, 2, 3, 4];
let nArr = arr.myFilter(
  function (item, index, arr) {
    return item === 1;
  },
  { a: 1 }
);

console.log(nArr);
```

- map 方法重写

```ts
/**
 * 返回一个新数组
 * 但是数组里面的项如果是引用类型,改变来引用类型也会影响到新的数组
 */

Array.prototype.myMap = function (fn) {
  let arr = this;
  let len = arr.length;
  let arg2 = arguments[1] || window;
  let nArr = [];

  for (var i = 0; i < len; i++) {
    nArr.push(fn.apply(arg2, [arr[i], i, arr]));
  }

  return nArr;
};
// 测试代码
let arr = [1, 2, 3, 4];
let nArr = arr.myMap(
  function (item, index, arr) {
    return 1;
  },
  { a: 1 }
);

console.log(nArr);
```

- every 方法重写

```ts
/**
 * 如果有一个不满足条件就停止遍历,条件就是return后面的表达式
 * 返回一个布尔值
 */
Array.prototype.myEvery = function (fn) {
  let arr = this;
  let len = arr.length;
  let arg2 = arguments[1] || window;
  let res = true;

  for (var i = 0; i < len; i++) {
    if (!fn.apply(arg2, [arr[i], i, arr])) {
      res = false;
      break;
    }
  }

  return res;
};
// 测试代码
let arr = [1, 1, 1, 1];
let res = arr.myEvery(
  function (item, index, arr) {
    return item === 1;
  },
  { a: 1 }
);

console.log(res);
```

- some 方法重写

```ts
/**
 * 如果有一个满足条件就停止遍历,条件就是return后面的表达式
 * 返回一个布尔值
 */
Array.prototype.mySome = function (fn) {
  let arr = this;
  let len = arr.length;
  let arg2 = arguments[1] || window;
  let res = false;

  for (var i = 0; i < len; i++) {
    if (fn.apply(arg2, [arr[i], i, arr])) {
      res = true;
      break;
    }
  }

  return res;
};
// 测试代码
let arr = [2, 2, 1, 2];
let res = arr.mySome(
  function (item, index, arr) {
    return item === 1;
  },
  { a: 1 }
);

console.log(res);
```

- reduce 方法重写

```ts
/**
 * 归纳函数或缩减器
 * reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。
 * 您的 reducer 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。
 */
Array.prototype.myReduce = function (fn, initialValue) {
  let arr = this;
  let len = arr.length;
  let arg2 = arguments[1] || window;
  let start = typeof initialValue !== 'undefined' ? 0 : 1;
  initialValue = typeof initialValue !== 'undefined' ? initialValue : arr[0];

  for (var i = start; i < len; i++) {
    console.log(i);
    initialValue = fn.apply(arg2, [initialValue, arr[i], i, arr]);
  }

  return initialValue;
};
// 测试代码
let arr = [2, 2, 1, 2];
let res = arr.myReduce(function (prve, item, index, arr) {
  prve += item;
  return prve;
});

console.log(res);
```
