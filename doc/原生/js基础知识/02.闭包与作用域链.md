## 闭包与作用域链

- 环境与作用域

```ts
/**
 * 全局作用域下的环境是不会被回收的
 */

function show() {
  let url = "abc.com";
}
// 函数每被执行一次都会在内存中开辟一个新的环境
// 当函数被执行完后没有用的变量将会被清除 环境也会被清除
show();
show();

/**
 * 当函数内部的函数被外部的变量保存的时候 当函数被执行完后它的环境不会被清除
 * 如果在执行函数重新赋值给新的变量,则会开辟一个全新的环境
 */

function hd() {
  let n = 1;
  function sum() {
    console.log(++n);
  }

  return sum;
}

let a = hd();
a(); // 2
a(); // 3

// 此时会开辟一个全新的环境
let b = hd();
b(); // 2
b(); // 3
```

- 构造函数中作用域的使用形态

```ts
function Hd() {
  let n = 1;
  this.sum = () => {
    console.log(n++);
  };

  // 隐式return出this
}

let a = new Hd();
a.sum();
a.sum();
```

- 什么是块级作用域

```ts
// 变量a是在两个不同的块作用域中
{
  let a = 1;
}

{
  let a = 2;
}
```

- let const var 在 for 循环中的使用原理

```ts
/* var 的for循环原理 */

// 因为var没有块级作用域所以 var i =1;
// i是定义在window下面的一个变量
for (var i = 1; i <= 3; i++) {
  console.log(i);
}
console.log(i); // 4 外面可以访问到i

/* let 的for循环原理 */
// 因为let有块级作用域所以 let i =1;
// i是定义在for循环的块级作用域内的
for (var i = 1; i <= 3; i++) {
  console.log(i);
}
console.log(i); // undefined 外面是不可以访问到i的

/* const的for循环原理同let */
```

- 模拟出 var 的伪类作用域

```ts
for (var i = 1; i <= 3; i++) {
  // 自执行函数的每次执行都会形成自动的作用域链
  (function (a) {
    console.log(i);
  })(i);
}
```

- 闭包与其他语言对比实例

```ts
/**
 * 定义：函数内的子函数可以访问其父函数的作用域链
 */

// 使用闭包来获取数组的区间值
let lessons = [1, 10, 20, 100];
function between(a, b) {
  return function (v) {
    // 在这个函数里可以范围到a,b
    return v > a && v < b;
  };
}

console.log(lessons.filter(between(10, 100)));
```

-  使用闭包来实现移动动画效果

```ts
let btns = document.querySelectorAll("button");
btns.forEach(function (item) {
  item.addEventListener("click", function () {
    let left = 1;
    setInterval(function () {
      // 通过闭包这个函数可以访问到外部的left
      // 这个函数执行完后并不会被销毁掉
      item.style.left = left++ + "px";
    });
  });
});
```

- 动画为什么会抖动呢

```ts
/**
 * 产生抖动的原因是每次点击的时候都会产生一个新的环境let被重新置为1
 */
let btns = document.querySelectorAll("button");
btns.forEach(function (item) {
  let left = 1; // 把left提升到父级作用域可以解决这个抖动的问题
  item.addEventListener("click", function () {
    setInterval(function () {
      // 通过闭包这个函数可以访问到外部的left
      // 这个函数执行完后并不会被销毁掉
      item.style.left = left++ + "px";
    });
  });
});
```

- 解决动画加速的问题

```ts
/**
 * 动画加速的原因:每点击一次都会产生一个新的定时器,在多个定时器的作用下导致动画加速了
 */

let btns = document.querySelectorAll("button");
btns.forEach(function (item) {
  let left = 1; // 把left提升到父级作用域可以解决这个抖动的问题
  let interval = false;

  item.addEventListener("click", function () {
    if (!interval) {
      interval = true;
      setInterval(function () {
        // 通过闭包这个函数可以访问到外部的left
        // 这个函数执行完后并不会被销毁掉
        item.style.left = left++ + "px";
      });
    }
  });
});
```

- 利用必包来进行排序

```ts
// 排序函数
function order(field, type = "asc") {
  return function (a, b) {
    if (type === "asc") return a[field] < b[field] ? 1 : -1;
    return a[field] > b[field] ? 1 : -1;
  };
}

// 每对一组数据进行排序 sort里面的函数都会产生一个新的作用域
// 利用闭包这个排序函数可以范围到函数外部的参数
let hd = lessons.sort(order("click"));
```

- 闭包内存泄露的解决方法

```ts
let divs = document.querySelectorAll("div");

divs.forEach(function (item) {
  let desc = item.getAttribute("desc");
  item.addEventListener("click", function () {
    console.log(desc);
    console.log(item); // 这里打印的item是null
  });
  item = null; // 清空item 避免内存泄露
});
```

- this 在闭包中的历史遗留问题

```ts
/**
 * this指向的是当前调用函数的对象
 */

let hd = {
  user:'后盾人'
  get:function(){
    return function(){
      // 可以使用箭头函数来把this指向hd
      return this.user;
    }
  }
}
let a = hd.get;
console.log(a()); // undefined a函数中的this指向window
```
