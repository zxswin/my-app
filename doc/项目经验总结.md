## 原生 js

- querySelector() 方法

```ts
/**
 * querySelector() 方法仅仅返回匹配指定选择器的第一个元素
 */
document.querySelector('#demo');
```

- querySelectorAll()

```ts
/**
 * querySelectorAll() 方法返回文档中匹配指定 CSS 选择器的所有元素，返回 NodeList 对象
 */
// 获取文档中所有的 <p> 元素
var x = document.querySelectorAll('p');

// 设置第一个 <p> 元素的背景颜色
x[0].style.backgroundColor = 'red';
```

- NodeList

```ts
/**
 * NodeList 对象是一个从文档中获取的节点列表 (集合) 。
 */
// HTMLCollection 是 HTML 元素的集合。

// NodeList 是一个文档节点的集合。

// NodeList 与 HTMLCollection 有很多类似的地方。

// NodeList 与 HTMLCollection 都与数组对象有点类似，可以使用索引 (0, 1, 2, 3, 4, ...) 来获取元素。

// NodeList 与 HTMLCollection 都有 length 属性。

// HTMLCollection 元素可以通过 name，id 或索引来获取。

// NodeList 只能通过索引来获取。

// 只有 NodeList 对象有包含属性节点和文本节点。

// 节点列表不是一个数组！

// 节点列表看起来可能是一个数组，但其实不是。

// 你可以像数组一样，使用索引来获取元素。

// 节点列表无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。
```

- Node.contains()

```ts
/**
 * Node.contains()
 *
 * node.contains( otherNode )
 * node 是否包含otherNode节点.
 * otherNode 是否是node的后代节点.
 *
 * 如果 otherNode 是 node 的后代节点或是 node 节点本身.则返回true , 否则返回 false.
 */
var span = document.getElementById('mySPAN');
var div = document.getElementById('myDIV').contains(span);
```

## 普通元素获取焦点

```ts
// 普通元素需要添加 tabIndex="0" 输出才可以捕获onBlur和onFocus事件
```

## es6 语法使用

### 数组

- reduce

```ts
/**
 * 简单使用
 * reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。
 * reducer 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。
 * reduce() 对于空数组是不会执行回调函数的。
 *
 * array.reduce(function(total, currentValue, currentIndex, arr), initialValue)
 * total	必需。初始值, 或者计算结束后的返回值。
 * currentValue	必需。当前元素
 * currentIndex	可选。当前元素的索引
 * arr	可选。当前元素所属的数组对象。
 * initialValue	可选。传递给函数的初始值
 */

const arrNum = [1, 2, 3, 4, 5, 6, 10];
const totalNum = arrNum.reduce((total, num) => {
  return total + num;
});

console.log(totalNum); // 31

/**
 * 自己实现一个reduce的方法
 */
// callback参数有4个。pre,cur,index,arr
Array.prototype.myReduce = function (callback, prev) {
  for (let i = 0; i < this.length; i++) {
    // 判断有没有第二个参数
    if (!prev) {
      // 没有prev复杂点，第一次拿的是两个元素arr[0],arr[1]，注意index的变化
      prev = callback(this[i], this[i + 1], i + 1, this); //这里的指针是i+1都是对的，但是下一次循环的时候i必须按是3所以需要+1
      i++; // 第一次循环了两个变量，下次应该从第三个执行，所以向后移动
    } else {
      //有prev简单，直接就是从arr[0]开始递归
      prev = callback(prev, this[i], i, this);
    }
  }
  return prev;
};

/**
 * 使用reduce实现一个数组扁平化的方法
 */
Array.prototype.myflat = function (depth = 1) {
  return this.reduce((pre, cur) => {
    if (Array.isArray(cur)) {
      // 这里应该每次reduce都产生一个新的depth
      let _depth = depth;
      if (_depth > 0) {
        _depth--;
        pre = [...pre, ...cur.myflat(_depth)];
      } else {
        // depth = 0控制结束递归
        if (cur.length !== 0) {
          // 空数组抛弃！
          pre.push(cur);
        }
      }
    } else {
      pre.push(cur);
    }
    return pre;
  }, []);
};

/**
 * 实现compose函数 这可是中间件的原理
 */

var compose = function (f, g) {
  //compose极简写法，仅做示例
  return function (x) {
    return f(g(x));
  };
};

/**
 * 使用reduce实现compose函数
 */
function compose(...fns) {
  return fns.reduce(function (a, b) {
    return function (...args) {
      //compose返回的是一个函数
      return a(b(...args));
    };
  });
}

//reduce简化版 一行代码搞定   面试装B必背
let compose = (...fns) => fns.reduce((a, b) => (...args) => a(b(...args)));
```

- flat()扁平化

```ts
/**
 * flat() 方法会按照一个可指定的深度递归遍历数组
 * depth 可选指定要提取嵌套数组的结构深度，默认值为 1。
 *
 * flat() 方法会移除数组中的空项
 */
var arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]

var arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]

var arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]

//使用 Infinity，可展开任意深度的嵌套数组
var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

- flatMap()

```ts
/**
 *  返回值：一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 depth 值为1
 *  flatMap 方法与 map 方法和深度depth为1的 flat 几乎相同
 */

var arr1 = [1, 2, 3, 4];
arr1.flatMap(x => [[x * 2]]);
// [[2], [4], [6], [8]]

/**
 * 只需返回一个1项元素数组以保留该项，返回一个多元素数组以添加项，或返回一个0项元素数组以删除该项
 */
let a = [5, 4, -3, 20, 17, -33, -4, 18];
const newarr = a.flatMap(n => (n > 0 ? n : []));

console.log(newarr); // [5, 4, 20, 17, 18]
```

### Object 的使用

- 判断某个属性是否在对象里

```ts
/**
 * 使用in关键字
 * 该方法可以判断对象的自有属性和继承来的属性是否存在
 */
var o = { x: 1 };

'x' in o; //true，自有属性存在

'y' in o; //false

'toString' in o; //true，是一个继承属性

/**
 * 使用对象的hasOwnProperty()方法
 * 该方法只能判断自有属性是否存在，对于继承属性会返回false
 */
var o = { x: 1 };

o.hasOwnProperty('x'); //true，自有属性中有x
o.hasOwnProperty('y'); //false，自有属性中不存在y
o.hasOwnProperty('toString'); //false，这是一个继承属性，但不是自有属性

/**
 * 使用undefined判断
 * 自有属性和继承属性均可判断
 */
var o = { x: 1 };

o.x !== undefined; //true

o.y !== undefined; //false

o.toString !== undefined; //true
```

- 对 Object 中的索引进行循环

```ts
let obj = {
  name: '张三',
  sex: '男',
  age: 20,
  height: 150,
};

for (let key of Object.keys(obj)) {
  console.log(key);
}

// name
// sex
// age
// height
```

- 对 Object 中的值进行循环。

```tsx
let obj = {
  name: '张三',
  sex: '男',
  age: 20,
  height: 150,
};

for (let val of Object.values(obj)) {
  console.log(val);
}

// 张三
// 男
// 20
// 150
```

- 循环 Object 中的某一项

```tsx
let obj = {
  name: '张三',
  sex: '男',
  age: 20,
  height: 150,
};

for (let val of Object.entries(obj)) {
  console.log(val);
}

// (2) ["name", "张三"]
// (2) ["sex", "男"]
// (2) ["age", 20]
// (2) ["height", 150
```

- 上面把属性和值放在一个数组里，下面把他们拆开

```tsx
let obj = {
  name: '张三',
  sex: '男',
  age: 20,
  height: 150,
};

for (let [key, val] of Object.entries(obj)) {
  console.log(key, val);
}

// name 张三
// sex 男
// age 20
// height 150
```

- Object.defineProperty() 定义对象的属性

```ts
/* Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 */
var o = {}; // 创建一个新对象

// 在对象中添加一个属性与数据描述符的示例
Object.defineProperty(o, 'a', {
  value: 37,
  writable: true,
  enumerable: true,
  configurable: true,
});

console.log('o', o);
```

### js 阻止事件冒泡

```tsx
event.stopPropagation(); // 阻止事件冒泡
event.preventDefault(); // 阻止默认事件
```

### dispatchEvent

```ts
/**
 * 向一个指定的事件目标派发一个事件,  并以合适的顺序同步调用目标元素相关的事件处理函数
 */

// 会自动执行按钮的点击事件
button.dispatchEvent(new MouseEvent('click', { bubbles: true }));
```

### MouseEvent()构造函数

```ts
/**
 * 生成一个新的MouseEvent对象
 */

function simulateClick() {
  var evt = new MouseEvent("click", {
    bubbles: true,
    cancelable: true,
    view: window,
  });
  var cb = document.getElementById("checkbox"); //element to click on
  var canceled = !cb.dispatchEvent(evt);
  if(canceled) {
    // A handler called preventDefault
    alert("canceled");
  } else {
    // None of the handlers called preventDefault
    alert("not canceled");
  }
}
document.getElementById("button").addEventListener('click', simulateClick);

<p><label><input type="checkbox" id="checkbox"> Checked</label>
<p><button id="button">Click me</button>

```

### EventEmitter 的使用

```ts
//event.js 文件
var events = require('events');
var emitter = new events.EventEmitter();
emitter.on('someEvent', function (arg1, arg2) {
  console.log('listener1', arg1, arg2);
});
emitter.on('someEvent', function (arg1, arg2) {
  console.log('listener2', arg1, arg2);
});

// emit可以传递参数给上面的回调函数
emitter.emit('someEvent', 'arg1 参数', 'arg2 参数');
```

- Object.is() 方法判断两个值是否为同一个值。

```ts
/**
 * 语法:Object.is(value1, value2);
 *
 * Object.is() 方法判断两个值是否为同一个值。
 * 都是 undefined
 * 都是 null
 * 都是 true 或 false
 * 都是相同长度的字符串且相同字符按相同顺序排列
 * 都是相同对象（意味着每个对象有同一个引用）
 * 都是数字且
 *   都是 +0
 *   都是 -0
 *   都是 NaN
 *   或都是非零而且非 NaN 且为同一个值
 */
```

### websocket 的使用

- 特点

```ts
/**
 * 1.服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息
 * 2.建立在 TCP 协议之上，服务器端的实现比较容易。
 * 3.与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器
 * 4.数据格式比较轻量，性能开销小，通信高效
 * 5.可以发送文本，也可以发送二进制数据。
 * 6.没有同源限制，客户端可以与任意服务器通信。
 * 7.协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。
 */
```

- 简单使用案例

```ts
// 执行这个语句之后，客户端就会与服务器进行连接
var ws = new WebSocket('wss://echo.websocket.org');

ws.onopen = function (evt) {
  console.log('Connection open ...');
  ws.send('Hello WebSockets!');
};

ws.onmessage = function (evt) {
  console.log('Received Message: ' + evt.data);
  ws.close();
};

ws.onclose = function (evt) {
  console.log('Connection closed.');
};
```

- webSocket.readyState

```ts
/**
 * readyState属性返回实例对象的当前状态
 * CONNECTING：值为0，表示正在连接。
 * OPEN：值为1，表示连接成功，可以通信了。
 * CLOSING：值为2，表示连接正在关闭。
 * CLOSED：值为3，表示连接已经关闭，或者打开连接失败。
 */
switch (ws.readyState) {
  case WebSocket.CONNECTING:
    // do something
    break;
  case WebSocket.OPEN:
    // do something
    break;
  case WebSocket.CLOSING:
    // do something
    break;
  case WebSocket.CLOSED:
    // do something
    break;
  default:
    // this never happens
    break;
}
```

- 常用

```ts
// webSocket.onopen
// 用于指定连接成功后的回调函数
ws.onopen = function () {
  ws.send('Hello Server!');
};

// 指定多个回调函数，可以使用addEventListener方法
ws.addEventListener('open', function (event) {
  ws.send('Hello Server!');
});

// webSocket.onclose
// 用于指定连接关闭后的回调函数
ws.onclose = function (event) {
  var code = event.code;
  var reason = event.reason;
  var wasClean = event.wasClean;
  // handle close event
};

ws.addEventListener('close', function (event) {
  var code = event.code;
  var reason = event.reason;
  var wasClean = event.wasClean;
  // handle close event
});

// webSocket.onmessage
// 用于指定收到服务器数据后的回调函数
ws.onmessage = function (event) {
  var data = event.data;
  // 处理数据
};

ws.addEventListener('message', function (event) {
  var data = event.data;
  // 处理数据
});

// 服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）
ws.onmessage = function (event) {
  if (typeof event.data === String) {
    console.log('Received data string');
  }

  if (event.data instanceof ArrayBuffer) {
    var buffer = event.data;
    console.log('Received arraybuffer');
  }
};

// 使用binaryType属性，显式指定收到的二进制数据类型
// 收到的是 blob 数据
ws.binaryType = 'blob';
ws.onmessage = function (e) {
  console.log(e.data.size);
};

// 收到的是 ArrayBuffer 数据
ws.binaryType = 'arraybuffer';
ws.onmessage = function (e) {
  console.log(e.data.byteLength);
};

// send()方法用于向服务器发送数据
ws.send('your message');

// 发送 ArrayBuffer 对象的例子
var img = canvas_context.getImageData(0, 0, 400, 320);
var binary = new Uint8Array(img.data.length);
for (var i = 0; i < img.data.length; i++) {
  binary[i] = img.data[i];
}
ws.send(binary.buffer);

// webSocket.bufferedAmount
// 实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束
var data = new ArrayBuffer(10000000);
socket.send(data);

if (socket.bufferedAmount === 0) {
  // 发送完毕
} else {
  // 发送还没结束
}

// webSocket.onerror
// 实例对象的onerror属性，用于指定报错时的回调函数。
socket.onerror = function (event) {
  // handle error event
};

socket.addEventListener('error', function (event) {
  // handle error event
});
```

### 存取器(对象访问器)

- 取

```ts
// 创建一个对象
var person = {
  firstName: 'Bill',
  lastName: 'Gates',
  language: 'en',
  get lang() {
    return this.language.toUpperCase();
  },
};

// 使用 getter 来显示来自对象的数据：
document.getElementById('demo').innerHTML = person.lang;

// 使用 setter 来设置对象属性：
person.lang = 'en';
```

- 设置

```ts
var person = {
  firstName: 'Bill',
  lastName: 'Gates',
  language: '',
  set lang(lang) {
    this.language = lang;
  },
};

// 使用 setter 来设置对象属性：
person.lang = 'en';

// 显示来自对象的数据：
document.getElementById('demo').innerHTML = person.language;
```

### Reflect

```ts
/**
 * Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的。
 */
```

### Proxy

```ts
/**
 * Proxy 可以对目标对象的读取、函数调用等操作进行拦截，然后进行操作处理。它不直接操作对象，而是像代理模式，
 * 通过对象的代理对象进行操作，在进行这些操作时，可以添加一些需要的额外操作。
 */
```

## clientHeight , scrollHeight 和 offsetHeight

```ts
/**
 * clientHeight
 * clientHeight = 内容实际高度 + 上下内边距
 * jQuery: $ (obj).innerHeight();
 *
 * offsetHeight
 * offsetHeight = height + padding + border
 * offsetHeight获取到的高度是网页实际渲染出来的高度+内边距+边框
 * jQuery: $ (obj).outerHeight();
 * jQuery: $ (obj).outerHeight(true); // 包含了margin
 *
 * scrollHeight
 * scrollHeight计算高度时，会累加上以自身为定位祖先元素的所有后代定位元素的可视高度
 *
 *
 * Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数
 * 一个元素的 scrollTop 值是这个元素的内容顶部（卷起来的）到它的视口可见内容（的顶部）的距离的度量。
 * 当一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为0
 *
 * 只想获取内容实际高度的
 * window.getComputeStyle(obj).height
 */
```

## TypeScript 使用部分

## 模块定义

```ts
/** 图片声明  */
// 声明 .scss和 .less文件declare module '*.scss' {
declare module '*.scss' {
  const content: { [key: string]: any };
  export default content;
}

declare module '*.less' {
  const content: { [key: string]: any };
  export default content;
}

// index.d.ts
declare module '*.svg';
declare module '*.png';
declare module '*.jpg';
declare module '*.jpeg';
declare module '*.gif';
declare module '*.bmp';
declare module '*.tiff';

// 使用namespace 声明一个库
// src/jQuery.d.ts
declare namespace jQuery {
  function ajax(url: string, settings?: any): void;
  const version: number;
  class Event {
    blur(eventType: EventType): void;
  }
  enum EventType {
    CustomClick,
  }
}

// 声明不按照模块化写的文件
declare module 'mobx-react-form';
```

## 导入

```ts
/**
 * 第一种导入commonjs模块的方式
 */
// 整体导入
const foo = require('foo');
// 单个导入
const bar = require('foo').bar;

/**
 * 第二种方式是 import ... from，注意针对整体导出，需要使用 import * as 来导入
 */
// 整体导入 export导出的内容组合成一个对象返回
import * as foo from 'foo';
// 单个导入
import { bar } from 'foo';
// 导入默认导出对象
import far from 'foo';

/* 第三种方式是 import ... require，这也是 ts 官方推荐的方式 */
// 整体导入
import foo = require('foo');
// 单个导入
import bar = foo.bar;

/** 通过配置tsconfig.json文件后引入  */
"allowSyntheticDefaultImports": true

import moment from 'moment';
```

### ts enum 枚举类

```ts
// 默认从0递增,也可以手动赋值的枚举项可以不是数字
enum Days {
  Sun,
  Mon,
  Tue,
  Wed,
  Thu,
  Fri,
  Sat,
}

console.log(Days['Sun'] === 0); // true
console.log(Days['Mon'] === 1); // true
console.log(Days['Tue'] === 2); // true
console.log(Days['Sat'] === 6); // true

console.log(Days[0] === 'Sun'); // true
console.log(Days[1] === 'Mon'); // true
console.log(Days[2] === 'Tue'); // true
console.log(Days[6] === 'Sat'); // true
```

### 命名空间 namespace

```ts
/**
 * “内部模块” 现在称作 “命名空间”，“外部模块”现在则简称为“模块”，
 */
namespace Validator {
  export interface StringValidator {
    isAcceptable(s: string): boolean;
  }

  const lettersRegexp = /^[A-Za-z]+$/;
  const numberRegexp = /^[0-9]+$/;

  export class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
      return lettersRegexp.test(s);
    }
  }

  export class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
      return lettersRegexp.test(s);
    }
  }
}

// 测试

let strings = ['Hello', '89772', '1230'];

let validators: { [s: string]: Validator.StringValidator } = {};

validators['ZIP code'] = new Validator.ZipCodeValidator();
validators['Letters Only'] = new Validator.LettersOnlyValidator();

for (let s of string) {
  for (let name in validators) {
    console.log(`"${s}" - ${validators[name].isAcceptable(s) ? 'matches' : 'does not match'} ${name}`);
  }
}
```

### Promise 的使用

```ts
/**
 * 基本使用
 */

// 创建一个Promise对象
const promise = new Promise((resolve, reject) => {
  // do something here ...
  if (success) {
    resolve(value); // fulfilled
  } else {
    reject(error); // rejected
  }
});

// 通过then方法，分别指定resolved状态和rejected状态的回调函数
promise.then(
  function (value) {
    // success
  },
  function (error) {
    // failure
  }
);

/**
 * 创建一个Promise对象的方法
 */

// 1.Promise.resolve(value)
// 普通数据：[String|Array|Object|Number] 最终结果并返回一个新的Promise
let p = Promsie.resolve(123);
p.then(function (num) {
  console.log(num);
});

/**
 * 错误的捕获
 * 荐使用catch方法，不要在then方法中定义rejected状态的回调函数；这是因为使用catch还可以捕获在then方法执行中存在的错误。
 */
promise
  .then(function (data) {
    // success
  })
  .catch(function (err) {
    // error
  });

/**
 * Promise.prototype. finally()
 * 无论结果如何都要进行的操作
 */
p.finally(onFinally);

p.finally(function () {});

/**
 * Promise.all(iterable)
 * 批量执行多个Promise
 * 传入的参数中存在不是Promise实例，则会先调用Promise.resolve，将其转为Promise实例，再进一步处理
 * 传入的参数中任意一个promise返回失败时，那么整体立即返回失败，返回的错误信息是第一个失败的promise结果。
 */

var p1 = Promise.resolve(3);
var p2 = 1337;
var p3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});

Promise.all([p1, p2, p3]).then(values => {
  console.log(values);
});

//  [3, 1337, "foo"]

/**
 * Promise. race(iterable)
 * 因此返回的新实例状态，是跟随参数中最先改变状态的那个实例(返回最先完成的那个Promise)
 */
var promise1 = new Promise(function (resolve, reject) {
  setTimeout(resolve, 500, 'one-resolve-500');
});

var promise2 = new Promise(function (resolve, reject) {
  setTimeout(reject, 400, 'two-reject-400');
});

Promise.race([promise1, promise2]).then(
  function (value) {
    console.log(value);
  },
  function (err) {
    console.log(err);
  }
);

// two-reject-400
```

### 装饰器的编写及使用

## react

### React 组件的默认状态（defaultProps）

```tsx
/**
 * defaultProps 可以为 Class 组件添加默认 props。
 * 可以通过静态属性来实现
 */
class List extends Component<any, any> {
  static defaultProps = {
    name: 'listing',
    action: 'action',
  };
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <React.Fragment>
        <div>我是list组件{this.props.name}</div>
        <div>我是list组件{this.props.action}</div>
      </React.Fragment>
    );
  }
}
```

## PureComponent, Component 的区别

```ts
/**
 * Component 的默认行为是不论 state 和 props 是否有变化，都触发 render
 * PureComponent nder。而 PureComponent 会先对 state 和 props 进行浅比较，不同的时候才会 render
 */
import React, { PureComponent, Component } from 'react';

class PureCom extends PureComponent<any, any> {
  constructor(props) {
    super(props);
  }

  render() {
    const { person } = this.props;
    return (
      <React.Fragment>
        <div>这是一个pure组件{person.name}</div>
      </React.Fragment>
    );
  }
}

export default PureCom;
```

### 条件渲染

```tsx
// 条件渲染方式1
if (isLoggedIn) {
  return <UserGreeting />;
}
  return <GuestGreeting />;
}

// 使用逻辑 && 操作符的内联 if 用法
return (
    <div>
      <h1>Hello!</h1>
      {unreadMessages.length > 0 &&
        <h2>
          You have {unreadMessages.length} unread messages.
        </h2>
      }
    </div>
  );

// 三目运算符的使用
return (
    <div>
      {isLoggedIn ? (
        <LogoutButton onClick={this.handleLogoutClick} />
      ) : (
        <LoginButton onClick={this.handleLoginClick} />
      )}
    </div>
  );

// return null 以阻止组件渲染
// 从组件的 render 方法返回 null 不会影响组件生命周期方法的触发。
// 例如， componentWillUpdate 和 componentDidUpdate 仍将被调用。
function WarningBanner(props) {
  if (!props.warn) {
    return null;
  }

  return (
    <div className="warning">
      Warning!
    </div>
  );
}

```

## 列表渲染 循环

```tsx
function Son(props: any) {
  const list = [
    { id: 1, name: 'name1' },
    { id: 2, name: 'name2' },
    { id: 3, name: 'name3' },
    { id: 4, name: 'name4' },
  ];

  return (
    <div>
      <ul>
        {list.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

### 表单与受控组件-双向绑定

- 常用表单元素

```tsx
<input type="text" value={this.state.value} onChange={this.handleChange} />
<textarea value={this.state.value} onChange={this.handleChange} />
<select value={this.state.value} onChange={this.handleChange}>
  <option value="grapefruit"></option>
  <option value="lime">酸橙</option>
  <option value="coconut">椰子</option>
  <option value="mango">芒果</option>
</select>

```

- 通过 state 实现表单的双向数据绑定

```tsx
import React from 'react';
type Person = {
  isBoy?: boolean;
  name?: string;
  age?: number;
};

class Son extends React.Component<any, Person> {
  constructor(props) {
    super(props);
    this.state = {
      isBoy: false,
      name: '小明',
      age: 18,
    };
  }

  handleInputChange = (event: React.FormEvent<HTMLInputElement>) => {
    const checkInputs = ['isBoy'];
    const target = event.currentTarget;
    const value = checkInputs.includes(target.name) ? target.checked : target.value;
    const name = target.name;

    this.setState({
      [name]: value,
    });
  };

  render() {
    return (
      <form>
        <p>
          name:{this.state.name} age:{this.state.age} checkisboy:
          {String(this.state.isBoy)}
        </p>
        <label>
          参与：
          <input name="isBoy" type="checkbox" checked={this.state.isBoy} onChange={this.handleInputChange} />
        </label>
        <label>
          姓名：
          <input name="name" type="text" value={this.state.name} onChange={this.handleInputChange} />
        </label>
        <label>
          年龄：
          <input name="age" type="number" value={this.state.age} onChange={this.handleInputChange} />
        </label>
      </form>
    );
  }
}
export default Son;
```

- 通过 useState 实现表单控件的数据双向绑定

```tsx
import React, { useState, useEffect } from 'react';
import _ from 'lodash';

type Person = {
  ischeck?: boolean;
  name?: string;
  age?: number | string;
};

const initFlag: Person = {
  ischeck: true,
  name: 'xiaomin',
  age: 10,
};

function Son(props) {
  const [flag, setFlag] = useState(Object.assign({}, initFlag));

  const handelInputChange = (event: React.FormEvent<HTMLInputElement>) => {
    const checks = ['ischeck'];
    const target = event.currentTarget;
    const name = target.name;
    const value = checks.includes(name) ? target.checked : target.value;
    console.log('value', value, typeof value);
    initFlag[name] = value;
    setFlag(_.assignIn({}, initFlag));
  };

  useEffect(() => {
    console.log('flag改变了', flag);
  });

  return (
    <div>
      <p>{String(flag.ischeck)}</p>
      <p>{String(flag.name)}</p>
      <p>{String(flag.age)}</p>
      <label>
        是否可选：
        <input type="checkbox" checked={flag.ischeck} name="ischeck" onChange={handelInputChange} />
      </label>
      <label>
        姓名：
        <input type="text" value={flag.name} name="name" onChange={handelInputChange} />
      </label>
      <label>
        年龄：
        <input type="number" value={flag.age} name="age" onChange={handelInputChange} />
      </label>
    </div>
  );
}

export default Son;
```

### 关于 React 表单类操作

```tsx

```

### React-classnames 库的使用

```bash
# 解决了原生动态添加多个className会报错的问题

# 安装
npm install classnames --save

# 基本使用
import classnames from 'classnames'

<div className=classnames({
    'class1': true,
    'class2': true
    )>
</div>

# 推荐写法
classnames('foo', { bar: true }); // => 'foo bar'

# 加入动态class
let buttonType = 'primary';
classnames({ [`btn-${buttonType}`]: true });

```

## input 键盘事件触发

```tsx
class Grandson extends React.Component<any, any> {
  constructor(props) {
    super(props);
    this.state = {};
  }

  inputKeyUp = (event: React.KeyboardEvent<HTMLInputElement>) => {
    if (event.keyCode === 13) {
      console.log('触发了回车按钮……');
      event.currentTarget.blur();
    }
  };

  render() {
    return (
      <React.Fragment>
        <input type="text" onKeyUp={this.inputKeyUp} />
      </React.Fragment>
    );
  }
}
```

### react Html 格式输出 dangerouslySetInnerHTML

```tsx
<ul>
  {this.state.list.map((item, index) => {
    return <li key={index + item} onClick={this.deleteItem.bind(this, index)} dangerouslySetInnerHTML={{ __html: item }}></li>;
  })}
</ul>
```

### label 中使用 htmlFor

```tsx
<div>
  <label htmlFor="jspang">加入服务：</label>
  <input id="jspang" className="input" value={this.state.inputValue} onChange={this.inputChange.bind(this)} />
  <button onClick={this.addList.bind(this)}> 增加服务 </button>
</div>
```

### 快速生成代码片段

```ts
/* Simple React Snippets 插件安装 */
```

### React developer tools 调试工具

```bash
## 下载chrome插件下载伴侣
## 下载对应的插件进行安装
```

### PropTypes 的使用

```ts
import React, { Component } from 'react'; //imrc
import PropTypes from 'prop-types';

class XiaojiejieItem extends Component {
  //cc

  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }

  render() {
    return <div onClick={this.handleClick}>{this.props.content}</div>;
  }

  handleClick() {
    this.props.deleteItem(this.props.index);
  }
}
//--------------主要代码--------start
XiaojiejieItem.propTypes = {
  content: PropTypes.string,
  deleteItem: PropTypes.func,
  index: PropTypes.number,
};
//--------------主要代码--------end
export default XiaojiejieItem;

/** 必填项配置  */
avname: PropTypes.string.isRequired;

/** 使用默认值  */
XiaojiejieItem.defaultProps = {
  avname: '松岛枫',
};
```

### ref 的使用

```tsx
/** 简单的使用案例  */
<input
    id="jspang"
    className="input"
    value={this.state.inputValue}
    onChange={this.inputChange.bind(this)}
    //关键代码——----------start
    ref={(input)=>{this.input=input}}
    //关键代码------------end
    />

inputChange(){
    this.setState({
        inputValue:this.input.value
    })
}

/** setState是异步的,通过第二个参数(一个回调函数) 实现数据更新 */

<ul ref={(ul)=>{this.ul=ul}}>
    {
        this.state.list.map((item,index)=>{
            return (
                <XiaojiejieItem
                key={index+item}
                content={item}
                index={index}
                deleteItem={this.deleteItem.bind(this)}
                />
            )
        })
    }
</ul>

addList(){
    this.setState({
        list:[...this.state.list,this.state.inputValue],
        inputValue:''
        //关键代码--------------start
    },()=>{
        console.log(this.ul.querySelectorAll('div').length)
    })
    //关键代码--------------end
}


```

### 关于 react 的生命周期

```tsx
/**
 * 1.Initialization:初始化阶段。
 * constructor不算生命周期函数
 * 看成React的Initialization阶段，定义属性（props）和状态(state)。
 *
 *
 *
 * 2.Mounting: 挂在阶段。
 * componentWillMount: 在组件即将被挂载到页面的时刻执行。
 * render: 页面state或props发生变化时执行。
 * componentDidMount: 组件挂载完成时被执行。

 * 3.Updation: 更新阶段。
 * shouldComponentUpdate函数会在组件更新之前，自动被执行。
 * 返回true，就同意组件更新;返回false,就反对组件更新
 *
 * componentWillUpdate在组件更新之前，但shouldComponenUpdate之后被执行。
 * componentDidUpdate在组件更新之后执行，它是组件更新的最后一个环节。
 *
 * 1-shouldComponentUpdate---组件发生改变前执行
   2-componentWillUpdate---组件更新前，shouldComponentUpdate函数之后执行
   3-render----开始挂载渲染
   4-componentDidUpdate----组件更新之后执行
 *
 *
 * componentWillReceiveProps
 * 子组件接收到父组件传递过来的参数，父组件render函数重新被执行，这个生命周期就会被执行。
 *
 *
 *
 * 4.Unmounting: 销毁阶段
 * componentWillUnmount函数
 */

/**
 * 生命周期改善程序性能示例
 *
 * 存在问题描述: 频繁无用渲染render,例如父组件的某个state发生更新的时候
 *
 * 可以通过使用shouldComponentUpdate来解决这个问题
 * nextProps:变化后的属性;
 * nextState:变化后的状态;
 */

shouldComponentUpdate(nextProps,nextState){
    if(nextProps.name !== this.props.name){
        return true
    }else{
        return false
    }
}
```

### 使用 EasyMock 模拟远程接口数据

```ts
/** EasyMock网站:www.easy-mock.com/  */
```

### React 动画组件 react-transition-group

```tsx
/**
 * react官方提供的动画过渡库，有着完善的API文档
 * 安装:
 * npm install react-transition-group -S
 * npm install @types/react-transition-group -S
 *
 * 相关的css样式类
 * xxx-enter: 进入（入场）前的CSS样式；
 * xxx-enter-active:进入动画直到完成时之前的CSS样式;
 * xxx-enter-done:进入完成时的CSS样式;
 * xxx-exit:退出（出场）前的CSS样式;
 * xxx-exit-active:退出动画知道完成时之前的的CSS样式。
 * xxx-exit-done:退出完成时的CSS样式。
 *
 * unmountOnExit 属性
 * 加上这个的意思是在元素退场时，自动把DOM也删除
 *
 */


import { CSSTransition } from 'react-transition-group'

render() {
    return (
        <div>
            <CSSTransition
                in={this.state.isShow}   //用于判断是否出现的状态
                timeout={2000}           //动画持续时间
                classNames="boss-text"   //className值，防止重复 要注意的是这个属性是classNames 后面是有s的
                unmountOnExit
            >
                <div>BOSS级人物-孙悟空</div>
            </CSSTransition>
            <div><button onClick={this.toToggole}>召唤Boss</button></div>
        </div>
        );
}

```

- react-transition-group css 文件示例

```css
.boss-text-enter {
  opacity: 0;
}
.boss-text-enter-active {
  opacity: 1;
  transition: opacity 2000ms;
}
.boss-text-enter-done {
  opacity: 1;
}
.boss-text-exit {
  opacity: 1;
}
.boss-text-exit-active {
  opacity: 0;
  transition: opacity 2000ms;
}
.boss-text-exit-done {
  opacity: 0;
}
```

- react-transition-group 多 DOM 动画制作和编写

```tsx
import { CSSTransition, TransitionGroup } from 'react-transition-group';

<ul
  ref={ul => {
    this.ul = ul;
  }}
>
  <TransitionGroup>
    {this.state.list.map((item, index) => {
      return (
        <CSSTransition timeout={1000} classNames="boss-text" unmountOnExit appear={true} key={index + item}>
          <XiaojiejieItem content={item} index={index} deleteItem={this.deleteItem.bind(this)} />
        </CSSTransition>
      );
    })}
  </TransitionGroup>
</ul>;
```

### react 常用 api

- React.Fragment

```tsx
/**
 * ReactDOM.createPortal(child, container)
 * 将提供一种将子节点渲染到 DOM 节点中的方式，该节点存在于 DOM 组件的层次结构之外。
 * 使用Portal使组件的挂载脱离父组件。例如：对话框，tooltip
 * 组件的挂载点虽然可以脱离父组件，但组件的事件通过冒泡机制仍可以传给父组件
 * 只要挂载的DOM存在于父组件中就可以了
 */
import React, { Component } from 'react';
import ReactDOM from 'react-dom';

class List extends Component<any> {
  constructor(props) {
    super(props);
    this.state = {};
  }
  render() {
    return (
      <div
        onClick={() => {
          console.log('list被点击了');
        }}
      >
        {ReactDOM.createPortal(
          <span
            onClick={() => {
              console.log('Portal被点击了');
            }}
          >
            11122
          </span>,
          document.querySelector('#app')
        )}
      </div>
    );
  }
}

export default List;
```

- React.Fragment

```tsx
/**
 * 将子元素列表添加到一个分组中，并且不会在DOM 中增加额外节点
 * key 是唯一可以传递给 Fragment 的属性
 */
return (
  <React.Fragment>
    <ChildA />
    <ChildB />
    <ChildC />
  </React.Fragment>
);
```

- React 克隆组件：React.cloneElement()

```ts
/**
 * 该方法以 element 作为起点，克隆并返回一个新的 React 元素。所产生的元素将具有原始元素的props ，新的 props 为浅层合并。
 * 新的子元素将取代现有的子元素， key 和 ref 将被保留。
 * React.cloneElement(element, [props], [...children]);
 *
 * 第一个参数为必选参数：TYPE（ReactElement）
 * 第二个参数为可选参数：[PROPS（object）]，
 * 第三个参数为可选参数：[CHILDREN（ReactElement）]
 */
```

- React 中 setState 更新 state

```tsx
/**
 * React中constructor是唯一可以初始化state的地方
 * 使用this.setState()更新状态
 */

// 方式1直接传入对象更新状态
// 由React控制的事件处理程序，以及生命周期函数调用setState不会同步更新state
// React控制之外的事件中调用setState是同步更新的。比如原生js绑定的事件，setTimeout/setInterval等。
// 多个setState调用会合并处理
show = () => {
  setTimeout(() => {
    this.setState({
      isshow: true,
    });
    console.log(this.state.isshow);
  }, 1000);
};

// 方式2使用函数产生更新
// 接收两个函数，第二个函数式设置成功后的回调函数
const change = (preState, props) => {
  console.log('state', preState);
  console.log('props', props);
  return {
    isshow: !preState.isshow,
  };
};
const callback = () => {
  console.log('状态已经改变', this.state);
};
this.setState(change, callback);
```

- 渲染属性的编程方式

```tsx
import React, { Component } from 'react';

class List extends Component<any, any> {
  constructor(props) {
    super(props);
    this.state = {
      isshow: false,
    };
  }

  show = () => {
    this.setState({
      isshow: !this.state.isshow,
    });
  };
  render() {
    return (
      <React.Fragment>
        <button onClick={this.show}>点击展示</button>
        {this.state.isshow ? <AnimalShow render={() => <Cat />} /> : <AnimalShow render={() => <Horse />} />}
      </React.Fragment>
    );
  }
}

class AnimalShow extends Component<any, any> {
  render() {
    return (
      <div>
        <h1>动物展示</h1>
        {this.props.render()}
      </div>
    );
  }
}

class Cat extends Component {
  render() {
    return <div>这是一只猫</div>;
  }
}

const Horse: React.FunctionComponent = () => {
  return <div>这是一只马</div>;
};

export default List;
```

- React.Component 与 React.PureComponent（React 之性能优化）

```tsx
/**
 * 继承PureComponent时，进行的是浅比较，也就是说，如果是引用类型的数据，
 * 当把之前和下一个的props和state作比较,数据的值没变则不更新UI,Component只要设置了state就会更新
 * 只会比较是不是同一个地址，而不会比较具体这个地址存的数据是否完全一致
 * React.memo 是一个高级组件. 它和React.PureComponent类似，只是在函数组件使用，而不是类组件
 */
import React, { Component, PureComponent, memo } from 'react';
```

- 组件生命周期

```tsx
/**
 * 挂载卸载过程
 */

// 组件第一次渲染完成，此时dom节点已经生成
componentDidMount();
// 在此处完成组件的卸载和数据的销毁
componentWillUnmount();

// 它代表的过程是组件已经经历了constructor()初始化数据后，但是还未渲染DOM时
componentWillMount();

/**
 * 更新过程
 */

// 组件会进入重新渲染的流程，在这里return false可以阻止组件的更新
shouldComponentUpdate(nextProps, nextState);

// 每次重新渲染后都会进入这个生命周期
componentDidUpdate(prevProps, prevState);
```

- 函数组件类型定义 React.FC 的使用

```tsx
import React from 'react';
import { Button } from 'antd';

interface Greeting {
  name: string;
  firstName?: string;
  lastName?: string;
}

// 没有使用React.FC
const HelloOld = (props: Greeting) => <Button>你好{props.name}</Button>;

// 使用React.FC泛型类型
const Hello: React.FC<Greeting> = props => {
  return <Button>Hello {props.name}</Button>;
};

export { Hello, HelloOld };
```

### React 的页面渲染更新机制

- 触发重新渲染的时机

```ts
/**
 * 1.state 和 mobx 触发的更新会重新渲染页面无论值是否和之前的一样
 * 2.使用hooks的函数式组件如果改变和前值一样则不会触发组件的重新渲染
 * 3.组件接收到新的props也会触发重新渲染
 * 4.如果组件的props发生了更新也会触发重新的渲染
 * 5.如果类组件写的子组件重新挂载则constructor会重新执行一遍
 */
```

- react 渲染的过程

```ts
/**
 * React整个的渲染机制就是React会调用render()函数构建一棵Dom树
 * 在state/props发生改变的时候，render()函数会被再次调用渲染出另外一棵树，重新渲染所有的节点，
 * 构造出新的虚拟Dom tree跟原来的Dom tree用Diff算法进行比较，找到需要更新的地方批量改动，
 * 再渲染到真实的DOM上，由于这样做就减少了对Dom的频繁操作，从而提升的性能。
 */
```

- react 的 Diff 算法

```ts
/**
 * 1.在React中，两棵DOM树只会对同一层的节点进行比较，若发现节点已不存在，则该节点及其子节点会被完全删除，不会用于进一步的比较
 * 这样，只需要对树进行一次遍历，就能完成整个DOM树的比较
 *
 * 2.对于同层节点，React在数组遍历的增减关键字Key,若节点本身完全相同(类型相同，属性相同)，只是位置不同，
 * 则React只需要考虑同层节点的位置变换，不需要进行节点的销毁和重新创建
 *
 * 3.对于不同层的节点，即使节点本身完全相同（类型相同且属性相同），也只能销毁和重新创建。
 */
```

### React 的 Context 的使用

```tsx
// 父组件List.txs
import React, { Component } from 'react';
import Son from './Son';

// 创建一个 Context,
export const { Provider, Consumer } = React.createContext({ name: '名称' });

class List extends Component<any, any> {
  contentData = {
    name: '共享名称',
  };
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <Provider value={this.contentData}>
        <Son />
      </Provider>
    );
  }
}

export default List;

// 子组件Son
import React from 'react';
import { Consumer } from './List';

function Son(props: any) {
  return (
    <Consumer>
      {contentData => (
        <div>
          <p>获取到List共享名称: {contentData.name}</p>
        </div>
      )}
    </Consumer>
  );
}

export default Son;
```

### ref 与 forwardRef 的使用

- 基本使用

```tsx
/**
 * 基本使用获取页面的dom节点元素
 */

const Grandson: React.FC = () => {
  const createRef = React.createRef<HTMLDivElement>();

  useEffect(() => {
    console.log(createRef.current.innerHTML);
  });

  return (
    <div>
      <div className="test" ref={createRef}>
        test内容
      </div>
    </div>
  );
};

/**
 * 基本使用
 * 转发”它给子组件
 */
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));

// 你可以直接获取 DOM button 的 ref：
const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;
```

- 在高阶组件中转发 refs

```tsx
function logProps(WrappedComponent) {
  class LogProps extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('old props:', prevProps);
      console.log('new props:', this.props);
    }

    render() {
      return <WrappedComponent {...this.props} />;
    }
  }

  return LogProps;
}
```

## React.memo

```ts
/**
 * 类似于PureComponnent 但它只对props进行浅比较
 */
```

## react 获取 dom 节点的方法

- 要引入 react 才可以用 dom 的方式定义变量

```ts
import React, { useState, useEffect } from 'react';

const div = <div>1234</div>;
```

- 通过 jquery 获取

```tsx
import React, { Component } from 'react';
import $ from 'jquery';

export default class Test extends Component {
  componentDidMount() {
    console.log('$(".test").text()', $('.test').text());
  }
  render() {
    return <div className="test">jQuery</div>;
  }
}
```

- 通过 ref 获取

```tsx
/**
 * 返回是具体的dom节点
 * ref可以挂载到组件上也可以是dom元素上
 * 挂到组件(class声明的组件)上的ref表示对组件实例的引用。
 * 不能在函数式组件上使用 ref 属性，因为它们没有实例：
 * ref 属性接受一个回调函数，它在组件被加载或卸载时会立即执行
 * ref 回调会在componentDidMount 或 componentDidUpdate 这些生命周期回调之前执行。
 */

import React from 'react';
import ReactDOM from 'react-dom';
import $ from 'jquery';

class Grandson extends React.Component<any, any> {
  createRef = React.createRef<HTMLParagraphElement>();

  // 通过回调获取的ref节点对象
  refCbObj = null;

  constructor(props) {
    super(props);
    this.state = {};
  }

  componentDidMount() {
    // ref属性，表示为对组件真正实例的引用
    const child = this.refs.child;
    // ReactDOM.findDOMNode(ref)来获取组件挂载后真正的dom节点
    const domNode = ReactDOM.findDOMNode(child);
    // 通过jquery把它包装成一个jquery对象
    const jqDomNode = $(domNode);
    // 可以直接使用jq的方法进行dom节点的操作
    console.log(jqDomNode.text());

    // 这样可以获取示例本身的dom节点 并进行相应操作
    const thisDOM = ReactDOM.findDOMNode(this);
    const adom = document.createElement('a');
    thisDOM.appendChild(adom);
    console.log('thisDOM', $(thisDOM).find('p').text());

    // 通过React.createRef挂载的元素可以直接使用innerHTML等原生Api
    console.log('createRef', this.createRef.current.innerHTML);

    // 通过回调获取
    const cbRef = ReactDOM.findDOMNode(this.refCbObj);
    console.log('cbRef.textContent', cbRef.textContent);
  }

  render() {
    return (
      <div className="i-div">
        <p ref="child">我是i-div-p00000</p>
        <p ref={this.createRef}>我是create</p>
        <p ref={ref => (this.refCbObj = ref)}>通过回调获取</p>
      </div>
    );
  }
}
```

### React 事件绑定

- 基本用法

```ts
function Son(props: any) {
  const buttonHandle = (e: React.MouseEvent) => {
    console.log(e.currentTarget.innerHTML);
  };
  const inputHandle = (e: React.FormEvent<HTMLInputElement>) => {
    console.log(e.currentTarget.value);
  };
  return (
    <>
      <input onChange={inputHandle} type="text" />
      <button onClick={buttonHandle}>Focus the input</button>
    </>
  );
}
```

### React Hook 的使用

Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。
Hook 不能在 class 组件中使用
只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。
只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用
还有一个地方可以调用 Hook —— 就是自定义的 Hook 中

- useState 的使用

```tsx
/**
 * useState 是允许你在 React 函数组件中添加 state 的 Hook
 */

import React, { useState, useEffect } from 'react';

function List(props: any) {
  // 声明一个新的叫做 “count” 的 state 变量 初始值设置为0
  const [count, setCount] = useState(0);
  const addClick = () => {
    setCount(count + 1); // 通过调用setCount取更新count的值
    // setCount(count => count + 2); 也可以使用函数式更新的方式
  };

  return (
    <div>
      <p>当前计算数值：{count}</p>
      <button onClick={addClick}>点击增加数值</button>
    </div>
  );
}
```

- useEffect 的使用

```tsx
/**
 * 默认情况下，React 会在每次渲染后调用useEffect —— 包括第一次渲染的时候
 * useEffect函数还可以通过返回一个函数来指定如何“清除”副作用
 * useEffect函数可以出现多次会分别执行
 * effect 的清除阶段在每次重新渲染时都会执行，而不是只在卸载组件的时候执行一次。
 * 此之外，请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 useEffect
 */
function List(props: any) {
  // 声明一个新的叫做 “count” 的 state 变量 初始值设置为0
  const [count, setCount] = useState(0);
  const addClick = () => {
    setCount(count + 1);
  };

  // 相当于 componentDidMount 和 componentDidUpdate:
  useEffect(() => {
    // 使用浏览器的 API 更新页面标题 会在count改变的时候去执行
    document.title = `${count}当前计算数值 `;
    return () => {
      console.log('每次state数据发生改变这里会先执行再执行上面的代码React 会在组件卸载的时候执行清除操作');
    };
  });

  // 传入第二个数组参数，指定只有在规定的字段发生变化的时候才触发函数的执行
  useEffect(() => {
    console.log('只有在count发生变化的情况下才会执行,如果第二个参数是空数组则仅在组件挂载和卸载时执行');
    return () => {
      console.log('执行清除操作！');
    };
  }, [count]);

  return (
    <div>
      <p>当前计算数值：{count}</p>
      <button onClick={addClick}>点击增加数值</button>
    </div>
  );
}
```

- 自定义 Hook

```tsx
/**
 * 果函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。
 * 自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。
 * 在两个组件中使用相同的 Hook 会不会共享 state ,保持独立，完全隔离
 */
function useStatusId(name) {
  const [id, setId] = useState(0);
  useEffect(() => {
    setId(name);
    console.log('自定义Hook执行了');
  });

  return id;
}
```

- useContext

```tsx
/**
 * 让你不使用组件嵌套就可以订阅 React 的 Context。
 * useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。
 * 你仍然需要在上层组件树中使用 <MyContext.Provider> 来为下层组件提供 context。
 */

// 在父组件中List.tsx
import React, { Component } from 'react';
import Son from './Son';

import './index.scss';

// 创建一个 Context,
export const ListContext = React.createContext({ name: '名称' });

class List extends Component<any, any> {
  contentData = {
    name: '共享名称',
  };
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <ListContext.Provider value={this.contentData}>
        <Son />
      </ListContext.Provider>
    );
  }
}
export default List;

// 在Son.tsx中
import React, { useContext } from 'react';
import { ListContext } from './List';

function Son(props: any) {
  // 获取上下文共享数据
  const context = useContext(ListContext);
  return <p>通过useContext获取到的共享数据：{context.name}</p>;
}

export default Son;
```

- useReducer

```tsx
/**
 * useState 的替代方案。它接收一个形如 (state, action) => newState 的 reducer，
 * 并返回当前的 state 以及与其配套的 dispatch 方法。
 */
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter(props: any) {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <div>
      Count: {state.count}
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
    </div>
  );
}

export default Son;

// 惰性初始化
// init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)
function init(initialCount) {
  return { count: initialCount };
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return init(action.payload);
    default:
      throw new Error();
  }
}

function Counter({ initialCount }) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    <>
      Count: {state.count}
      <button onClick={() => dispatch({ type: 'reset', payload: initialCount })}>Reset</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
    </>
  );
}
```

- useMemo

```tsx
/**
 * const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
 * 传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作
 * 会在某个依赖项改变时才重新计算 memoized 值
 * 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值
 */
```

- useCallback

```tsx
/**
 * useCallback(fn, deps) 相当于 useMemo(() => fn, deps)。
 * 把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本
 * 该回调函数仅在某个依赖项改变时才会更新
 */
```

- useRef

```tsx
/**
 * useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。
 * 返回的 ref 对象在组件的整个生命周期内保持不变。
 */

function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    // `current` 指向已挂载到 DOM
    inputEl.current.focus();
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Focus the input</button>
    </>
  );
}
```

- useImperativeHandle

```tsx
/**
 * useImperativeHandle(ref, createHandle, [deps])
 * useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值
 * useImperativeHandle 应当与 forwardRef 一起使用：
 */

// 渲染 <FancyInput ref={inputRef} /> 的父组件可以调用 inputRef.current.focus()。
function FancyInput(props, ref) {
  const inputRef = useRef();
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    }
  }));
  return <input ref={inputRef} ... />;
}
FancyInput = forwardRef(FancyInput);
```

- useLayoutEffect

```tsx
/**
 * 其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。
 * 尽可能使用标准的 useEffect 以避免阻塞视觉更新。
 */
```

## React 路由部分：react-router-dom 的使用

- BrowserRouter

```tsx
/**
 * BrowserRouter主要使用在浏览器中，也就是WEB应用中。
 */

// 1.basename 属性
// 设置运用根目录
<BrowserRouter basename="/admin"/>
    ...
    <Link to="/home"/> // 被渲染为 <a href="/admin/home">
    ...
</BrowserRouter>

// 2.getUserConfirmation: func
// 当导航需要确认的时候执行函数,默认使用 window.confirm
// 使用默认的确认函数
const getConfirmation = (message, callback) => {
  console.log('执行了默认确认函数……');
  const allowTransition = window.confirm(message);
  callback(allowTransition);
};

const yourCallBack = (ok) => {
  console.log('路由跳转成功了。');
};
<BrowserRouter getUserConfirmation={() => getConfirmation('确认跳转路由么', yourCallBack(true)) />

// 3.forceRefresh: bool
// 当设置为 true 时，在导航的过程中整个页面将会刷新。 只有当浏览器不支持 HTML5 的 history API 时，才设置为 true。
const supportsHistory = 'pushState' in window.history
<BrowserRouter forceRefresh={!supportsHistory}/>

// 4.keyLength: number
// location.key 的长度。默认是 6。
<BrowserRouter keyLength={12}/>
```

- 使用 HashRouter

```tsx
/**
 * 使用HashRouter - 这样路径就类似于这样http://localhost:3000/contact#/contact
 * 由于该技术仅用于支持传统的浏览器，因此在用于浏览器时可以使用 <BrowserHistory> 代替。
 * 使用 hash 的方式记录导航历史不支持 location.key 和location.state
 */

// ================ hashType ================
// hashType: string
// window.location.hash 使用的 hash 类型。有如下几种：

// "slash" - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops
// "noslash" - 后面没有斜杠，例如 # 和 #sunshine/lollipops
// "hashbang" - Google 风格的 "ajax crawlable"，例如 #!/ 和 #!/sunshine/lollipops
// 默认为 "slash"。
```

- Link 组件

```tsx
/**
 * Link就像是一个个的路牌，为我们指明组件的位置。
 * 定义的Link最终会被渲染成一个a标签。
 * Link使用to这个属性来指明目标组件的路径，可以直接使用一个字符串，也可以传入一个对象。
 */
import { Link } from 'react-router-dom'
// 字符串参数
<Link to="/query">查询</Link>

// 对象参数
<Link to={{
  pathname: '/query',
  search: '?key=name',
  hash: '#hash',
  state: { fromDashboard: true }
}}>查询</Link>

// ======= 属性： to 需要跳转到的路径(pathname)或地址（location）=======

// ======= 属性：replace: bool =======
// 当设置为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址。
// 当设置为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。
// 默认为 false
```

- NavLink 组件

```tsx
/**
 * 可以使用activeClassName来设置Link被选中时被附加的class
 * 使用activeStyle来配置被选中时应用的样式。
 * 有一个exact属性,此属性要求location完全匹配才会附加class和style
 *
  to 可以是字符串或者对象，同Link组件
  exact 布尔类型，完全匹配时才会被附件class和style
  activeStyle Object类型
  activeClassName 字符串类型
  strict: bool类型，当值为 true 时，在确定位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线。

 */

// 选中后被添加class selected
<NavLink to={'/'} exact activeClassName='selected'>Home</NavLink>
// 选中后被附加样式 color:red
<NavLink to={'/gallery'} activeStyle={{color:red}}>Gallery</NavLink>
```

- Route 组件

```tsx
/**
 * Route组件
 * 当location与Route的path匹配时渲染Route中的Component。
 * 如果有多个Route匹配，那么这些Route的Component都会被渲染。
 */

// ======= Route也有一个exact属性，作用也是要求location与Route的path绝对匹配 =======
// 当location形如 http://location/时，Home就会被渲染。
// 因为 "/" 会匹配所有的URL，所以这里设置一个exact来强制绝对匹配。
<Route exact path="/" component={Home}/>
<Route path="/about" component={About}/>


// ======= Route的三种渲染方式=======
// 1. component: 这是最常用也最容易理解的方式，给什么就渲染什么。
// 2. render: render的类型是function，Route会渲染这个function的返回值。
<Route path="/home" render={() => {
    console.log('额外的逻辑');
    return (<div>Home</div>);
    }/>
// 3.children: 这是最特殊的渲染方式
// 它会被传入一个match参数来告诉你这个Route的path和location匹配上没有
// 即使path没有匹配上，我们也可以将它渲染出来
// 我们可以根据这个参数来决定在匹配的时候渲染什么，不匹配的时候又渲染什么

// 在匹配时，容器的calss是light，<Home />会被渲染
// 在不匹配时，容器的calss是dark，<About />会被渲染
// <Route path='/home' children={({ match }) => (
//     <div className={match ? 'light' : 'dark'}>
//       {match ? <Home/>:<About>}
//     </div>
//   )} />


// ======= 所有路由中指定的组件将被传入以下三个 props =======
// 1.match.
<Link to='/p/1' />
<Link to='/p/2' />
<Link to='/p/3' />
......
<Route path='/p/:id' render={(match)=<h3>当前文章ID:{match.params.id}</h3>)} />
// 2.location.
// Location 是指你当前的位置，下一步打算去的位置，或是你之前所在的位置
// 在 Route component 中，以 this.props.location 的方式获取，
// 在 Route render 中，以 ({ location }) => () 的方式获取，
// 在 Route children 中，以 ({ location }) => () 的方式获取，
// 在 withRouter 中，以 this.props.location 的方式获取。

{
  key: 'ac3df4', // 在使用 hashHistory 时，没有 key
  pathname: '/somewhere'
  search: '?some=search-string',
  hash: '#howdy',
  state: {
    [userDefined]: true
  }
}
// location 对象不会发生改变，因此你可以在生命周期的钩子函数中使用 location 对象来查看当前页面的位置是否发生改变
componentWillReceiveProps(nextProps) {
  if (nextProps.location !== this.props.location) {
    // 已经跳转了！
  }
}

// 通常你只需要这样使用 location
<Link to="/somewhere"/>

// 但是你同样可以这么用
const location = {
  pathname: '/somewhere'
  state: { fromDashboard: true }
}

<Link to={location}/>
<Redirect to={location}/>
history.push(location)
history.replace(location)

// 你可以把 location 传入一下组件 [Route] [Switch]
// 可以让组件不使用路由状态（router state）中的真实 location，
// 因为我们有时候需要组件去渲染一个其他的 location 而不是本身所处的真实 location



// 3.history.
// History 是 React Router 的两大重要依赖之一（除去 React 本身）
// history.location 中获取 location 对象，但是别那么写，因为 history 是可变的
// 在不同的 Javascript 环境中，history 以多种形式实现了对于 session 历史的管理。

// ======= history 对象通常会具有以下属性和方法：=======

// length -（ number 类型）指的是 history 堆栈的数量。
// action -（ string 类型）指的是当前的动作（action），例如 PUSH，REPLACE 以及 POP 。
// location -（ object类型）是指当前的位置（location），location 会具有如下属性：
// pathname -（ string 类型）URL路径。
// search -（ string 类型）URL中的查询字符串（query string）。
// hash -（ string 类型）URL的 hash 分段。
// state -（ string 类型）是指 location 中的状态，例如在 push(path, state) 时，state会描述什么时候 location 被放置到堆栈中等信息。这个 state 只会出现在 browser history 和 memory history 的环境里。
// push(path, [state]) -（ function 类型）在 hisotry 堆栈顶加入一个新的条目。
// replace(path, [state]) -（ function 类型）替换在 history 堆栈中的当前条目。
// go(n) -（ function 类型）将 history 对战中的指针向前移动 n 。
// goBack() -（ function 类型）等同于 go(-1) 。
// goForward() -（ function 类型）等同于 go(1) 。
// block(prompt) -（ function 类型）阻止跳转，

// ======= match 对象包含了 <Route path> 如何与URL匹配的信息。match 对象包含以下属性：=======
// params -（ object 类型）即路径参数，通过解析URL中动态的部分获得的键值对。
// isExact - 当为 true 时，整个URL都需要匹配。
// path -（ string 类型）用来做匹配的路径格式。在需要嵌套 <Route> 的时候用到。
// url -（ string 类型）URL匹配的部分，在需要嵌套 <Link> 的时候会用到。

// 你可以在以下地方获取 match 对象：
// 在 Route component 中，以 this.props.match 方式。
// 在 Route render中，以 ({ match }) => () 方式。
// 在 Route children中，以 ({ match }) => () 方式

```

- Redirect 组件

```tsx
/**
 * 当这个组件被渲染是，location会被重写为Redirect的to指定的新location。
 * 必须放在需要重定向的页面前面
 */
<Redirect to="/new" />
```

- Switch 组件

```tsx
/**
 * 渲染匹配地址(location)的第一个 <Route>或者<Redirect>
 * <Switch>的独特之处是独它仅仅渲染一个路由。
 */
<Switch>
  <Route exact path="/" component={Home} />
  <Route path="/about" component={About} />
  <Route path="/:user" component={User} />
  <Route component={NoMatch} />
</Switch>
```

- 路由配置示例

```tsx
const routes = [
  {
    path: '/sandwiches',
    component: Sandwiches,
  },
  {
    path: '/tacos',
    component: Tacos,
    routes: [
      {
        path: '/tacos/bus',
        component: Bus,
      },
      {
        path: '/tacos/cart',
        component: Cart,
      },
    ],
  },
];
```

- 基本使用

```tsx
/**
 * 关于react-router-dom的组成
 * 1.react-router: 实现了路由的核心功能，而react-router-dom依赖react-router，
 * 2.react-router-dom: 基于react-router，加入了在浏览器运行环境下的一些功能：
 * Link组件，会渲染一个a标签；
 * BrowserRouter组件，使用pushState和popState事件构建路由；
 * HashRouter组件，使用window.location.hash和hashchange事件构建路由。
 *
 * 其他
 * react-router-native: 基于react-router，类似react-router-dom，加入了react-native运行环境下的一些功能。
 */

// BaseLayout.tsx

import React, { Component } from 'react';
import { BrowserRouter as Router, Route, Link, HashRouter, Redirect, Switch } from 'react-router-dom';

const HomePage = () => <div>首页</div>;
const LoginPage = () => <div>登录</div>;
const RegisterPage = () => <div>注册</div>;
const ProfilePage = () => <div>简介页面</div>;
const AboutPage = () => <div>关于我们</div>;
const ContactPage = () => <div>联系我们</div>;
const NotFound = () => <div>页面未找到</div>;

class BaseLayout extends React.Component<any, any> {
  constructor(props) {
    super(props);
    this.state = {};
  }

  render() {
    return (
      <div className="base">
        <header>
          <nav>
            <ul>
              {/* replace 属性用于解决 Warning: Hash history cannot PUSH the same path*/}
              <li>
                <Link to="/" replace>
                  首页
                </Link>
              </li>
              <li>
                <Link to="/about" replace>
                  关于我们
                </Link>
              </li>
              <li>
                <Link to="/me" replace>
                  简介页面
                </Link>
              </li>
              <li>
                <Link to="/login" replace>
                  登录
                </Link>
              </li>
              <li>
                <Link to="/register" replace>
                  注册
                </Link>
              </li>
              <li>
                <Link to="/contact" replace>
                  联系我们
                </Link>
              </li>
            </ul>
          </nav>
        </header>
        <div className="container">
          <Switch>
            {/* exact 指定路由为排他路由 v4默认路由为非排他路由 */}
            <Route path="/" exact component={HomePage} />
            <Route path="/about" component={AboutPage} />
            <Route path="/contact" component={ContactPage} />
            <Route path="/login" component={LoginPage} />
            <Route path="/register" component={RegisterPage} />
            {/** 必须放在需要重定向的页面前面  */}
            <Redirect to="/register" />
            <Route path="/me" component={ProfilePage} />
            <Route component={NotFound} />
          </Switch>
        </div>
      </div>
    );
  }
}

export default BaseLayout;

// - 使用HashRouter - 这样路径就类似于这样http://localhost:3000/contact#/contact
import React, { Component } from 'react';
import { BrowserRouter as Router, Route, Link, HashRouter } from 'react-router-dom';
import BaseLayout from './pages/BaseLayout';
import './App.css';

class App extends Component {
  render() {
    return (
      <HashRouter>
        <BaseLayout />
      </HashRouter>
    );
  }
}
export default App;
```

- Route 的参数

```tsx
/**
 * 第一种传参方式；通过params
 */

// 在路由组件中获取参数 props里面包含了location history match staticContext等参数
const AboutPage = (props) => {
  console.log('match', props.match);
  console.log('props.match.params', props.match.params);
  return <div>关于我们</div>;
};

// 设置切换路由传递参数的key
<Route path="/about/:name" component={AboutPage} />;

// 在指定界面跳转到路由传递过去的参数值
<Link to="/about/2" replace>
  关于我们
</Link>;

/** 第二种传参方式  */

const AboutPage = (props) => {
  console.log('location', props.location.state);
  return <div>关于我们</div>;
};

// 在指定界面跳转到路由传递过去的参数值
<Link
  to={{
    pathname: '/about',
    state: { name: 'sunny', age: 18 },
  }}
>
<Route path="/about" component={AboutPage} />
```

## mobx 的使用

```tsx
/**
 * 创建ListStore状态
 */
import { observable, action } from 'mobx';
class ListStore {
  @observable listNum = 1;
  @action addNum() {
    this.listNum += 1;
  }
  @action lessNum() {
    this.listNum -= 1;
  }
}
export default ListStore;

/** 实例化ListStore状态  */
import ListStore from './listStore';
import AboutStore from './aboutStore';
let listStore = new ListStore();
let aboutStore = new AboutStore();
const stores = {
  listStore,
  aboutStore,
};
// 默认导出接口
export default stores;

/** 在index中引入  */
import React from 'react';
import ReactDOM from 'react-dom';
// 导入根组件
import App from './App';
import { Provider } from 'mobx-react';
import stores from './store';
import './index.scss';
// 在root元素上渲染根组件
ReactDOM.render(
  <Provider {...stores}>
    <App />
  </Provider>,
  document.getElementById('root')
);

/**
 * 在函数组件中使用Mobx
 */
import React from 'react';
import { observer, inject } from 'mobx-react';

// 注入全局存储对象listStore 并包装为响应式函数组件
// 只要listStore 中的值发生变化 就会触发界面重新刷新
const Son = inject('listStore')(
  observer(props => {
    const clickChang = e => {
      props.listStore.addNum();
      console.log('改变状态值', props.listStore.listNum);
    };
    return (
      <div>
        <p>listNum:{props.listStore.listNum}</p>
        <button onClick={clickChang}>改变状态值</button>
      </div>
    );
  })
);

export default Son;
```

## lodash

```tsx
// 1.返回新的去重后的数组。
_.uniq([2, 1, 2]);

// 2.深拷贝
var objects = [{ a: 1 }, { b: 2 }];
var deep = _.cloneDeep(objects);
console.log(deep[0] === objects[0]);
// => false

// 3.深拷贝 还会拷贝原型链上的属性和方法
function Foo() {
  this.a = 1;
}

function Bar() {
  this.c = 3;
}

Foo.prototype.b = 2;
Bar.prototype.d = 4;

_.assignIn({ a: 0 }, new Foo(), new Bar());
// => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }

// 4._.isNil(value)
// 如果 value 为null 或 undefined，那么返回 true，否则返回 false。
_.isNil(null);
// => true

_.isNil(void 0);
// => true

_.isNil(NaN);
// => false
```

- 过滤重复项目

```ts
_.uniq([2, 1, 2]); // => [2, 1]
_.uniqBy([{ x: 1 }, { x: 2 }, { x: 1 }], 'x'); // => [{ 'x': 1 }, { 'x': 2 }]

var objects = [
  { x: 1, y: 2 },
  { x: 2, y: 1 },
  { x: 1, y: 2 },
];
_.uniqWith(objects, _.isEqual);
// => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
```

- 根据某个字段对 json 对象进行分组

```ts
// 会返回一个聚合的对象key是分组字段的值

_.groupBy(['one', 'two', 'three'], 'length');
// => { '3': ['one', 'two'], '5': ['three'] }

let a = [
  { id: 1, name: 'me' },
  { id: 1, name: 'you' },
  { id: 2, name: 'her' },
];
_.groupBy(a, 'id'); //就可以实现按id分组了。
```

- \_.orderBy 排序 指定字段和指定排列顺序

```ts
var users = [
  { user: 'fred', age: 48 },
  { user: 'barney', age: 34 },
  { user: 'fred', age: 40 },
  { user: 'barney', age: 36 },
];

// 以 `user` 升序排序 再  `age` 以降序排序。
_.orderBy(users, ['user', 'age'], ['asc', 'desc']);
// => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
```

- 比较最大值

```ts
var objects = [{ n: 1 }, { n: 2 }];

_.maxBy(objects, function (o) {
  return o.n;
});
// => { 'n': 2 }

_.max([4, 2, 8, 6]);
// => 8
```

- throttle（节流）

```ts
/* 
预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新的时间周期。
简言之：结束时间点不会随点击改变 
*/

testThrottle = _.throttle(
  () => {
    console.log('节流函数被触发了1');
  },
  1000,
  {
    leading: true, // 调用节流开始前执行
    trailing: true, // 调用节流开始后执行 leading 和 trailing 都设置为true则只会执行一次(节流开始前执行)
  }
);

btnClick = () => {
  this.testThrottle();
};
```

- debounce（防抖）

```ts
/**
 * 当调用动作触发一段时间后，才会执行该动作，若在这段时间间隔内又调用此动作则将重新计算时间间隔
 * 简言之：结束时间点会随点击改变
 */
testDebounce = _.debounce(
  () => {
    console.log('防抖函数执行了');
  },
  2000,
  {
    maxWait: 3000, // 允许被延迟的最大值
    leading: false, // 设置 func 允许被延迟的最大值
    trailing: true, // 指定在延迟结束后调用，默认true
  }
);

btnClick = () => {
  this.testDebounce();
};
```

- isEmpty(value) 判断是否为空对象

```ts
/**
 * 检查 value 是否为一个空对象，集合，映射或者set。 判断的依据是除非是有枚举属性的对象，length 大于 0 的 arguments object, array, string 或类jquery选择器。
 * 类数组值，比如arguments对象，array，buffer，string或者类jQuery集合的length 为 0，
 * 被认为是空。类似的，map（映射）和set 的size 为 0，被认为是空。
 *
 * 返回值:(boolean): 如果 value 为空，那么返回 true，否则返回 false。
 */

_.isEmpty(null);
// => true

_.isEmpty(true);
// => true

_.isEmpty(1);
// => true

_.isEmpty([1, 2, 3]);
// => false

_.isEmpty({ a: 1 });
// => false
```

\_.mapValues

```ts
/**
 * 创建一个对象，这个对象的key与object对象相同，值是通过 iteratee 运行 object 中每个自身可枚举属性名字符串产生的。
 * iteratee调用三个参数： (value, key, object)。
 */

var users = {
  fred: { user: 'fred', age: 40 },
  pebbles: { user: 'pebbles', age: 1 },
};

_.mapValues(users, function (o) {
  return o.age;
});
// => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)

// The `_.property` iteratee shorthand.
_.mapValues(users, 'age');
// => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
```

\_.get

```ts
/**
 * 根据 object对象的path路径获取值。 如果解析 value 是 undefined 会以 defaultValue 取代
 */
var object = { a: [{ b: { c: 3 } }] };

_.get(object, 'a[0].b.c');
// => 3

_.get(object, ['a', '0', 'b', 'c']);
// => 3

_.get(object, 'a.b.c', 'default');
// => 'default'
```

- \_.curry 函数柯里化

```tsx
/**
 * 使用场景1
 */
// 定一个一个函数它接收3个参数并有一个返回值
function simpleURL(protocol, domain, path) {
  return protocol + '://' + domain + '/' + path;
}

// _.curry函数柯里化
// 1.如果接收所有的参数则直接返回结果
// 2.如果接收一部分参数，则返回一个函数接收剩余的参数

let myURL1 = _.curry(simpleURL)('https', 'mysite');
let res1 = myURL1('home.html'); //
console.log(res1); //https://mysite/home.html

/**
 * 使用场景2：获取json对象中的指定字段
 */
var persons = [
  { name: 'kevin', age: 11 },
  { name: 'daisy', age: 24 },
];

let getProp = _.curry(function (key, obj) {
  return obj[key];
});
let names2 = persons.map(getProp('name'));
console.log(names2); //['kevin', 'daisy']

let ages2 = persons.map(getProp('age'));
console.log(ages2); //[11,24]

/**
 * 也可以添加占位符号
 */
var abc = function (a, b, c) {
  return [a, b, c];
};

var curried = _.curry(abc);

curried(1)(2)(3);
// => [1, 2, 3]

curried(1, 2)(3);
// => [1, 2, 3]

curried(1, 2, 3);
// => [1, 2, 3]

// Curried with placeholders.
curried(1)(_, 3)(2);
// => [1, 2, 3]
```

- \_.curryRight 函数柯里化从右边开始接收参数

```tsx
/**
 * 使用同curryRight 只不过它是从右边开始接收参数
 */

var abc = function (a, b, c) {
  return [a, b, c];
};

var curried = _.curryRight(abc);

curried(3)(2)(1);
// => [1, 2, 3]

curried(2, 3)(1);
// => [1, 2, 3]

curried(1, 2, 3);
// => [1, 2, 3]

// Curried with placeholders.
curried(3)(1, _)(2);
// => [1, 2, 3]
```

- \_.map 取对象中的某个字段值并组合成数组

```ts
function square(n) {
  return n * n;
}

_.map([4, 8], square);
// => [16, 64]

_.map({ a: 4, b: 8 }, square);
// => [16, 64] (iteration order is not guaranteed)

var users = [{ user: 'barney' }, { user: 'fred' }];

// The `_.property` iteratee shorthand.
_.map(users, 'user');
// => ['barney', 'fred']
```

- 数组分组

```ts
// 将数组（array）拆分成多个 size 长度的区块，并将这些区块组成一个新数组。
_.chunk(['a', 'b', 'c', 'd'], 2);
// => [['a', 'b'], ['c', 'd']]

_.chunk(['a', 'b', 'c', 'd'], 3);
// => [['a', 'b', 'c'], ['d']]
```

## 日期格式控件 moment 的使用

## css 效果

- 对号复选框的实现

```scss
/* 自定义对号选中框 */
.custom-check-mark {
  width: 300px;
  height: 300px;
  border: 1px solid #f00;
  padding: 20px;

  label {
    display: block;
    width: 50px;
    height: 50px;
    position: relative;
    cursor: pointer;
    &::before {
      content: '';
      display: block;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      background-color: #171528;
      border: 1px solid #171528;
      transition: all 0.3s ease;
    }

    &::after {
      content: '✓'; //  url(./img/svg/check_mark.svg);
      position: absolute;
      display: flex;
      justify-content: center;
      align-items: center;
      top: 50%;
      left: 50%;
      margin-top: -25px;
      margin-left: -25px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: #589afb;
      transition: all 0.3s ease;
      color: #171528;
      font-size: 30px;
      font-weight: bolder;
      opacity: 0;
    }
  }
  input {
    display: none;

    &:checked + label:before {
      opacity: 0;
    }
    &:checked + label:after {
      opacity: 1;
    }
  }
}
```

- switch 开关效果的实现

```scss
/**
 * :checked 选择器匹配每个已被选中的 input 元素（只用于单选按钮和复选框）
 * E>F 子选择器 匹配E元素下的所有F元素
 * E+F 相邻兄弟选择器 匹配紧邻E元素后面的第一个F元素
 * E~F 通用选择器 匹配紧邻E元素后面的所有F元素
 */

<div > <input id='checked_1' type='checkbox' className='switch' / > <label htmlFor='checked_1' > </label > </div > label {
  position: relative;
  display: block;
  border-radius: 24px;
  width: 40px;
  padding: 5px;
  background-color: #eee;
  cursor: pointer;
  border: 1px solid #f00;

  &::before {
    content: '';
    display: block;
    border-radius: 24px;
    height: 22px;
    background-color: white;
    transition: all 0.3s ease;
  }

  &::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    margin-top: -11px;
    margin-left: -11px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background-color: white;
    transform: translateX(-9px);
    transition: all 0.3s ease;
    border: 1px solid #333;
  }
}

.switch {
  display: none;
  &:checked + label:after {
    transform: translateX(9px);
  }
  &:checked + label:before {
    background-color: green;
  }
}
```

## CSS3 相关

- CSS3 中的原生变量 var 详解

```css
:root {
  --main-bg-color: pink;
}

body {
  background-color: var(--main-bg-color);
}

.element {
  width: 200px;
  height: 200px;
  --main-bg-color: #000;
  color: #fff;
  background-color: var(--main-bg-color);
}
```

- image-set()

```css
/**
  可以让不同屏幕密度设备加载不同的图片资源
  */
.mask-image {
  width: 250px;
  height: 187.5px;
  -webkit-mask-image: -webkit-image-set(url(loading.png) 1x, url(star.svg) 2x);
  mask-image: image-set(url(loading.png) 1x, url(star.svg) 2x);
}
```

- cross-fade()功能符

```css
/* 
  cross-fade中的透明度值是只作用于后面一张图片上！
  表示含义是star.svg这张图片保持为50%透明度
 */
.mask-image {
  width: 250px;
  height: 187.5px;
  -webkit-mask-image: -webkit-cross-fade(url(loading.png), url(star.svg), 50%);
  mask-image: cross-fade(url(loading.png), url(star.svg), 50%);
}
```

- element()功能符资源

```css
/**
  element()功能符可以让页面上的DOM元素作为图片显示
  */
div {
  background: -moz-element(#button);
}
```

- mask 遮罩属性的使用(可以控制 svg 的颜色)

```css
/**
 所谓遮罩，就是原始图片只显示遮罩图片非透明的部分
 如果遮罩图片加载失败则原图不会展示出来
 支持svg图片和png图片

*/

/* <div className="mask-image"></div> */
.mask-image {
  background: #ff0000;
  width: 250px;
  height: 187.5px;
  mask-image: url(../src/img/svg/check_mark.svg);
}

/* mask-mode属性 目前，mask-mode仅Firefox浏览器支持
mask-mode属性的默认值是match-source，意思是根据资源的类型自动采用合适的遮罩模式
luminance，表示基于亮度遮罩
alpha，表示基于透明度遮罩
match-source，意思是根据资源的类型自动采用合适的遮罩模式

mask-image支持多图片，因此mask-mode也支持多属性值
mask-mode: alpha, match-source;
*/

/** mask-repeat
  mask-repeat属性的默认值是repeat，行为类似于background-repeat属性
  round表示遮罩图片尽可能靠在一起没有任何间隙，同时不发生任何剪裁。这就意味着图片可能会有比例的缩放
  space，表示遮罩图片尽可能的平铺同时不发生任何剪裁
  */

/** mask-position
mask-position: top;
mask-position: bottom;
mask-position: left;
mask-position: right;
mask-position: center;

支持垂直和水平方向两个关键字：
mask-position: right top;

支持各类数值：
mask-position: 30% 50%;
mask-position: 10px 5rem;

mask-position也支持多属性值
mask-position: 0 0, center;

*/

/** mask-clip
mask-clip: content-box;
mask-clip: padding-box;
mask-clip: border-box;
mask-clip: fill-box;
mask-clip: stroke-box;
mask-clip: view-box;
mask-clip: no-clip;
  */

/** mask-origin
mask-origin: content-box;
mask-origin: padding-box;
mask-origin: border-box;
mask-origin: fill-box;
mask-origin: stroke-box;
mask-origin: view-box;

支持多属性值
mask-origin: content-box, border-box;
  */

/** mask-size
mask-size: cover;
mask-size: contain;

mask-size: 50% auto;
mask-size: 3em 25%;
mask-size: auto 6px;

同样支持多属性值：
mask-size: 50%, 25%, 25%;
mask-size: 6px, auto, contain;
  */

/** mask-composite表示当同时使用多个图片进行遮罩时候的混合方式
mask-composite: add;
mask-composite: subtract;
mask-composite: intersect;
mask-composite: exclude;
  */

/** 最终推荐使用代码  */
/* <div className="mask-image"></div> */
.mask-image {
  background: #ff0000;
  width: 250px;
  height: 187.5px;
  mask-image: url(../src/img/svg/check_mark.svg);
  mask-repeat: no-repeat;
  mask-position: center;
  mask-size: cover;
}
```

- CSS3 filter(滤镜) 属性

```css
/**
  * filter 属性定义了元素(通常是<img>)的可视效果(例如：模糊与饱和度)。
  * 语法
  filter: none | blur() | brightness() | contrast() | drop-shadow() | grayscale() | hue-rotate() | invert() | opacity() | saturate() | sepia() | url();
  */

/* blur 图片使用高斯模糊效果 */
img {
  -webkit-filter: blur(5px); /* Chrome, Safari, Opera */
  filter: blur(5px);
}

/* Brightness 使图片变亮 */
img {
  -webkit-filter: brightness(200%); /* Chrome, Safari, Opera */
  filter: brightness(200%);
}

/* 调整图像的对比度 */
img {
  -webkit-filter: contrast(200%); /* Chrome, Safari, Opera */
  filter: contrast(200%);
}

/* drop-shadow 给图像设置一个阴影效果: */
img {
  -webkit-filter: drop-shadow(8px 8px 10px red); /* Chrome, Safari, Opera */
  filter: drop-shadow(8px 8px 10px red);
}

/* Grayscale 将图像转换为灰度图像: */
img {
  -webkit-filter: grayscale(50%); /* Chrome, Safari, Opera */
  filter: grayscale(50%);
}

/* hue-rotate() 给图像应用色相旋转  */
img {
  -webkit-filter: hue-rotate(90deg); /* Chrome, Safari, Opera */
  filter: hue-rotate(90deg);
}

/* Invert 反转输入图像: */
img {
  -webkit-filter: invert(100%); /* Chrome, Safari, Opera */
  filter: invert(100%);
}

/* Opacity 转化图像的透明程度: */
img {
  -webkit-filter: opacity(30%); /* Chrome, Safari, Opera */
  filter: opacity(30%);
}

/** Saturate 转换图像饱和度:  */
img {
  -webkit-filter: saturate(800%); /* Chrome, Safari, Opera */
  filter: saturate(800%);
}

/* Sepia 函数实例  */
img {
  -webkit-filter: sepia(100%); /* Chrome, Safari, Opera */
  filter: sepia(100%);
}

/* 复合函数  使用多个滤镜，每个滤镜使用空格分隔 */
img {
  -webkit-filter: contrast(200%) brightness(150%); /* Chrome, Safari, Opera */
  filter: contrast(200%) brightness(150%);
}
```

- CSS3 中动画的实现

```css
/** 简单动画  */
.show {
  opacity: 1;
  transition: all 1.5s ease-in;
}
.hide {
  opacity: 0;
  transition: all 1.5s ease-in;
}

/** 复杂动画  */
.show {
  animation: show-item 2s ease-in forwards; // forwards属性，它是用来控制停止到最后一帧的
}
.hide {
  animation: hide-item 2s ease-in forwards;
}

@keyframes hide-item {
  0% {
    opacity: 1;
    color: yellow;
  }
  50% {
    opacity: 0.5;
    color: red;
  }
  100% {
    opacity: 0;
    color: green;
  }
}

@keyframes show-item {
  0% {
    opacity: 0;
    color: yellow;
  }
  50% {
    opacity: 0.5;
    color: red;
  }
  100% {
    opacity: 1;
    color: green;
  }
}
```

- 文字的选择

```css
/* user-select: none|auto|text|contain|all; */
/* 
属性值：
none :  元素和子元素的文本将无法被选中

text :  文本可以被选中

auto :  文本将根据浏览器的默认属性进行选择

all  :  当所有内容作为一个整体时可以被选择。如果双击或者在上下文上点击子元素，那么被选择的部分将是以该子元素向上回溯的最高祖先元素

contain、element :  可以选择文本，但选择范围受元素边界的约束，也就是选择的文本将包含在该元素的范围内。只支持Internet Explorer
 */
user-select: text; /* 文字可以被选中 */
user-select: none; /* 文字不可以被选中 */
```

## SCSS 的使用

- 变量

```scss
/* 
 * @import是全局变量通用，先合并在编译
 * 如果是纯样式scss文件，@import将会重复引用class 如果是变量混合@mixin则不会
 */
$blue: #1875e7;
　 div {
  color: $blue;
}

$side: left;
.rounded {
  border-#{$side}-radius: 5px;
}
```

- 计算功能

```scss
$var: 10;
.i-test {
  margin: (14px/2);
  top: 50px + 100px;
  right: $var * 10%;
}
```

- 选择器嵌套

```scss
div {
  h1 {
    color: red;
  }
}
```

- &引用父元素

```scss
a {
  &:hover {
    color: #ffb3ff;
  }
}
```

- 继承:使用@extend 命令

```scss
.class1 {
  border: 1px solid #ddd;
}
.class2 {
  @extend .class1;
  font-size: 120%;
}
```

- 继承:使用@mixin 命令

```scss
@mixin left {
  float: left;
  margin-left: 10px;
}
div {
  @include left();
}

/* 可以指定参数和缺省值 */
@mixin left($value: 10px) {
  float: left;
  margin-right: $value;
}

div {
  @include left(20px);
}
```

- 颜色函数

```scss
/* SASS提供了一些内置的颜色函数，以便生成系列颜色 */
lighten(#cc3, 10%) // #d6d65c
darken(#cc3, 10%) // #a3a329
grayscale(#cc3) // #808080
complement(#cc3) // #33c
```

- 引入外部文件

```scss
@import 'path/filename.scss';
```

- 条件语句

```scss
p {
  @if 1 + 1 == 2 {
    border: 1px solid;
  }
  @if 5 > 3 {
    border: 2px dotted;
  }
}

.rounded {
  @if lightness($color) > 30% {
    background-color: #000;
  } @else {
    background-color: #fff;
  }
}
```

- for 循环语句

```scss
@for $i from 1 to 10 {
  .border-#{$i} {
    border: #{$i}px solid blue;
  }
}
```

- while 循环

```scss
$i: 6;

@while $i > 0 {
  .item-#{$i} {
    width: 2em * $i;
  }
  $i: $i - 2;
}
```

- each 命令，作用与 for 类似

```scss
@each $member in a, b, c, d {
  .#{$member} {
    background-image: url('/image/#{$member}.jpg');
  }
}
```

- 自定义函数

```scss
@function double($n) {
  @return $n * 2;
}

#sidebar {
  width: double(5px);
}
```

## 滚动条美化样式美化

```css
/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/
::-webkit-scrollbar {
  width: 7px;
  height: 7px;
  background-color: #f5f5f5;
}

/*定义滚动条轨道 内阴影+圆角*/
::-webkit-scrollbar-track {
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
  -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
  border-radius: 10px;
  background-color: #f5f5f5;
}

/*定义滑块 内阴影+圆角*/
::-webkit-scrollbar-thumb {
  border-radius: 10px;
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.1);
  -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.1);
  background-color: rgba($primary, 0.5);
}
```

## flex 布局

- 作用于父级元素上的属性

```bash
## flex-direction
决定主轴的方向（即项目的排列方向）
flex-direction: row | row-reverse | column | column-reverse;
row（默认值）：主轴为水平方向，起点在左端。
row-reverse：主轴为水平方向，起点在右端。
column：主轴为垂直方向，起点在上沿。
column-reverse：主轴为垂直方向，起点在下沿。

## flex-wrap
项目都排在一条线（又称"轴线"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行
flex-wrap: nowrap | wrap | wrap-reverse;
nowrap（默认）：不换行。
wrap：换行，第一行在上方
wrap-reverse：换行，第一行在下方

## flex-flow
flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap

## justify-content
定义了项目在主轴上的对齐方式
justify-content: flex-start | flex-end | center | space-between | space-around;
flex-start（默认值）：左对齐
flex-end：右对齐
center： 居中
space-between：两端对齐，项目之间的间隔都相等。
space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍

## align-items
align-items属性定义项目在交叉轴上如何对齐
align-items: flex-start | flex-end | center | baseline | stretch;
flex-start：交叉轴的起点对齐。
flex-end：交叉轴的终点对齐。
center：交叉轴的中点对齐。
baseline: 项目的第一行文字的基线对齐。
stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

## align-content
定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用
align-content: flex-start | flex-end | center | space-between | space-around | stretch;
flex-start：与交叉轴的起点对齐。
flex-end：与交叉轴的终点对齐。
center：与交叉轴的中点对齐。
space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch（默认值）：轴线占满整个交叉轴。
```

- 作用于子项上的属性

```bash
## order
order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
## flex-grow
flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大
## flex-shrink
flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
## flex-basis
flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小
它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。
## flex
flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto
## align-self
align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，
如果没有父元素，则等同于stretch。
```

- 注意要点

```bash
# 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效
```

- 子元素如何分配父元素的剩余空间

```bash
## flex-grow、flex-shrink、flex-basis三个属性的作用

## flex-basis
该属性用来设置元素的宽度
同时设置了width和flex-basis，那么width 的值就会被flex-basis覆盖掉。


## flex-grow
当父元素的宽度大于所有子元素的宽度的和时（即父元素会有剩余空间），子元素如何分配父元素的剩余空间
flex-grow的默认值为0，意思是该元素不索取父元素的剩余空间
如果值大于0，表示索取。值越大，索取的越厉害。

## flex-shrink
当父元素的宽度小于所有子元素的宽度的和时（即子元素会超出父元素），子元素如何缩小自己的宽度的。
flex-shrink的默认值为1 当父元素的宽度小于所有子元素的宽度的和时，子元素的宽度会减小
值越大，减小的越厉害

```

- flex 是 flex-grow，flex-shrink, flex-basis 缩写形式

```bash
# flex 取值为 none，则计算值为 0 0 auto
.item {flex: none;}
# 当 flex取值为 auto，则计算值为 1 1 auto
.item {flex: auto;}
# 当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%
.item {flex: 1;}
# 当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink取 1
.item-1 {flex: 0%;}
# 当 flex取值为两个非负数字，则分别视为 flex-grow和 flex-shrink的值，flex-basis取 0%，
.item {flex: 2 3;}
```

## js 调试技巧大全

- 基本使用

```bash

## 快速定位文件
使用快捷键：ctrl + p

## 快速定位文件中成员函数
使用快捷键：ctrl + shif + o

## 设置断点
在 Source 内容区设置
在 js 源文件中需要执行断点操作的代码前加上 debugger

## 调用栈的查看
Call Stack 列表里的箭头便会指向哪里。同时当我们点击调用栈列表上的任意一处，便会调到相应的位置，可以查看对应调用栈里的变量。
可以右键选择 Restart Frame。断点就会跳到此处开头重新执行

## Snippets
在 Souces 页面下的 Snippets 栏目中，我们可以随时进行 JS 代码的编写，运行结果会打印到控制台
按下“Ctrl + Enter”执行

## Async 模式调试
```

## git 命令行提交

```bash
## 1.提交所有修改文件到储存区
git add -A
##
git commit -m '提交备注'

## 提交代码到远程
git push origin master

## git 跳过钩子校验
git commit -m '提交描述'  --no-verify
```

## vscode 快捷操作

```bash
f2 -> 批量更改变量名

## 多光标
1.alt + 鼠标左键点击
2.ctrl + alt + 上下方向键
3.光标放在一个地方，按ctrl+shift+L或者ctrl+f2，可以在页面中出现这个词的不同地方都出现光标
4.按shift+alt，再使用鼠标拖动，也可以出现竖直的列光标，同时可以选中多列

5.Ctrl + U 取消任何光标操作
```
