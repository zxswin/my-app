## React Hook

- 关于 Hook

```ts
/**
 * Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性
 * Hook中对状态的修改类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并
 *
 * 1.什么是Hook
 * Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。
 * Hook不能在Class组件中使用
 *
 * 2.Hook的使用规则
 * 只能在函数的最外层调用Hook
 * 不要在循环,条件判断,子函数中调用
 * 只能在React的函数组件中调用
 *
 * 3.自定义Hook
 * 函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook
 * 可以让组件之间重用一些状态逻辑
 * Hook 是一种复用状态逻辑的方式，
 * Hook 的每次调用都有一个完全独立的 state —— 因此你可以在单个组件中多次调用同一个自定义 Hook。
 *
 * 4.useState
 * 通过使用useState定义‘state变量’,当函数退出的时候State中的变量会被React保留
 * 可以通过调用多次useState来定义多个'state变量',可以传入唯一的参数用来初始化state
 * const [count, setCount] = useState() 返回了一个有两个值的数组
 * useState的返回值是当前的state以及更新的state函数
 *
 * 5.uesEffect
 * 会保存并在DOM更新之后调用你传入的函数
 * 第一次渲染和每次更新之后都会执行
 * 每次执行effect的同时,DOM都已经更新完毕
 *
 * 传递给useEffect的函数每次都有所不同 保证每次在useEffect中都能获取到最新的值
 * 某种意义上这是渲染的一部分,effect属于一次特殊的渲染
 *
 * 和componentMount 和 componentDidUpdate不同
 * 使用useEffect调度effect不会阻塞浏览器的更新,运用响应速度会更快
 *
 * Hook的更新机制
 * 1.如果更新的值和之前的一致将不会触发从新渲染
 * 2.React使用Object.is比较算法来比较state 如果传入的是当前的state,则不会渲染更新
 *
 *
 * 6.让effect同步执行可以使用 useLayoutEffect 和effect的使用方法一致
 */
```

- 一个计数器的例子

```tsx
/**
 * 一个计数器的例子
 */
import React, { useState } from 'react';

const HookCom: React.FC = () => {
  // 声明一个叫'count' 的state变量
  const [count, setCount] = useState(0);

  const clickCountChange = () => {
    const changeCount = count + 1;
    setCount(changeCount);
  };

  return (
    <div>
      <p>显示当前的计数器的值：{count}</p>
      <button onClick={clickCountChange}>点击增加计算器的值</button>
    </div>
  );
};

export default HookCom;
```

- 函数式更新

```tsx
/**
 * 使用场景:
 * 如果新的state需要使用先前的state计算得到
 *
 * 该函数接收先前的state,并返回一个更新后的值
 */

import React, { useState, useEffect } from 'react';

const HookCom: React.FC = () => {
  const [count, setCount] = useState(0);

  const reset = () => {
    setCount(0);
  };
  const add = () => {
    setCount((preCount) => preCount + 1);
  };
  const min = () => {
    setCount((preCount) => preCount - 1);
  };

  return (
    <div>
      <p>显示当前的计数器的值：{count}</p>
      <button onClick={reset}>重置</button>
      <button onClick={add}>加</button>
      <button onClick={min}>减法</button>
    </div>
  );
};

export default HookCom;
```

- 惰性初始 state

```tsx
/**
 * state的初始值只有在初始渲染的时候才起作用
 * 也可以传入一个函数计算并返回初始的state 当初始化的值获取需要比较复杂的逻辑处理的时候这种方式对性能会更好一点
 */

const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```

- Effect Hook

```tsx
/**
 * Effect Hook的作用:
 * 1.相当于Class组件中的componentDidMount,ComponentDidUpdate和componentWillUnmount
 * 2.给函数组件增加操作副作用的能力,例如在数据变更时执行的相关操作
 * 3.默认情况下每次渲染后都会调用Effect Hook,第一次渲染的时候也会调用
 *
 * 4.Effect Hook可以返回一个指定如何清除副作用的函数.例如取消订阅
 * 该函数会在函数组件被卸载的时候执行。
 * 组件第一次渲染的时候则不会执行到这个函数
 * 重新渲染的时候会首选执行这个函数然后再执行useEffect中的代码
 *
 * React 会在执行当前effect之前对上一个effect进行清除(如果有返回清除函数的话)
 *
 * 5.在函数式组件中可以多次使用到Effect Hook
 *
 */

import React, { useState, useEffect } from 'react';

const HookCom: React.FC = () => {
  // 声明一个叫'count' 的state变量
  const [count, setCount] = useState(0);

  const clickCountChange = () => {
    const changeCount = count + 1;
    setCount(changeCount);
  };

  useEffect(() => {
    console.log('第一次渲染和每次count变更都会执行', count);

    // 返回一个函数用于函数式组件被卸载的时候执行
    // 只要函数式组件发送了重新渲染就会执行到这个函数
    // 组件第一次渲染的时候则不会执行到这个函数

    // 重新渲染的时候会首选执行这个函数然后再执行useEffect中的代码
    return () => {
      console.log('函数式组件被卸载了');
    };
  });

  useEffect(() => {
    console.log('第二个useEffect也会被执行到');
  });

  return (
    <div>
      <p>显示当前的计数器的值：{count}</p>
      <button onClick={clickCountChange}>点击增加计算器的值</button>
    </div>
  );
};

export default HookCom;
```

- 自定义 Hook

```tsx
/**
 * 1.自定义Hook
 * 函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook
 * 可以让组件之间重用一些状态逻辑
 * Hook 是一种复用状态逻辑的方式，
 * Hook 的每次调用都有一个完全独立的 state —— 因此你可以在单个组件中多次调用同一个自定义 Hook。
 *
 * 它会产生一个状态的变更,这个变更会触发组件的更新
 *
 *
 * 被调用后的执行情况:
 * 1.会先去调用一次useEffect中的代码
 * 2.会去调用一次useEffect中的返回函数
 * 3.会去再调用一次useEffect中的代码
 *
 */
import React, { useState, useEffect } from 'react';

const useFriendStatus = (id) => {
  const [isOnline, setIsOnline] = useState(null);

  const handleStatusChange = (status) => {
    setIsOnline(status);
  };

  useEffect(() => {
    // 1.会先执行这里
    // 3.最后又重新执行到这里结束
    console.log('执行useEffect');
    handleStatusChange(true);

    return () => {
      // 2.然后会执行到这里
      console.log('执行了useEffect的返回函数');
      handleStatusChange(false);
    };
  });

  return isOnline;
};

const HookCom: React.FC = () => {
  const isOnline = useFriendStatus(0);

  return <div>{isOnline && <div>在线状态</div>}</div>;
};

export default HookCom;

/**
 * 实现自定义Hook函数的例子
 */
import React, { useState, useRef, useEffect } from 'react';

const usePreChecked = (value) => {
  const checkedRef = { current: value };

  useEffect(() => {
    // 这里首次加载和setChecked(random)的时候都会被触发
    checkedRef.current = value;
  });

  return checkedRef.current;
};

const HookCom: React.FC = () => {
  const random = Math.random();

  const [checked, setChecked] = useState(random);

  const preChecked = usePreChecked(random);

  const changeChecked = () => {
    const random = Math.random();
    // 当这里点击的时候会触发自定义Hook函数里面的useEffect;
    setChecked(random);
  };

  return (
    <>
      <p>
        checked: {String(checked)},preCheck: {String(preChecked)}
      </p>
      <p>
        <button id="button" onClick={changeChecked}>
          点击执行改变checked
        </button>
      </p>
    </>
  );
};

export default HookCom;
```

- 通过跳过 Effect 进行性能优化

```tsx
/**
 * React 会等待浏览器完成页面渲染后才会延迟调用useEffect
 *
 * 1.执行只运行一次的effect（仅在组件挂载和卸载的时候执行）,可以传递一个空数组
 * 传入空数组则effect内部的props和state一直都会拥有其初始值
 *
 * 如果有多个effect函数则相互之间是不会影响到的
 *
 * 2.第二个参数中数组里面的字段只有在某一个元素发生变化的时候才会触发渲染
 *
 * 3.useEffect 传递第二个参数，它是 effect 所依赖的值数组 也可以是props
 *
 * 4.所以effect函数中引用的值都应该出现在依赖项的数组中。
 */

import React, { useState, useEffect } from 'react';

const HookCom: React.FC = () => {
  // 声明一个叫'count' 的state变量
  const [count, setCount] = useState(0);

  const clickCountChange = () => {
    let changeCount = count + 1;
    if (changeCount >= 5) changeCount = 5;
    setCount(changeCount);
  };

  useEffect(() => {
    console.log(
      '第二个参数传入了空数组,只有在组件挂载和卸载的时候才会去执行',
      count
    );
    return () => {
      console.log('函数式组件被卸载了');
    };
  }, []);

  useEffect(() => {
    console.log(
      '第二个数组中传入的字段,只有在该元素发生改变的情况下才会触发渲染'
    );
  }, [count]);

  return (
    <div>
      <p>显示当前的计数器的值：{count}</p>
      <button onClick={clickCountChange}>点击增加计算器的值</button>
    </div>
  );
};

export default HookCom;

/**
 * 第二个参数传入的是props属性数值
 */

useEffect(() => {
  const subscription = props.source.subscribe();
  return () => {
    subscription.unsubscribe();
  };
}, [props.source]);
```

- 为什么不能在循环,条件或嵌套函数中调用 Hook

```tsx
/**
 * React 靠 Hook的调用顺序来确定那个state对应那个useState
 * Hook的调用顺序再每次渲染中都是相同的,所以它能够正常工作
 *
 * 如果使用了条件等语句
 * 第一次的渲染和第二次的渲染的Hook的调用顺序就会不一致
 * 导致Hook的调用被提前了
 */
```

- 使用 useReducer 的 Hook 管理复杂的状态

```tsx
/**
 * 语法：
 * const [state, dispatch] = useReducer(reducer, initialArg, init);
 * initialArg - 返回初始值的函数 init参数是它的入参
 *
 * 也可以直接传入初始值
 */

import React, { useReducer } from 'react';

const initialState = { count: 0 };

const reducer = (state, action) => {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
};

const HookCom: React.FC = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <>
      <p>Count:{state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>加法</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>减法</button>
    </>
  );
};

export default HookCom;
```

- useContext

```tsx
/**
 * 通过useContext就可以获取到React.createContext的共享上下文内容
 * 普通情况下是需要通过Consumer去获取
 */
import React, { useState, useEffect, useContext } from 'react';

const themes = {
  light: {
    foreground: '#000000',
    background: '#eeeeee',
  },
  dark: {
    foreground: '#ffffff',
    background: '#222222',
  },
};

const ThemeContext = React.createContext(themes.light);

const HookCom: React.FC = () => {
  return (
    <ThemeContext.Provider value={themes.dark}>
      <ThemedButton />
    </ThemeContext.Provider>
  );
};

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return (
    <button style={{ background: theme.background, color: theme.foreground }}>
      按钮的主题颜色通过useContext获取
    </button>
  );
}

export default HookCom;
```

- useCallback

```tsx
/**
 * 返回一个 memoized 回调函数。
 * 该回调函数仅在某个依赖项改变时才会更新
 * useCallback(fn, deps) 相当于 useMemo(() => fn, deps)。
 */

const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);

/**
 * useCallback也可以当做ref来使用
 */
import React, {
  useState,
  useRef,
  useEffect,
  useImperativeHandle,
  useCallback,
} from 'react';

const HookCom: React.FC = () => {
  const [height, setHeight] = useState(0);

  // const measuredRef1 = useRef(null);

  // useEffect(() => {
  //   const height = measuredRef1.current.getBoundingClientRect().height;
  //   setHeight(height);
  // });

  /**
   * 没有选中useRef
   * 当ref是一个对象的时候它并不会把当前的ref的值的变化通知我们
   * 使用callback ref可以确保即使组件延迟显示被测量的节点,依然能在父组件接收到相关的信息
   */
  const measuredRef = useCallback((node) => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);
  // 传递[]作为useCallback的依赖列表确保ref callback不会再再次渲染的时候改变。
  // 因为我们没有用到组件作用域中的 *任何* 值 被标识为安全的
  // []中的依赖项必须包含回调中的所有值(组件作用域中的变量)，并参与 React 数据流

  return (
    <>
      <h1 ref={measuredRef}>被计算的节点</h1>
      <h2>上面标题的高度是{Math.round(height)}px</h2>
    </>
  );
};

export default HookCom;
```

- useMemo

```ts
/**
 * 把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。
 * const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
 * 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值
 * 传入 useMemo 的函数会在渲染期间执行
 */
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

- useRef 的使用

```tsx
/**
 * 通过使用useRef可以访问Dom
 * useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。
 * 避免在渲染期间设置 refs
 */

import React, { useRef } from 'react';

const HookCom: React.FC = () => {
  const inputEl = useRef(null);
  const buttonClick = () => {
    const inputVal = inputEl.current.value;
    console.log(inputEl, inputVal);
  };

  return (
    <>
      <input ref={inputEl} type="text"></input>
      <button onClick={buttonClick}>点击获取input的值</button>
    </>
  );
};

export default HookCom;
```

- useImperativeHandle

```tsx
/**
 * useImperativeHandle(ref, createHandle, [deps])
 * useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值
 */
import React, { useRef, useImperativeHandle } from 'react';
/**
 * 使用useImperativeHandle可以让父子组件分别有各自的ref
 * 通过使用useImperativeHandle来自定义开放给父组件的current
 */

const FancyInput = React.forwardRef((props, ref) => {
  // 子组件的ref
  const inputRef = useRef() as any;

  /**
   * 第一个参数是定义current对象的ref
   * 第二个参数是一个函数,返回一个对象,即这个ref的current对象
   * 第三个参数可选即依赖项目参数数组
   */
  useImperativeHandle(ref, () => {
    // 返回给父组件使用的ref
    return {
      focus: () => {
        inputRef.current.focus();
        console.log('inputRef', inputRef);
      },
      data: {
        a: 1,
        b: 2,
      },
    };
  });

  return <input ref={inputRef} type="text" />;
});

const HookCom: React.FC = () => {
  // 父组件的ref
  const fancyInputRef = useRef() as any;

  const getSonRefClick = () => {
    console.log('fancyInputRef', fancyInputRef);
    fancyInputRef.current.focus();
  };

  return (
    <>
      <FancyInput ref={fancyInputRef} />

      <button onClick={getSonRefClick}>父组件调用子组件的focus</button>
    </>
  );
};

export default HookCom;
```

- useLayoutEffect

```ts
/**
 * 其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect
 * 尽可能使用标准的 useEffect 以避免阻塞视觉更新。
 */
```

- useDebugValue

```tsx
/**
 * useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签
 */

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  // ...

  // 在开发者工具中的这个 Hook 旁边显示标签
  // e.g. "FriendStatus: Online"
  useDebugValue(isOnline ? 'Online' : 'Offline');

  return isOnline;
}

/** 延迟格式化 debug 值  */
useDebugValue(date, (date) => date.toDateString());
```

## 合理使用 Hook 的技巧篇

```tsx
/**
 * Hook中的state可以是一个对象
 * 当Hook中的state更新的时候 会用新的state直接替换掉旧的state
 * 而class中的setState则是进行了合并操作
 */
function Box() {
  const [state, setState] = useState({
    left: 0,
    top: 0,
    width: 100,
    height: 100,
  });
  // ...
}

// 可以通过这种方式对值进行设置
// 展开 「...state」 以确保我们没有 「丢失」 width 和 height
setState((state) => ({ ...state, left: e.pageX, top: e.pageY }));

/**
 * 推荐把state按功能属性进行拆分,便于进行抽取自定义的Hook
 *
 */
function Box() {
  const position = useWindowPosition();
  const [size, setSize] = useState({ width: 100, height: 100 });
  // ...
}

function useWindowPosition() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  useEffect(() => {
    // ...
  }, []);
  return position;
}
```

- Hook 中实现 getDerivedStateFromProps

```tsx
/**
 * 只需要在函数顶部执行相关逻辑即可
 */
```

- Hook 中实现 forceUpdate 强制更新

```ts
/**
 * 可以使用useReducer来实现强制更新
 */

const [ignored, forceUpdate] = useReducer((x) => x + 1, 0);

function handleClick() {
  forceUpdate();
}
```

- 如何引用一个函数组件

```tsx
/**
 * 可以通过 useImperativeHandle Hook 暴露一些命令式的方法或参数给父组件
 */

import React, {
  useState,
  useRef,
  useImperativeHandle,
  useCallback,
} from 'react';

const FancyInput = React.forwardRef((props, ref) => {
  const [fresh, setFresh] = useState(false);
  const attRef = useRef(0); // 设置current的初始值为0

  // 传给父组件的Ref会随着fresh的改变而改变
  useImperativeHandle(ref, () => ({
    attRef,
    fresh,
  }));

  // 这里的点击是不会触发界面的刷新的
  // 在函数式组件里没有了 this 来存放一些实例的变量，所以 React 建议使用 useRef 来存放一些会发生变化的值
  // useRef 并不再单单是为了 DOM 的 ref 准备的，同时也会用来存放组件实例的属性。

  const handleClick = useCallback(() => {
    attRef.current++;
  }, [attRef]); // handleClick 只会依赖 attRef 的变化。不会在 fresh 改变时更新

  return (
    <div>
      {attRef.current}
      <button onClick={handleClick}>Fancy</button>
      <button
        onClick={() => {
          // 这里的改变会触发界面的重新渲染
          setFresh(!fresh);
        }}
      >
        刷新
      </button>
    </div>
  );
});

const HookCom: React.FC = () => {
  const fancyInputRef = useRef();

  return (
    <>
      <FancyInput ref={fancyInputRef} />
      <button
        onClick={() => {
          console.log(fancyInputRef.current);
        }}
      >
        父组件返回子组件的实例属性
      </button>
    </>
  );
};

export default HookCom;
```

- 优化类当创建的初始 state 很昂贵的时候

```tsx
/**
 * 如果直接赋初始值
 * 则每次渲染都会执行
 */
function Table(props) {
  // ⚠️ createRows() 每次渲染都会被调用
  const [rows, setRows] = useState(createRows(props.count));
  // ...
}

/**
 * 如果在回调函数中调用则只会再初始化的时候调用一次
 */
function Table(props) {
  // ✅ createRows() 只会被调用一次
  const [rows, setRows] = useState(() => createRows(props.count));
  // ...
}

/**
 * useRef的初始值赋值逻辑优化
 */
function Image(props) {
  // ⚠️ IntersectionObserver 在每次渲染都会被创建
  const ref = useRef(new IntersectionObserver(onIntersect));
  // ...
}

// 优化后的代码
function Image(props) {
  const ref = useRef(null);

  // ✅ IntersectionObserver 只会被惰性创建一次
  function getObserver() {
    if (ref.current === null) {
      ref.current = new IntersectionObserver(onIntersect);
    }
    return ref.current;
  }

  // 当你需要时，调用 getObserver()
  // ...
}
```

- 性能方面

```ts
/**
 * 传统上认为，在 React 中使用内联函数对性能的影响，与每次渲染都传递新的回调会如何破坏子组件的 shouldComponentUpdate 优化有
 * Hook 从三个方面解决了这个问题。
 */
```

- 避免向下传递回调的最佳实践

```tsx
/**
 * dispatch context 永远不会变，因此组件通过读取它就不需要重新渲染了，除非它们还需要应用的 state
 * 通过 context 用 useReducer 往下传一个 dispatch 函数
 */

/** 在父组件中  */
const TodosDispatch = React.createContext(null);

function TodosApp() {
  // 提示：`dispatch` 不会在重新渲染之间变化
  const [todos, dispatch] = useReducer(todosReducer);

  return (
    <TodosDispatch.Provider value={dispatch}>
      <DeepTree todos={todos} />
    </TodosDispatch.Provider>
  );
}

/** 在子组件中  */
function DeepChild(props) {
  // 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。
  const dispatch = useContext(TodosDispatch);

  function handleClick() {
    dispatch({ type: 'add', text: 'hello' });
  }

  return <button onClick={handleClick}>Add todo</button>;
}
```
