## 文件上传

## multipart-formdate 的表单

```ts
// 1.文件上传的请求头信息中Content-Type为multipart/form-data
// Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryuXqA8sUCWYVfNf4R

// 2.同时还需要规定一个内容分割用于分割请求提中多个post的内容，如文件内容和文本内容是需要分隔开来的，不然接收方就无法解析和还原这个文件了
// 例如：boundary=----WebKitFormBoundaryuXqA8sUCWYVfNf4R

// 3.multipart/form-data的请求体也是一个字符串
// ------WebKitFormBoundaryCvJ7D0M0tnOJlABd   // 分隔字符串  上传的文件文件对象
// Content-Disposition: form-data; name="file"; filename="微信图片_20181123090829.jpg"
// Content-Type: image/jpeg

// ------WebKitFormBoundaryCvJ7D0M0tnOJlABd  // 分隔字符串 附带的name参数 及其值
// Content-Disposition: form-data; name="name"

// koa2
// ------WebKitFormBoundaryCvJ7D0M0tnOJlABd  // 分隔字符串 附带的password参数 及其值
// Content-Disposition: form-data; name="password"

// 12345
// ------WebKitFormBoundaryCvJ7D0M0tnOJlABd // 分隔字符串 附带的info参数 及其值
// Content-Disposition: form-data; name="info"

// 附带信息
// ------WebKitFormBoundaryCvJ7D0M0tnOJlABd--

// 4.multipart/form-data 主要用于发送大量的二进制数据

// 5.表单的post请求 application/x-www-urlencoded 表示消息内容会经过 URL 格式编码

// 6.form 表单中 enctype 的默认值是 enctype="application/x- www-form-urlencoded"
// 需要想把enctype属性设置为multipart/form-data
// <form method="POST" action="http://w.sohu.com/t2/upload.do" enctype="multipart/form-data">
// </form>
```

- 一个控件实现对图片上传

```ts
// 提交给后端的数据格式为：

// ------WebKitFormBoundaryUBkUbOCsXxklJxLO // 上传的第一个文件
// Content-Disposition: form-data; name="file0"; filename="《HTTP 权威指南》高清中文版.pdf"
// Content-Type: application/kswps

// ------WebKitFormBoundaryUBkUbOCsXxklJxLO // 上传的第二个文件
// Content-Disposition: form-data; name="file1"; filename="0001.png"
// Content-Type: image/png

// ------WebKitFormBoundaryUBkUbOCsXxklJxLO // 上传的第三个文件
// Content-Disposition: form-data; name="file2"; filename="备份.txt"
// Content-Type: text/plain

// ------WebKitFormBoundaryUBkUbOCsXxklJxLO // 上传的第四个文件
// Content-Disposition: form-data; name="file3"; filename="季度总结上传模板.xlsx"
// Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet

// ------WebKitFormBoundaryUBkUbOCsXxklJxLO // 上传的第五个文件
// Content-Disposition: form-data; name="file4"; filename="微信图片\_20181123090829.jpg"
// Content-Type: image/jpeg

// ------WebKitFormBoundaryUBkUbOCsXxklJxLO // 上传文件的数量
// Content-Disposition: form-data; name="file + length"

// 5
// ------WebKitFormBoundaryUBkUbOCsXxklJxLO
// Content-Disposition: form-data; name="file + item"

// function item() { [native code] }
// ------WebKitFormBoundaryUBkUbOCsXxklJxLO
// Content-Disposition: form-data; name="name"

// koa2
// ------WebKitFormBoundaryUBkUbOCsXxklJxLO
// Content-Disposition: form-data; name="password"

// 12345
// ------WebKitFormBoundaryUBkUbOCsXxklJxLO
// Content-Disposition: form-data; name="info"

// 附带信息
// ------WebKitFormBoundaryUBkUbOCsXxklJxLO--
```

## 文件上传功能简单示范

- 多文件上传 | 前端预览 | 进度显示等功能实现

```pug
input(type="file",name="file",multiple="multiple", id="file1" (change)="selfile()")

div(*ngFor="let item of imgShowArr")
p {{item.name}} {{item.size}}
p {{item.src}}
p
img([src]="item.src")

.process
.process-bar([ngStyle]="processStyle")
```

- less 样式文件

```less
.process {
  width: 300px;
  height: 20px;
  border: 1px solid #f00;
  position: absolute;
  top: 0;
  left: 0;
  .process-bar {
    width: 20%;
    height: 20px;
    position: absolute;
    top: 0;
    left: 0;
    background: #f00;
  }
  .processWidth {
    width: 60%;
  }
}
```

- ts 文件结构

```ts
import { Component } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpEvent,
} from '@angular/common/http';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';

import { of } from 'rxjs';
import { catchError } from 'rxjs/operators';

@Component({
  selector: 'login',
  templateUrl: './login.component.pug',
  styleUrls: ['./login.component.less'],
})
export class LoginComponent {
  imgShowArr; // 需要在前台展示的所有图片
  processStyle = {
    width: '0%',
  }; // 显示进度信息

  constructor(private http: HttpClient, private sanitizer: DomSanitizer) {}
  ngOnInit() {
    const params = new HttpParams({
      fromObject: { _page: '111222', _limit: '1011' },
    });
    const headers = new HttpHeaders().set('token', 'iloveangular');

    this.http
      .get('/api/hello', {
        params,
      })
      .pipe(
        catchError((error) => {
          console.error('Error catched', error);
          return of({ description: 'Error Value Emitted' }); // 如果有异常会在subscribe中被打印出来
        })
      )
      .subscribe((v) => {});

    this.http
      .request('GET', '/api/hello', {
        headers, // 设置 Http Headers参数
        params,
        observe: 'response', // observe 属性值为 response 来获取完整的响应对象
      })
      .subscribe((v) => {
        console.log('通过request方法返回的数据', v);
      });

    this.http
      .post(
        '/api/pt',
        {
          namep: 'koa2',
          passwordp: '123',
        },
        {
          params,
          headers, // 设置 Http Headers参数
          observe: 'response', // observe 属性值为 response 来获取完整的响应对象
        }
      )
      .subscribe((v) => {
        console.log('get', v);
      });
  }

  selfile() {
    console.log('多文件上传开始');
    this.processStyle.width = '0%';
    this.imgShowArr = [];
    let file = document.getElementById('file1')['files']; //js 读取上传文件
    console.log('file', file);

    let data = new FormData();

    Object.keys(file).forEach((key) => {
      data.append(`file${key}`, file[key]);
      let json = {};
      json['name'] = file[key].name;
      json['size'] = file[key].size;
      // 前端展示上传图片预览 通过 this.sanitizer.bypassSecurityTrustUrl转成安全的url 要不然ng无法会标识为unsafe 无法显示
      json['src'] = this.sanitizer.bypassSecurityTrustUrl(
        window.URL.createObjectURL(file[key])
      );
      //把二进制对象直接读出浏览器显示的资源
      console.log(window.URL.createObjectURL(file[key]));
      this.imgShowArr.push(json);
    });

    console.log('this.imgShowArr', this.imgShowArr);
    data.append('name', 'koa2');
    data.append('password', '12345');
    data.append('info', '附带信息');
    console.log('data', data);
    this.upload(data);
  }

  upload(data) {
    this.http
      .post('/api/upload', data, {
        observe: 'events',
        reportProgress: true,
      })
      .subscribe((event: HttpEvent<any>) => {
        console.log('进度事件', event.type);

        // _ event.type = 0 表示 开始发送请求
        // _ event.type = 1 表示 响应体接受进度
        // _ event.type = 2 表示 响应头接收
        // _ event.type = 3 表示 响应体接受完成
        // _ event.type = 4 表示 请求完成

        if (event.type === 1) {
          console.log('进度事件', event);
          console.log('event.total ', event['total']); // 发送数据总大小
          console.log('event.loaded ', event['loaded']); // 接受数据大小 loaded
          const kbfile = event['total'] / 1024;
          const kbLoaded = event['loaded'] / 1024;
          console.log(`文件总大小! ${kbfile}Kb 上传`);
          console.log(`上传进度! ${kbLoaded}Kb 上传`);
          let process = (event['loaded'] / event['total']) * 100;
          console.log('process', process);
          this.processStyle.width = process + '%'; // 显示上传进度
        }
      });
  }
}
```

- 服务器端 NodeJs 代码

```ts
// 注意：
// content-type: text/html; charset=utf-8 默认情况服务器会根据响应内容自动设置
const Koa = require('koa');
let Router = require('koa-router');
const koaBody = require('koa-body');
const fs = require('mz/fs');

const path = require('path');

const app = new Koa();
const router = new Router();

const uuidv1 = require('uuid/v1'); // 用于生成唯一值

// 打印请求的 url
app.use(async (ctx, next) => {
  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
  await next();
});

app.use(koaBody()); // 解析请求体参数 要不然服务器无法识别

// get 请求
router.get('/api/hello', async (ctx, next) => {
  // console.log(ctx.request.query); // { name: 'koa', password: '12345' } 获取链接上的参数
  ctx.response.body = ctx;
});

// post 请求
router.post('/api/pt', async (ctx, next) => {
  // console.log(ctx.request.query); // { name: 'koa', password: '12345' } 获取链接上的参数
  // console.log(ctx.request.body); // { id: 'test', manufacturer: '测试数据', name: '测试数据 1', price: 888888 } 获取 body 上的数据
  ctx.response.body = ctx;
});

// 文件上传接口
router.post(
  '/api/upload',
  koaBody({
    // 自定义 koaBody 配置选项
    multipart: true, // 是否支持 multipart-formdate 的表单 默认是 false (其实就是是否支持文件上传)
    encoding: 'gzip',
    formidable: {
      uploadDir: path.join(__dirname, 'uploads/files'), // 设置文件默认上传目录 自定义目录和名称可以不写
      keepExtensions: true, // 保持文件的后缀
      maxFieldsSize: 2 * 1024 * 1024, // 文件上传大小
      onFileBegin: (name, file) => {
        // 文件上传前的设置
        // name 是 input type='file' 的 name 属性值
        // file 为单个文件对象 多个文件上传 则 次文件会执行多次

        console.log('=============================');
        console.log(file);
        console.log('=============================');

        let date = new Date();
        let month = Number.parseInt(date.getMonth()) + 1;
        month = month.toString().length > 1 ? month : `0${month}`;
        let fileDir = `${date.getFullYear()}${month}${date.getDate()}`;

        let dir = path.join(__dirname, `uploads/files/${fileDir}`); // 设置文件上传路径 必须真实存在

        /**
         * 要生成文件在自定义的目录中 必须使用同步模式 要不然无法生成在自动目录 而是生成在默认目录下
         */
        try {
          fs.accessSync(dir);
          console.log('可读可写');
          upload();
        } catch (err) {
          console.error('不可访问');
          try {
            fs.mkdirSync(dir);
            upload();
          } catch (err) {
            console.log('err', err);
          }
        }

        function upload() {
          // 自定义生成文件
          let extname = path.extname(file.name);
          let fileName = uuidv1();
          let filePath = path.join(dir, file.name);
          file.path = filePath; // 指定文件生成路径 用于生成文件
        }
      },
    },
  }),
  async (ctx, next) => {
    console.log('上传成功');
    // console.log(ctx.request.files); // 获取上传后文件的信息
    // console.log(ctx.request.body); // 获取其他的表单字段
    ctx.response.body = JSON.stringify(ctx.request.files);
  }
);

// 添加路由中间件
app.use(router.routes()).use(router.allowedMethods());
app.listen(3000);
console.log('app started at port 3000...');
```

## 单词:

```pug
transfer 请转移
blob 斑点
binary 二进制的
bound 跳跃 界限
disposition 性情 性格 意向 倾向 安排 配置 部署
plain 平地 素的
guid 指导
```
