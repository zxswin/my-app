## nodejs 系统学习

- 如何对外输出及引用变量

```ts
// 简单的demo

// hello.js
'use strict'; //启用严格模式
var s = 'Hello';
function greet(name) {
  console.log(s + ', ' + name + '!');
}
module.exports = greet; //把函数greet作为模块的输出暴露出去
```

```ts
// app.js
'use strict';
var greet = require('./hello'); // 引入hello模块: 不要忘了写相对目录!
var s = 'Michael';
greet(s); // Hello, Michael!
```

- 基本模板及使用

```ts
// 1.global： Node.js 环境中，也有唯一的全局对象
// 2.process 也是 Node.js 提供的一个对象，它代表当前 Node.js 进程
process === global.process; //true
process.version; //'v8.11.4'
process.platform; //'win32'
process.arch; //'x64'
process.cwd(); //'C:\\Users\\ZXS\\Desktop\\NodeJS 学习笔记\\demo'
process.chdir('/private/tmp'); // 切换当前工作目录

// process 简单运用代码
//判断 JavaScript 执行环境
if (typeof window === 'undefined') {
  console.log('node.js');
} else {
  console.log('browser');
}

// process.nextTick()将在下一轮事件循环中调用:
process.nextTick(function () {
  console.log('nextTick callback!');
});
console.log('nextTick was set!');

// 程序即将退出时的回调函数:
process.on('exit', function (code) {
  console.log('about to exit with code: ' + code);
});
```

## fs 模块

```ts
/**
 * Node.js 标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。
 */
```

- 文件的读取

```ts
/**
 * 当正常读取时，err 参数为 null，data 参数为读取到的 String。
 * 当读取发生错误时，err 参数代表一个错误对象，data 为 undefined。
 */

// 异步读取文本文件
var fs = require('fs');
fs.readFile('sample.txt', 'utf-8', function (err, data) {
  if (err) {
    console.log(err);
  } else {
    console.log(data);
  }
});
```

- 步读取图像等二进制文件

```ts
/**
 * 当读取二进制文件时，不传入文件编码时，回调函数的 data 参数将返回一个 Buffer 对象。
 * 在 Node.js 中，Buffer 对象就是一个包含零个或任意个字节的数组（注意和 Array 不同）。
 */

var fs = require('fs');
fs.readFile('sample.png', function (err, data) {
  if (err) {
    console.log(err);
  } else {
    console.log(data);
    console.log(data.length + ' bytes');
  }
});

// Buffer 对象可以和 String 作转换，例如，把一个 Buffer 对象转换成 String：
var text = data.toString('utf-8');
console.log(text);

// 把一个 String 转换成 Buffer
var buf = Buffer.from(text, 'utf-8');
console.log(buf);
```

- 同步读文件

```ts
// 如果同步读取文件发生错误，则需要用 try...catch 捕获该错误：

try {
  var data = fs.readFileSync('sample.txt', 'utf-8');
  console.log(data);
} catch (err) {
  // 出错了
}
```

- 写文件

```ts
/**
 * writeFile()的参数依次为文件名、数据和回调函数。
 * 如果传入的数据是 String，默认按 UTF-8 编码写入文本文件，
 * 如果传入的参数是 Buffer，则写入的是二进制文件。
 */

// 异步写入文件
var fs = require('fs');
var data = 'Hello, Node.js';
fs.writeFile('output.txt', data, function (err) {
  if (err) {
    console.log(err);
  } else {
    console.log('ok.');
  }
});

// 同步写入文件
var fs = require('fs');
var data = 'Hello, Node.js';
fs.writeFileSync('output.txt', data);
```

- fs.stat() 获取文件信息

```ts
/**
 * 如果我们要获取文件大小，创建时间等信息，可以使用 fs.stat()
 * 它返回一个 Stat 对象，能告诉我们文件或目录的详细信息：
 */

// fs.stat()获取文件信息
var fs = require('fs');
fs.stat('sample.txt', function (err, stat) {
  if (err) {
    console.log(err);
  } else {
    // 是否是文件:
    console.log('isFile: ' + stat.isFile());
    // 是否是目录:
    console.log('isDirectory: ' + stat.isDirectory());
    if (stat.isFile()) {
      // 文件大小:
      console.log('size: ' + stat.size);
      // 创建时间, Date 对象:
      console.log('birth time: ' + stat.birthtime);
      // 修改时间, Date 对象:
      console.log('modified time: ' + stat.mtime);
    }
  }
});
```

- 总结：

```ts
/**
 * 绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码
 * 服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码
 */
```

## stream 支持“流”这种数据结构

```ts
/**
 * 所有可以读取数据的流都继承自 stream.Readable
 * 所有可以写入的流都继承自 stream.Writable
 */
```

- 1.从文件流读取文本内容

```ts
/**
 * data 事件表示流的数据已经可以读取了
 * end 事件表示这个流已经到末尾了,没有数据可以读取了
 * error 事件表示出错了。
 *
 * data 事件可能会有多次，每次传递的 chunk 是流的一部分数据
 */
var fs = require('fs');
// 打开一个流:
var rs = fs.createReadStream('sample.txt', 'utf-8');
rs.on('data', function (chunk) {
  console.log('DATA:');
  console.log(chunk);
});

rs.on('end', function () {
  console.log('END');
});

rs.on('error', function (err) {
  console.log('ERROR: ' + err);
});
```

- 要以流的形式写入文件，只需要不断调用 write()方法，最后以 end()结束：

```ts
var fs = require('fs');

var ws1 = fs.createWriteStream('output1.txt', 'utf-8');
ws1.write('使用 Stream 写入文本数据...\n');
ws1.write('END.');
ws1.end();

var ws2 = fs.createWriteStream('output2.txt');
ws2.write(new Buffer('使用 Stream 写入二进制数据...\n', 'utf-8'));
ws2.write(new Buffer('END.', 'utf-8'));
ws2.end();
```

- 所有的数据自动从 Readable 流进入 Writable 流，这种操作叫 pipe。

```ts
/**
 * Readable 流有一个 pipe()方法，就是用来干这件事的
 * 默认情况下，当 Readable 流的数据读取完毕，end 事件触发后，将自动关闭 Writable 流。
 * 如果我们不希望自动关闭 Writable 流，需要传入参数：
 *
 * readable.pipe(writable, { end: false });
 */
var fs = require('fs');
var rs = fs.createReadStream('sample.txt');
var ws = fs.createWriteStream('copied.txt');
rs.pipe(ws);
```

## HTTP 模块

```ts
/**
 * request 对象封装了 HTTP 请求，我们调用 request 对象的属性和方法就可以拿到所有 HTTP 请求的信息；
 * response 对象封装了 HTTP 响应，我们操作 response 对象的方法，就可以把 HTTP 响应返回给浏览器。
 */
```

- 实现一个简单的 HTTP 服务器程序

```ts
// 导入 http 模块:
var http = require('http');

// 创建 http server，并传入回调函数:
var server = http.createServer(function (request, response) {
  // 回调函数接收 request 和 response 对象,
  // 获得 HTTP 请求的 method 和 url:
  console.log(request.method + ': ' + request.url);
  // 将 HTTP 响应 200 写入 response, 同时设置 Content-Type: text/html:
  response.writeHead(200, { 'Content-Type': 'text/html' });
  // 将 HTTP 响应的 HTML 内容写入 response:
  response.end('<h1>Hello world!</h1>');
});

// 让服务器监听 8080 端口:
server.listen(8080);

console.log('Server is running at http://127.0.0.1:8080/');
```

- 文件服务器

```ts
/**
 * url 模块，它使用起来非常简单，通过 parse()将一个字符串解析为一个 Url 对象
 */

var url = require('url');
console.log(
  url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash')
);

// Url {
//     protocol: 'http:', //协议
//     slashes: true, //斜线
//     auth: 'user:pass', //作者
//     host: 'host.com:8080',
//     port: '8080',
//     hostname: 'host.com',
//     hash: '#hash',
//     search: '?query=string',
//     query: 'query=string',
//     pathname: '/path/to/file',
//     path: '/path/to/file?query=string',
//     href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash'
// }
```

- 处理本地文件目录需要使用 Node.js 提供的 path 模块，它可以方便地构造目录：

```ts
var path = require('path');
// 解析当前目录:
var workDir = path.resolve('.');
// 组合完整的文件路径:当前目录+'pub'+'index.html':
var filePath = path.join(workDir, 'pub', 'index.html');
console.log('workDir', workDir); // '/Users/michael'
console.log('filePath', filePath); // '/Users/michael/pub/index.html'
```

- 简单实例代码如下(一个简单的服务器程序)

```ts
var fs = require('fs'),
  url = require('url'),
  path = require('path'),
  http = require('http');

// 从命令行参数获取 root 目录，默认是当前目录:
console.log('process.argv', process.argv);
console.log('process.argv[2]', process.argv[2]);
var root = path.resolve(process.argv[2] || '.');

console.log('Static root dir: ' + root);

// 创建服务器:
var server = http.createServer(function (request, response) {
  // 获得 URL 的 path，类似 '/css/bootstrap.css':
  var pathname = url.parse(request.url).pathname;
  // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':
  var filepath = path.join(root, pathname);
  // 获取文件状态:
  fs.stat(filepath, function (err, stats) {
    if (!err && stats.isFile()) {
      // 没有出错并且文件存在:
      console.log('200 ' + request.url);
      // 发送 200 响应:
      response.writeHead(200);
      // 将文件流导向 response:
      fs.createReadStream(filepath).pipe(response);
    } else if (!err && stats.isDirectory()) {
      // 如果遇到请求的路径是目录，则自动在目录下依次搜索 index.html、default.html，如果找到了，就返回 HTML 文件的内容
      console.log('200 ' + request.url);
      response.writeHead(200);
      let files = fs.readdirSync(filepath);
      console.log('files888', files);
      files.forEach((v) => {
        if (v === 'index.html') {
          fs.createReadStream(path.join(filepath, 'index.html')).pipe(response);
        } else if (v === 'default.html') {
          fs.createReadStream(path.join(filepath, 'default.html')).pipe(
            response
          );
        }
      });
    } else {
      // 出错了或者文件不存在:
      console.log('404 ' + request.url);
      // 发送 404 响应:
      response.writeHead(404);
      response.end('404 Not Found');
    }
  });
});

server.listen(8080);
console.log('Server is running at http://127.0.0.1:8080/');
```

- crypto 模块的目的是为了提供通用的加密和哈希算法。

```ts
/**
 * Nodejs 用 C/C++实现这些算法后，通过 cypto 这个模块暴露为 JavaScript 接口，这样用起来方便，运行速度也快。
 */
const crypto = require('crypto');
const hash = crypto.createHash('md5');

// 使用 hash.update() 方法将要计算的数据以流（stream）的方式写入，
// 流输入结束后，使用 hash.digest() 方法计算数据的 hash 值。
// 可任意多次调用 update():

// 输入流编码：utf8、ascii、binary（默认）
hash.update('some data to hash', 'utf8');

hash.update('Hello, world!');
hash.update('Hello, nodejs!');

// 输出编码：hex、binary、base64
console.log(hash.digest('hex')); // 7e1977739c748beac0c0fd14fd26a544
```

## Web 开发技术选型

```ts
/**
 * koa -- koa2 版本
 * koa 是 Express 的下一代基于 Node.js 的 web 框架，目前有 1.x 和 2.0 两个版本。
 */
```

- koa 的安装及使用

```ts
// 安装
// 1.npm install koa

// koa 简单代码示例
// 导入 koa，和 koa 1.x 不同，在 koa2 中，我们导入的是一个 class，因此用大写的 Koa 表示:
const Koa = require('koa');

// 创建一个 Koa 对象表示 web app 本身:
const app = new Koa();

// 对于任何请求，app 将调用该异步函数处理请求：
app.use(async (ctx, next) => {
  await next();
  ctx.response.type = 'text/html';
  ctx.response.body = '<h1>Hello, koa2!</h1>';
});

// 在端口 3000 监听:
app.listen(3000);
console.log('app started at port 3000...');
```

- 执行多个异步函数示例

```ts
/**
 * 参数 ctx 是由 koa 传入的封装了 request 和 response 的变量
 * 我们可以通过它访问 request 和 response
 * next 是 koa 传入的将要处理的下一个异步函数
 *
 * koa 把很多 async 函数组成一个处理链
 * 每个 async 函数都可以做一些自己的事情，然后用 await next()来调用下一个 async 函数
 *
 * 我们把每个 async 函数称为 middleware
 * 这些 middleware 可以组合起来，完成很多有用的功能。
 *
 *
 * ctx 对象有一些简写的方法，
 * 例如 ctx.url 相当于 ctx.request.url，
 * ctx.type 相当于 ctx.response.type。
 */
const Koa = require('koa');
const app = new Koa();

app.use(async (ctx, next) => {
  console.log(`${ctx.request.method} ${ctx.request.url}`); // 打印 URL
  await next(); // 调用下一个 middleware
});

app.use(async (ctx, next) => {
  const start = new Date().getTime(); // 当前时间
  await next(); // 调用下一个 middleware
  const ms = new Date().getTime() - start; // 耗费时间
  console.log(`Time: ${ms}ms`); // 打印耗费时间
});

app.use(async (ctx, next) => {
  await next();
  ctx.response.type = 'text/html';
  ctx.response.body = '<h1>Hello, koa2!</h1>';
});

// 在端口 3000 监听:
app.listen(3000);
console.log('app started at port 3000...');
```

- 处理 URL 并实现页面分离

```ts
/**
 * 1.单纯使用 koa2 实现对各类不同的 URL 的处理
 */
const Koa = require('koa');
const app = new Koa();

app.use(async (ctx, next) => {
  if (ctx.request.path === '/') {
    ctx.response.body = 'index page';
  } else {
    await next();
  }
});

app.use(async (ctx, next) => {
  if (ctx.request.path === '/test') {
    ctx.response.body = 'TEST page';
  } else {
    await next();
  }
});

app.use(async (ctx, next) => {
  if (ctx.request.path === '/error') {
    ctx.response.body = 'ERROR page';
  } else {
    await next();
  }
});
```

- koa-router

```ts
/**
 * 为了处理 URL，我们需要引入 koa-router 这个 middleware，让它负责处理 URL 映射。
 *
 * 安装 npm install koa-router
 * 注意导入 koa-router 的语句最后的()是函数调用
 * 注意 require('koa-router')返回的是函数
 * const router = require('koa-router')();
 */

const Koa = require('koa');

// 注意 require('koa-router')返回的是函数:
const router = require('koa-router')();

const app = new Koa();

// log request URL:
app.use(async (ctx, next) => {
  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
  await next();
});

// add url-route:
router.get('/hello/:name', async (ctx, next) => {
  var name = ctx.params.name;
  ctx.response.body = `<h1>Hello, ${name}!</h1>`;
  //示范 url http://127.0.0.1:3000/hello/mmmddd
});

router.get('/', async (ctx, next) => {
  ctx.response.body = '<h1>Index</h1>';
});

// add router middleware:
app.use(router.routes());

app.listen(3000);
console.log('app started at port 3000...');
```

- koa-bodyparser 处理 post 请求

```ts
/**
 * 用 router.get('/path', async fn)处理的是 get 请求。
 * 如果要处理 post 请求，可以用 router.post('/path', async fn)。
 * 解析原始 request 请求，然后，把解析后的参数，绑定到 ctx.request.body 中
 *
 * 安装
 * npm install koa-bodyparser -S
 *
 * 使用
 * app.use(bodyParser());
 */

// 一个简单的初步案例
const Koa = require('koa');
const bodyParser = require('koa-bodyparser');
const router = require('koa-router')();
const app = new Koa();
// log request URL:
app.use(async (ctx, next) => {
  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
  await next();
});
// parse request body:
app.use(bodyParser());
// add url-route:
router.get('/hello/:name', async (ctx, next) => {
  var name = ctx.params.name;
  ctx.response.body = `<h1>Hello, ${name}!</h1>`;
});
router.get('/', async (ctx, next) => {
  ctx.response.body = `<h1>Index</h1>

<form action="/signin" method="post">
<p>Name: <input name="name" value="koa"></p>
<p>Password: <input name="password" type="password"></p>
<p><input type="submit" value="Submit"></p>
</form>`;
});
router.post('/signin', async (ctx, next) => {
  var name = ctx.request.body.name || '',
    password = ctx.request.body.password || '';
  console.log(`signin with name: ${name}, password: ${password}`);
  if (name === 'koa' && password === '12345') {
    ctx.response.body = `<h1>Welcome, ${name}!</h1>`;
  } else {
    ctx.response.body = `<h1>Login failed!</h1>
<p><a href="/">Try again</a></p>`;
  }
});
// add router middleware:
app.use(router.routes());
app.listen(3000);
console.log('app started at port 3000...');
```

- 实现代码逻辑分离

```ts
// 1.app.js
const Koa = require('koa');
const bodyParser = require('koa-bodyparser');
const controller = require('./controller');
const app = new Koa();

// 打印出请求的 url 开始启动 web 服务功能:
app.use(async (ctx, next) => {
  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
  await next();
});

// 解析请求体:
app.use(bodyParser());

// 加入控制器:
app.use(controller());

app.listen(3000);
console.log('app started at port 3000...');
```

```ts
// 2.hello.js 业务逻辑代码
var fn_hello = async (ctx, next) => {
  var name = ctx.params.name;
  ctx.response.body = `<h1>Hello, ${name}!</h1>`;
};

module.exports = {
  'GET /hello/:name': fn_hello, //暴露出对于的 url 及方法
};
```

```ts
// 3.index.js 业务逻辑代码
var fn_index = async (ctx, next) => {
  ctx.response.body = `<h1>Index</h1> <form action="/signin" method="post"> <p>Name: <input name="name" value="koa"></p> <p>Password: <input name="password" type="password"></p> <p><input type="submit" value="Submit"></p> </form>`;
};

var fn_signin = async (ctx, next) => {
  var name = ctx.request.body.name || '',
    password = ctx.request.body.password || '';
  console.log(`signin with name: ${name}, password: ${password}`);
  if (name === 'koa' && password === '12345') {
    ctx.response.body = `<h1>Welcome, ${name}!</h1>`;
  } else {
    ctx.response.body = `<h1>Login failed!</h1> <p><a href="/">Try again</a></p>`;
  }
};

module.exports = {
  //暴露出对于的 url 及方法
  'GET /': fn_index,
  'POST /signin': fn_signin,
};
```

```ts
// 4.controller.js
const fs = require('fs');
// add url-route in /controllers:

function addMapping(router, mapping) {
  for (var url in mapping) {
    if (url.startsWith('GET ')) {
      var path = url.substring(4);
      router.get(path, mapping[url]);
      console.log(`register URL mapping: GET ${path}`);
    } else if (url.startsWith('POST ')) {
      var path = url.substring(5);
      router.post(path, mapping[url]);
      console.log(`register URL mapping: POST ${path}`);
    } else if (url.startsWith('PUT ')) {
      var path = url.substring(4);
      router.put(path, mapping[url]);
      console.log(`register URL mapping: PUT ${path}`);
    } else if (url.startsWith('DELETE ')) {
      var path = url.substring(7);
      router.del(path, mapping[url]);
      console.log(`register URL mapping: DELETE ${path}`);
    } else {
      console.log(`invalid URL: ${url}`);
    }
  }
}

function addControllers(router, dir) {
  fs.readdirSync(__dirname + '/' + dir)
    .filter((f) => {
      return f.endsWith('.js'); //获取说有的 js 文件
    })
    .forEach((f) => {
      console.log(`process controller: ${f}...`);
      let mapping = require(__dirname + '/' + dir + '/' + f);
      addMapping(router, mapping);
    });
}

module.exports = function (dir) {
  let controllers_dir = dir || 'controllers',
    router = require('koa-router')();
  addControllers(router, controllers_dir);
  return router.routes(); //暴露出 router.routes()给 app.js 使用
};
```

## Nunjucks

```ts
/**
 * Nunjucks 是 Mozilla 开发的一个纯 JavaScript 编写的模板引擎，
 * 既可以用在 Node 环境下，又可以运行在浏览器端
 *
 * 因为 Nunjucks 就是用 JavaScript 重新实现了 jinjia2。
 * 1.是一个模板引擎,
 * 2.对特殊字符要转义，避免受到 XSS 攻击。
 * 3.对不同类型的变量要格式化
 * 4.Nunjucks 默认就使用同步 IO 读取模板文件
 *
 * 设置 noCache: false 这个参数。 模板文件最多读取一次，就会放在内存中
 */
```

- 使用

```ts
/**
 * 安装
 * npm install nunjucks -S
 */
```

```ts
// app.js
const nunjucks = require('nunjucks');

function createEnv(path, opts) {
  var autoescape = opts.autoescape === undefined ? true : opts.autoescape,
    noCache = opts.noCache || false,
    watch = opts.watch || false,
    throwOnUndefined = opts.throwOnUndefined || false,
    env = new nunjucks.Environment(
      //env 表示模板引擎对象
      new nunjucks.FileSystemLoader(path, {
        //创建一个文件系统加载器，从 views 目录读取模板
        noCache: noCache,
        watch: watch,
      }),
      {
        autoescape: autoescape,
        throwOnUndefined: throwOnUndefined,
      }
    );
  if (opts.filters) {
    for (var f in opts.filters) {
      env.addFilter(f, opts.filters[f]);
    }
  }
  return env;
}

var env = createEnv('views', {
  watch: true,
  filters: {
    hex: function (n) {
      return '0x' + n.toString(16);
    },
  },
});

//传入 view 和 model 两个参数，并返回字符串。
var s = env.render('hello.html', {
  name: '<Nunjucks>',
  fruits: ['Apple', 'Pear', 'Banana'],
  count: 12000,
});

console.log(s);

console.log(
  env.render('extend.html', {
    header: 'Hello',
    body: 'bla bla bla...',
  })
);
```

```html
<!-- /views/hello.html -->
<html>
  <head>
    <title>Hello {{ name }}</title>
  </head>
  <body>
    <h3>Fruits List</h3>
    {% for f in fruits %}
    <p>{{ f }}</p>
    {% endfor %}
    <p>Total: {{ count|hex }}</p>
  </body>
</html>
```

```html
<!-- /views/base.html -->
<html>
  <body>
    {% block header %}
    <h3>Unnamed</h3>
    {% endblock %} {% block body %}
    <div>No body</div>
    {% endblock %} {% block footer %}
    <div>copyright</div>
    {% endblock %}
  </body>

  /views/extend.html {% extends 'base.html' %} {% block header %}
  <h1>{{ header }}</h1>
  {% endblock %} {% block body %}
  <p>{{ body }}</p>
  {% endblock %}
</html>
```

## 使用 MVC

```ts
/**
 * 安装 mime 依赖 用于获取文件类型
 * npm i mime -S
 *
 * 安装 mz 依赖 封装了 fs 对应的函数，并改为 Promise,用 await 调用 mz 的函数，而不需要任何回调
 * npm i mz -S
 *
 * 生产环境上必须配置环境变量 NODE_ENV = 'production'，而开发环境不需要配置
 * process.env.NODE_ENV === 'production';
 */
```

```ts
// 1.app.js
const Koa = require('koa');

const bodyParser = require('koa-bodyparser');

const controller = require('./controller');

const templating = require('./templating');

const app = new Koa();

const isProduction = process.env.NODE_ENV === 'production';

app.use(async (ctx, next) => {
  //web 服务程序开始 返回响应时间
  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
  var start = new Date().getTime(),
    execTime;
  await next();
  execTime = new Date().getTime() - start;
  ctx.response.set('X-Response-Time', `${execTime}ms`);
});

if (!isProduction) {
  //如果是在开发环境下
  let staticFiles = require('./static-files');
  app.use(staticFiles('/static/', __dirname + '/static')); //去获取必要的静态资源
}

// 解析请求体
app.use(bodyParser());

// 输出视图: 这里仅仅给 ctx 定义了 render 方法可以生成视图
app.use(
  templating('views', {
    noCache: !isProduction,
    watch: !isProduction,
  })
);

// url 控制器解析 实际生成视图
app.use(controller());

app.listen(3000); //网络端口监听
console.log('app started at port 3000...');
```

```ts
// controller.js
const fs = require('fs');

// add url-route in /controllers:

function addMapping(router, mapping) {
  //对路径及访问该路径应该执行的逻辑做处理
  for (var url in mapping) {
    if (url.startsWith('GET ')) {
      var path = url.substring(4);
      router.get(path, mapping[url]);
      console.log(`register URL mapping: GET ${path}`);
    } else if (url.startsWith('POST ')) {
      var path = url.substring(5);
      router.post(path, mapping[url]);
      console.log(`register URL mapping: POST ${path}`);
    } else if (url.startsWith('PUT ')) {
      var path = url.substring(4);
      router.put(path, mapping[url]);
      console.log(`register URL mapping: PUT ${path}`);
    } else if (url.startsWith('DELETE ')) {
      var path = url.substring(7);
      router.del(path, mapping[url]);
      console.log(`register URL mapping: DELETE ${path}`);
    } else {
      console.log(`invalid URL: ${url}`);
    }
  }
}

function addControllers(router, dir) {
  fs.readdirSync(__dirname + '/' + dir)
    .filter((f) => {
      return f.endsWith('.js'); //过滤出 js 文件 返回一个 js 文件数组
    })
    .forEach((f) => {
      console.log(`process controller: ${f}...`);
      let mapping = require(__dirname + '/' + dir + '/' + f); //获取 js 文件中对外暴露的模块方法
      addMapping(router, mapping);
    });
}

module.exports = function (dir) {
  let controllers_dir = dir || 'controllers',
    router = require('koa-router')();
  addControllers(router, controllers_dir);
  return router.routes(); //返回后在 app.js 中可以 app.use(controller());这么使用
};
```

```ts
// templating.js
const nunjucks = require('nunjucks');

function createEnv(path, opts) {
  var autoescape = opts.autoescape === undefined ? true : opts.autoescape,
    noCache = opts.noCache || false,
    watch = opts.watch || false,
    throwOnUndefined = opts.throwOnUndefined || false,
    env = new nunjucks.Environment(
      new nunjucks.FileSystemLoader(path, {
        noCache: noCache,
        watch: watch,
      }),
      {
        autoescape: autoescape,
        throwOnUndefined: throwOnUndefined,
      }
    );
  if (opts.filters) {
    for (var f in opts.filters) {
      env.addFilter(f, opts.filters[f]);
    }
  }
  return env;
}

function templating(path, opts) {
  var env = createEnv(path, opts);
  return async (ctx, next) => {
    ctx.render = function (view, model) {
      //ctx 本省是没有 render 方法的 这里给它加上 render 方法
      //Object.assign({}, ctx.state || {}, model || {}) 使程序便于拓展
      console.log('view', view);
      console.log('model', model);

      ctx.response.body = env.render(
        view,
        Object.assign({}, ctx.state || {}, model || {})
      ); //把字符串返回给响应体
      ctx.response.type = 'text/html';
    };
    await next();
  };
}

module.exports = templating;
```

```ts
// static-file.js
const path = require('path');
const mime = require('mime');
const fs = require('mz/fs');

function staticFiles(url, dir) {
  return async (ctx, next) => {
    //有响应就会执行
    let rpath = ctx.request.path; //获取请求路径
    console.log('请求的路径', rpath);
    if (rpath.startsWith(url)) {
      //如果路径中包含了 url 参数字符串
      let fp = path.join(dir, rpath.substring(url.length)); //获取文件所在路径
      console.log('获取文件所在路径', fp);
      if (await fs.exists(fp)) {
        //如果这个文件时存在的
        ctx.response.type = mime.getType(rpath); //响应文件类型
        ctx.response.body = await fs.readFile(fp); //读取文件内容 传给 响应体
      } else {
        ctx.response.status = 404; //如果文件不存在则返回 404
      }
    } else {
      await next(); //等待下一个异步函数执行
    }
  };
}

module.exports = staticFiles; //暴露出 staticFiles 方法
```

```ts
// 5.index.js
module.exports = {
  'GET /': async (ctx, next) => {
    ctx.render('index.html', {
      title: 'Welcome',
    });
  },
};
```

```ts
// 6.signin.js
module.exports = {
  'POST /signin': async (ctx, next) => {
    var email = ctx.request.body.email || '',
      password = ctx.request.body.password || '';
    if (email === 'admin@example.com' && password === '123456') {
      console.log('signin ok!');
      ctx.render('signin-ok.html', {
        title: 'Sign In OK',
        name: 'Mr Node',
      });
    } else {
      console.log('signin failed!');
      ctx.render('signin-failed.html', {
        title: 'Sign In Failed',
      });
    }
  },
};
// 其他 html 模板文件
// base.html
// index.html
// signin-failed.html
// signin-ok.html
```

## mysql 访问数据库

## 使用 Sequelize 1.安装依赖

```ts
/**
 * 安装 mysql 数据库驱动
 * npm install mysql
 *
 * 安装 sequelize 可简化对 mysql 数据库的操作
 * npm install sequelize -S
 *
 * Sequelize 是一个基于 promise 的 Node.js ORM, 目前支持 Postgres, MySQL, SQLite 和 Microsoft SQL Server.
 * 它具有强大的事务支持, 关联关系, 读取和复制等功能.
 *
 * npm install --save pg pg-hstore
 * npm install --save mysql2
 * npm install --save sqlite3
 * npm install --save tedious // MSSQL
 *
 * 对象关系映射
 * ORM 技术 Object-Relational Mapping Object-Relational Mapping 返回 json 对象无需再做低层处理
 */
```

- 创建数据库(SQL 语句)

```sql
use test;
create table pets (
id varchar(50) not null,
name varchar(100) not null,
gender bool not null,
birth varchar(10) not null,
createdAt bigint not null,
updatedAt bigint not null,
version bigint not null,
primary key (id)
) engine=innodb;
```

- Sequelize 简单实用案例

```ts
const Sequelize = require('sequelize');
const sequelize = new Sequelize('test', 'root', 'root', {
  host: 'localhost',
  //Dialect needs to be explicitly supplied as of v4.0.0 报错解决
  dialect: 'mysql', // pick one of 'mysql','sqlite','postgres','mssql',

  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000,
  },

  // 仅限 SQLite
  storage: 'path/to/database.sqlite',

  // 请参考 Querying - 查询 操作符 章节
  operatorsAliases: false,
});

const Pet = sequelize.define('pet', {
  id: {
    type: Sequelize.STRING(50),
    primaryKey: true,
  },
  name: Sequelize.STRING(100),
  gender: Sequelize.BOOLEAN,
  birth: Sequelize.STRING(10),
  createdAt: Sequelize.BIGINT,
  updatedAt: Sequelize.BIGINT,
  version: Sequelize.BIGINT,
});

var now = Date.now();

sequelize
  .sync()
  .then(() =>
    Pet.create({
      id: 'g-' + now,
      name: 'Gaffey',
      gender: false,
      birth: '2007-07-07',
      createdAt: now,
      updatedAt: now,
      version: 0,
    })
  )
  .then((jane) => {
    console.log('jane', jane, jane.toJSON());
  });
```

- 教程中的使用案例 await 可直接返回结果

```ts
/**
 * 如果要更新数据，可以对查询到的实例调用 save()方法：
 * 如果要删除数据，可以对查询到的实例调用 destroy()方法：
 */

const Sequelize = require('sequelize');

const config = require('./config');

console.log('init sequelize...');

//对链接数据库信息进行配置
var sequelize = new Sequelize(
  config.database,
  config.username,
  config.password,
  {
    host: config.host,
    dialect: 'mysql',
    pool: {
      max: 5,
      min: 0,
      idle: 30000,
    },
  }
);

//定义或创建一个 pet 的数据表
var Pet = sequelize.define(
  'pet',
  {
    id: {
      type: Sequelize.STRING(50),
      primaryKey: true,
    },
    name: Sequelize.STRING(100),
    gender: Sequelize.BOOLEAN,
    birth: Sequelize.STRING(10),
    createdAt: Sequelize.BIGINT,
    updatedAt: Sequelize.BIGINT,
    version: Sequelize.BIGINT,
  },
  {
    timestamps: false, //关闭 Sequelize 的自动添加 timestamp 的功能
  }
);

var now = Date.now(); //获取一个时间戳

Pet.create({
  id: 'g-' + now,
  name: 'Gaffey',
  gender: false,
  birth: '2007-07-07',
  createdAt: now,
  updatedAt: now,
  version: 0,
})
  .then(function (p) {
    console.log('created.' + JSON.stringify(p)); //打印出一个 json 字符串
  })
  .catch(function (err) {
    console.log('failed: ' + err);
  });

(async () => {
  var dog = await Pet.create({
    id: 'd-' + now,
    name: 'Odie',
    gender: false,
    birth: '2008-08-08',
    createdAt: now,
    updatedAt: now,
    version: 0,
  }); //await 可直接返回结果
  console.log('created: ' + JSON.stringify(dog));
})();

(async () => {
  //对数据进行查询
  var pets = await Pet.findAll({
    where: {
      name: 'Gaffey',
    },
  });
  console.log(`find ${pets.length} pets:`);
  for (let p of pets) {
    //循环遍历查询结果
    console.log(JSON.stringify(p));
    console.log('update pet...');
    p.gender = true;
    p.updatedAt = Date.now();
    p.version++;
    await p.save(); //对记录进行更新
    if (p.version === 3) {
      await p.destroy(); //对记录进行删除
      console.log(`${p.name} was destroyed.`);
    }
  }
})();

// 运行 nodejs 打印出来的 SQL 语句
// Executing (default): INSERT INTO `pets` (`id`,`name`,`gender`,`birth`,`createdAt`,`updatedAt`,`version`) VALUES ('g-1471961204219','Gaffey',false,'2007-07-07',1471961204219,1471961204219,0);
```

- Model

```ts
/**
 * 我们把通过 sequelize.define()返回的 Pet 称为 Model，它表示一个数据模型。
 * 通过 Pet.findAll()返回的一个或一组对象称为 Model 实例，每个实例都可以直接通过 JSON.stringify 序列化为 JSON 字符串。
 * JSON 对象相比，多了一些由 Sequelize 添加的方法，比如 save()和 destroy()。调用这些方法我们可以执行更新或者删除操作。
 */
```

- 建立 Model

```ts
/**
 * 统一主键，名称必须是 id，类型必须是 STRING(50)
 * 主键可以自己指定，也可以由框架自动生成（如果为 null 或 undefined）
 * 所有字段默认为 NOT NULL，除非显式指定
 * 统一 timestamp 机制，每个 Model 必须有 createdAt、updatedAt 和 version，分别记录创建时间、修改时间和版本号。
 * 其中，createdAt 和 updatedAt 以 BIGINT 存储时间戳，最大的好处是无需处理时区，排序方便。version 每次修改时自增
 */
```

## mocha 单元测试

```ts
/**
 * mocha 是 JavaScript 的一种单元测试框架，既可以在浏览器环境下运行，也可以在 Node.js 环境下运行。
 */
```

- 编写测试 1.一个简单的求和函数测试案例 及其原理

```ts
// hello.js 一个求和函数
module.exports = function (...rest) {
  var sum = 0;
  for (let n of rest) {
    sum += n;
  }
  return sum;
};

//对这个函数进行测试 使用 Node.js 提供的 assert 模块进行断言
const assert = require('assert');
const sum = require('./hello');

assert.strictEqual(sum(), 0);
assert.strictEqual(sum(1), 1);
assert.strictEqual(sum(1, 2), 3);
assert.strictEqual(sum(1, 2, 3), 6);
```

- 安装 mocha 的依赖包

```ts
// npm install mocha -D
```

- 编写测试程序 hello-test.js 内容如下：

```ts
/**
 * 这里我们使用 mocha 默认的 BDD-style 的测试。describe 可以任意嵌套，以便把相关测试看成一组测试。
 */
const assert = require('assert');

const sum = require('../hello');

describe('#hello.js', () => {
  describe('#sum()', () => {
    //每个it("name", function() {...})就代表一个测试
    it('sum() should return 0', () => {
      assert.strictEqual(sum(), 0);
    });

    it('sum(1) should return 1', () => {
      assert.strictEqual(sum(1), 1);
    });

    it('sum(1, 2) should return 3', () => {
      assert.strictEqual(sum(1, 2), 3);
    });

    it('sum(1, 2, 3) should return 6', () => {
      assert.strictEqual(sum(1, 2, 3), 6);
    });
  });
});
```

- 用 mocha 运行测试了

```ts
// hello.js 文件编写
console.log('init hello.js...');

// a simple function:
// > sum(1, 2, 3)
// 6
module.exports = function (...rest) {
  var sum = 0;
  for (let n of rest) {
    sum += n;
  }
  return sum;
};
```

```ts
// hello-test.js 文件编写
// 在测试前初始化资源，测试后释放资源是非常常见的。
// mocha 提供了 before、after、beforeEach 和 afterEach 来实现这些功能。
// 实例中输出是这样的
// before:
// beforeEach:
// √ sum() should return 0
// afterEach.
// beforeEach:
// √ sum(1) should return 1
// afterEach.
// beforeEach:
// √ sum(1, 2) should return 3
// afterEach.
// beforeEach:
// √ sum(1, 2, 3) should return 6
// afterEach.
// after.

const assert = require('assert');

const sum = require('../hello');

describe('#hello.js', () => {
  describe('#sum()', () => {
    before(function () {
      console.log('before:');
    });

    after(function () {
      console.log('after.');
    });

    beforeEach(function () {
      console.log('  beforeEach:');
    });

    afterEach(function () {
      console.log('  afterEach.');
    });

    it('sum() should return 0', () => {
      assert.strictEqual(sum(), 0);
    });

    it('sum(1) should return 1', () => {
      assert.strictEqual(sum(1), 1);
    });

    it('sum(1, 2) should return 3', () => {
      assert.strictEqual(sum(1, 2), 3);
    });

    it('sum(1, 2, 3) should return 6', () => {
      assert.strictEqual(sum(1, 2, 3), 6);
    });
  });
});
```

- mocha 默认会执行 test 目录下的所有测试，不要去改变默认目录。

```ts
/**
 * 在 package.json 文件中配置如下
 * 运行 npm test
  */
"devDependencies": {
"mocha": "^5.2.0"
},
"scripts": {
"test": "mocha"
},

```

- 异步测试

```ts
// 1.编写 hello.js 并对外暴露一个异步函数
console.log('init hello.js...');
const fs = require('mz/fs');
// 输出一个简单的异步函数
module.exports = async () => {
  let expression = await fs.readFile('./data.txt', 'utf-8'); //异步读取文本内容
  let fn = new Function('return ' + expression);
  let r = fn();
  console.log(`Calculate: ${expression} = ${r}`);
  return r; //返回 15
};
```

```ts
// 2.编写 await-test.js 异步测试
const assert = require('assert');

const hello = require('../hello');

describe('#async hello', () => {
  describe('#asyncCalculate()', () => {
    // 进行异步测试需要传入 done 参数 复杂写法
    it('#async with done', (done) => {
      (async function () {
        try {
          let r = await hello();
          assert.strictEqual(r, 15);
          done();
        } catch (err) {
          done(err);
        }
      })();
    });

    //进行异步测试的简洁写法 推荐
    it('#async function', async () => {
      let r = await hello();
      assert.strictEqual(r, 15);
    });

    //进行同步测试

    it('#sync function', () => {
      assert(true);
    });
  });
});
```

- Http 测试

```ts
/**
 * 1.安装测试模块 supertest
 * npm i supertest -D
 * 利用 mocha 的异步测试，配合 supertest，我们可以用简单的代码编写端到端的 HTTP 自动化测试
 */
```

- 编写 http 测试用例

```ts
// app.js
const Koa = require('koa');

const app = new Koa();

app.use(async (ctx, next) => {
  const start = new Date().getTime();
  await next();
  const ms = new Date().getTime() - start;
  //打印出请求方法+请求连接+响应时间
  console.log(`${ctx.request.method} ${ctx.request.url}: ${ms}ms`);
  ctx.response.set('X-Response-Time', `${ms}ms`);
});

app.use(async (ctx, next) => {
  var name = ctx.request.query.name || 'world';
  ctx.response.type = 'text/html';
  ctx.response.body = `<h1>Hello, ${name}!</h1>`; //把连接参数通过响应文本输出
});

module.exports = app; //暴露出 app 方便添加测试
```

```ts
// start.js
//用于启动文本运用
const app = require('./app');

app.listen(3000);
console.log('app started at port 3000...');
```

```ts
// app-test.js
//Http 测试异步测试文件
const request = require('supertest'),
  app = require('../app'); //引入 web 服务程序

describe('#test koa app', () => {
  let server = app.listen(9900); //让app实例监听在9900端口上，并且获得返回的server实例。

  describe('#test server', () => {
    it('#test GET /', async () => {
      let res = await request(server) //构造一个GET请求，发送给koa的应用，然后获得响应
        .get('/')
        //用supertest提供的expect()更方便地断言响应的HTTP代码、返回内容和HTTP头。断言HTTP头时可用使用正则表达式
        .expect('Content-Type', /text\/html/)
        .expect(200, '<h1>Hello, world!</h1>');
    });

    it('#test GET /path?name=Bob', async () => {
      let res = await request(server) //构造一个GET请求，发送给koa的应用，然后获得响应
        .get('/path?name=Bob')
        .expect('Content-Type', /text\/html/)
        .expect(200, '<h1>Hello, Bob!</h1>'); //当所有测试运行结束后，app实例会自动关闭，无需清理。
    });
  });
});
```

## WebSocket

```ts
/**
 * 什么是 WebSocket
 * 1.WebSocket 是 HTML5 新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，
 * 比如说，服务器可以在任意时刻发送消息给浏览器。
 * 2.HTTP 协议其实也能实现，比如用轮询或者 Comet
 * 3.HTML5 推出了 WebSocket 标准，让浏览器和服务器之间可以建立无限制的全双工通信，任何一方都可以主动发消息给对方。
 *
 * 4.WebSocket 协议
 * WebSocket 连接必须由浏览器发起，因为请求协议是一个标准的 HTTP 请求
 *
 *
 * GET ws://localhost:3000/ws/chat HTTP/1.1
 * Host: localhost
 * Upgrade: websocket
 * Connection: Upgrade
 * Origin: http://localhost:3000
 * Sec-WebSocket-Key: client-random-string
 * Sec-WebSocket-Version: 13
 *
 * 该请求和普通的 HTTP 请求有几点不同：
 * 1.GET 请求的地址不是类似/path/，而是以 ws://开头的地址；
 * 2.请求头 Upgrade: websocket 和 Connection: Upgrade 表示这个连接将要被转换为 WebSocket 连接；
 * 3.Sec-WebSocket-Key 是用于标识这个连接，并非用于加密数据；
 * 4.Sec-WebSocket-Version 指定了 WebSocket 的协议版本。
 *
 * 服务器如果接受该请求，就会返回如下响应：
 * 该响应代码 101 表示本次连接的 HTTP 协议即将被更改，更改后的协议就是 Upgrade: websocket 指定的 WebSocket 协议。
 * 版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用 WebSocket 的 API，就不需要关心这些。
 *
 * 5.WebSocket 实现原理
 * 实际上 HTTP 协议是建立在 TCP 协议之上的，TCP 协议本身就实现了全双工通信，但是 HTTP 协议的请求－应答机制限制了全双工通信。
 * WebSocket 连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用 HTTP 协议了，直接互相发数据吧。
 * 浏览器用 wss://xxx 创建 WebSocket 连接时，会先通过 HTTPS 创建安全的连接
 * 然后，该 HTTPS 连接升级为 WebSocket 连接，底层通信走的仍然是安全的 SSL/TLS 协议。
 *
 *
 * 6.服务器端实现 WebSocket
 * 由于 WebSocket 是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。
 * Node.js 本身支持的协议包括 TCP 协议和 HTTP 协议，要支持 WebSocket 协议，需要对 Node.js 提供的 HTTPServer 做额外的开发。
 * 已经有若干基于 Node.js 的稳定可靠的 WebSocket 实现，我们直接用 npm 安装使用即可。
 *
 */
```

- 一个简单的 WebSocket 实现案例

```ts
/**
 * 1.安装依赖
 * cnpm i ws -S
 */
// app.js 实例代码
// 导入 WebSocket 模块
const WebSocket = require('ws');

// 引用 Server 类
const WebSocketServer = WebSocket.Server;

// 实例化
const wss = new WebSocketServer({
  port: 3000, // 在 3000 端口上打开一个 WebSocket Server
});

// 如果有 WebSocket 请求接入 wws 对象可以响应 connection 事件来处理这个 WebSocket
wss.on('connection', function (ws) {
  console.log(`[SERVER] connection()`);
  ws.on('message', function (message) {
    console.log(`[SERVER] Received: ${message}`); //服务器接收到的信息
    setTimeout(() => {
      ws.send(`What's your name?`, (err) => {
        // 服务器发送信息
        if (err) {
          console.log(`[SERVER] error: ${err}`);
        }
      });
    }, 1000);
  });
});

console.log('ws server started at port 3000...');
```

```ts
// 客户端测试代码 实际代码中并不需要 仅用于测试
let count = 0;

let ws = new WebSocket('ws://localhost:3000/ws/chat');

ws.on('open', function () {
  console.log(`[CLIENT] open()`);
  ws.send('Hello!');
});

ws.on('message', function (message) {
  console.log(`[CLIENT] Received: ${message}`); // 客户端接收到的信息
  count++;
  if (count > 3) {
    ws.send('Goodbye!'); //客户端发送的信息
    ws.close();
  } else {
    setTimeout(() => {
      ws.send(`Hello, I'm Mr No.${count}!`); // 客户端发送的信息
    }, 1000);
  }
});
```

- 创建 WebSocket 连接(测试方法)

```ts
// 执行 JavaScript 代码的浏览器 Console，依次输入代码：
// 打开一个 WebSocket:
var ws = new WebSocket('ws://localhost:3000/test');
// 响应 onmessage 事件:
ws.onmessage = function (msg) {
  console.log(msg);
};
// 给服务器发送一个字符串:
ws.send('Hello!');
```

- 同源策略

```ts
/**
 * 从上面的测试可以看出，WebSocket 协议本身不要求同源策略（Same-origin Policy）
 * 也就是某个地址为http://a.com的网页可以通过WebSocket连接到ws://b.com。
 *
 * 但是，浏览器会发送 Origin 的 HTTP 头给服务器，服务器可以根据 Origin 拒绝这个 WebSocket 请求。
 * 所以，是否要求同源要看服务器端如何检查。
 */
```

## 编写聊天室

```ts
// 1.koa 和 WebSocketServer 可以共用一个端口
// 2.把 WebSocketServer 绑定到同一个端口的关键代码是先获取 koa 创建的 http.Server 的引用，再根据 http.Server 创建 WebSocketServer：
// koa app 的 listen()方法返回 http.Server:
let server = app.listen(3000);

// 创建 WebSocketServer:
let wss = new WebSocketServer({
  server: server,
});
```

- 配置反向代理

```bash
# 让 Nginx 理解该连接将使用 WebSocket 协议
server {
listen 80;
server_name localhost;

    # 处理静态资源文件:
    location ^~ /static/ {
        root /path/to/ws-with-koa;
    }

    # 处理WebSocket连接:
    location ^~ /ws/ {
        proxy_pass         http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header   Upgrade $http_upgrade;
        proxy_set_header   Connection "upgrade";
    }

    # 其他所有请求:
    location / {
        proxy_pass       http://127.0.0.1:3000;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

}

```

## REST

```ts
/**
 * 一.什么是 REST
 * 1.REST 就是一种设计 API 的模式。
 * 2.通过 API 操作数据，可以极大地把前端和后端的代码隔离，使得后端代码易于测试，前端代码编写更简单。
 * 3.把网页视为一种客户端，是 REST 架构可扩展的一个关键。
 */
```

- 一个简单的 REST 实例

```ts
/**
 * 1.REST API 规范(并不是强制要求)
 * REST 请求仍然是标准的 HTTP 请求，但是，除了 GET 请求外，POST、PUT 等请求的 body 是 JSON 数据格式
 * 请求的 Content-Type 为 application/json；
 * REST 响应返回的结果是 JSON 数据格式，因此，响应的 Content-Type 也是 application/json。
 *
 * 2.接口路由
 * 获取所有 Product 的 URL GET /api/products
 * 获取某个指定的 Product，例如，id 为 123 的 Product GET /api/products/123
 * 新建一个 Product 使用 POST 请求，JSON 数据包含在 body 中 POST /api/products
 * 更新一个 Product 使用 PUT 请求，例如，更新 id 为 123 的 Product PUT /api/products/123
 * 删除一个 Product 使用 DELETE 请求，例如，删除 id 为 123 的 Product DELETE /api/products/123
 * 资源还可以按层次组织 获取商品的评论 GET /api/products/123/reviews
 * 参数限制返回的结果集 GET /api/products/123/reviews?page=2&size=10&sort=time
 *
 */
```

- 用法实例

```ts
// api.js
var products = [
  {
    name: 'iPhone',
    price: 6999,
  },
  {
    name: 'Kindle',
    price: 999,
  },
];

module.exports = {
  'GET /api/products': async (ctx, next) => {
    ctx.response.type = 'application/json';
    ctx.response.body = {
      products: products,
    };
  },

  'POST /api/products': async (ctx, next) => {
    var p = {
      name: ctx.request.body.name,
      price: ctx.request.body.price,
    };
    products.push(p);
    ctx.response.type = 'application/json';
    ctx.response.body = p;
  },
};
```

```ts
// app.js
const Koa = require('koa');

const bodyParser = require('koa-bodyparser');

const controller = require('./controller');

const app = new Koa();

// log request URL:
app.use(async (ctx, next) => {
  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
  await next();
});

// parse request body:
app.use(bodyParser());

// add controller:
app.use(controller());

app.listen(3000);
console.log('app started at port 3000...');
```

```ts
// controller.js
const fs = require('fs');

// add url-route in /controllers:

function addMapping(router, mapping) {
  for (var url in mapping) {
    if (url.startsWith('GET ')) {
      var path = url.substring(4);
      router.get(path, mapping[url]);
      console.log(`register URL mapping: GET ${path}`);
    } else if (url.startsWith('POST ')) {
      var path = url.substring(5);
      router.post(path, mapping[url]);
      console.log(`register URL mapping: POST ${path}`);
    } else if (url.startsWith('PUT ')) {
      var path = url.substring(4);
      router.put(path, mapping[url]);
      console.log(`register URL mapping: PUT ${path}`);
    } else if (url.startsWith('DELETE ')) {
      var path = url.substring(7);
      router.del(path, mapping[url]);
      console.log(`register URL mapping: DELETE ${path}`);
    } else {
      console.log(`invalid URL: ${url}`);
    }
  }
}

function addControllers(router, dir) {
  fs.readdirSync(__dirname + '/' + dir)
    .filter((f) => {
      return f.endsWith('.js');
    })
    .forEach((f) => {
      console.log(`process controller: ${f}...`);
      let mapping = require(__dirname + '/' + dir + '/' + f);
      addMapping(router, mapping);
    });
}

module.exports = function (dir) {
  let controllers_dir = dir || 'controllers',
    router = require('koa-router')();
  addControllers(router, controllers_dir);
  return router.routes();
};
```

## 错误处理机制

```ts
/**
 * 1.如何组织 URL
 * 一个简单的方法是通过固定的前缀区分。
 * 例如，/static/开头的 URL 是静态资源文件，
 * 类似的，/api/开头的 URL 就是 REST API，
 * 其他 URL 是普通的 MVC 请求。
 *
  */
// 2.错误信息是一个 JSON 字符串，例如：
{
  "code": "10000",
  "message": "Bad email address"
}
```

## MVVM

```ts
/**
 * 常用 api
 * 1.__dirname 根目录
 * 2.node -v # 查看 node 的版本
 * 3.npm -v # 查看 npm 的版本
 * 4.node --use_strict js 文件名 # Node 在执行该 JavaScript 时将使用严格模式
 */
// 以同步的方式读取目录下的文件 并 过滤指定后缀名文件
fs.readdirSync(__dirname + '/' + dir).filter((f) => {
  console.log('f', f, __dirname);
  return f.endsWith('.js');
});
```

## 模块化

```ts
/**
 * 概念：
 * 1.CommonJS 规范：
 * 在这个规范下，每个.js 文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突
 * module.exports = variable; -一个模块想要对外暴露变量（函数也是变量）
 * var ref = require('module_name')-就拿到了引用模块的变量。
 *
 * 注意：
 * 1.文件不能命名为 node.js 要不然程序无法执行
 * 2.这个 hello.js 文件就是一个模块，模块的名字就是文件名（去掉.js 后缀）
 * 所以 hello.js 文件就是名为 hello 的模块。
 *
 */
```

- NodeJS 模块化实现原理

```ts
// Node.js 加载了 hello.js 后 使用闭包原理使模板间的同名变量不冲突
(function () {
  // 读取的 hello.js 代码:
  var s = 'Hello';
  var name = 'world';

  console.log(s + ' ' + name + '!');
  // hello.js代码结束
})();

// 模块的输出 module.exports
// 准备 module 对象:
var module = {
  id: 'hello',
  exports: {},
};
var load = function (module) {
  // 读取的 hello.js 代码:
  function greet(name) {
    console.log('Hello, ' + name + '!');
  }

  module.exports = greet;
  return module.exports; // hello.js代码结束并输出暴露的模块
};
var exported = load(module);
// 保存 module:
save(module, exported);

// 默认情况下，Node 准备的 exports 变量和 module.exports 变量实际上是同一个变量，并且初始化为空对象{}
// 给 exports 赋值是无效的，因为赋值后，module.exports 仍然是空对象{}。
var load = function (exports, module) {
  // hello.js 的文件内容

  // load 函数返回:
  return module.exports;
};

var exported = load(module.exports, module);

// 结论
// 直接对 module.exports 赋值，可以应对任何情况
```

## 单词

```pug
node 节点
strict 严格的
visual 视觉的
studio 工作室
code 代码
automator 自动机
module 模块
launch 发射 开始运用程序
require 需求
common 常见的 普通的 公共的
global 全局的 全球的
process 过程 进程
platform 平台
tick 打上勾 一瞬间
arch 拱门 结构
buffer 缓冲区
directory 目录
stream 流动
stdin 标准输入流
stdout 标准输出流
chunk 块
request 请求
response 响应
parse 解析
protocol 协议
slashes 斜线
auth 作者
resolve 决定
crypto 密码 秘密成员
digest 消化
express 表达
plain 平原
promise 承诺
middleware 中间件
ware 制品
render 给予 提供
escape 逃脱 逃跑
environment 环境
exec 执行程序
sequelize 续集
transaction 交易
pool 水池
pet 宠物
define 定义
gender 性别
entity 实体
hooks 钩子
assert 断言
describe 描述
launch 发射
expect 期待
comet 彗星
upgrade 升级
accept 接受
socket 插座
received 收到
rest 休息
```
