## 系统和文件的前置知识

- 权限位 mode

```ts
/**
 * 权限项	读	写	执行
 * 字符表示 r	 w	 x
 * 数字表示 4   2	 1
 * 不具备权限为 0
 * 权限参数 mode 主要针对 Linux 和 Unix 操作系统，Window 的权限默认是可读、可写、不可执行，
 * 所以权限位数字表示为 0o666，转换十进制表示为 438。
 * d 开头代表文件夹，- 开头的代表文件
 * drwxr-xr-x 当前用户、用户所属组和其他用户的权限位
 */
```

- 标识位 flag

```ts
/**
 * r：读取
 * w：写入
 * s：同步 +：增加相反操作
 * x：排他方式
 *
 * 标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等
 * r 读取文件，如果文件不存在则抛出异常。
 * r+读取并写入文件，如果文件不存在则抛出异常。
 * rs 读取并写入文件，指示操作系统绕开本地文件系统缓存。
 * w 写入文件，文件不存在会被创建，存在则清空后写入。
 * wx 写入文件，排它方式打开。
 * w+读取并写入文件，文件不存在则创建文件，存在则清空后写入。
 * wx+和 w+ 类似，排他方式打开。
 * a 追加写入，文件不存在则创建文件。
 * ax 与 a 类似，排他方式打开。
 * a+读取并追加写入，不存在则创建。
 * ax+与 a+ 类似，排他方式打开。
 */
```

- 文件描述符 fd 追踪资源

```ts
/**
 * 在 NodeJS 中，每操作一个文件，文件描述符是递增的，文件描述符一般从 3 开始，
 * 因为前面有 0、1、2 三个比较特殊的描述符，
 * 分别代表 process.stdin（标准输入）、
 * process.stdout（标准输出）
 * 和 process.stderr（错误输出）。
 */
```

## 文件操作的基本方法

```ts
/**
 * 文件数据直接放在内存中操作，如读取、写入、拷贝和追加，由于计算机的内存容量有限，对文件操作需要考虑性能
 */
```

- 同步读取方法 readFileSync

```ts
const fs = require('fs');
try {
  let buf = fs.readFileSync('1.txt');
  let data = fs.readFileSync('1.txt', 'utf8');
  console.log(buf); // <Buffer 48 65 6c 6c 6f>
  console.log(data); // Hello
} catch (err) {
  // 处理异常。
  console.log(err); // Hello
}
```

- 异步读取方法 readFile

```ts
const fs = require('fs');
fs.readFile('1.txt', 'utf8', (err, data) => {
  console.log(err); // null
  console.log(data); // Hello
});
```

- 同步写入方法 writeFileSync (如果目标文件不存在则创建文件)

```ts
const fs = require('fs');

try {
  fs.writeFileSync('2.txt', 'Hello world!');
  let data = fs.readFileSync('2.txt', 'utf8');
  console.log(data);
} catch (err) {
  // 异常处理
  console.log('errorInfo' + data);
}
```

- 异步写入方法 writeFile (如果目标文件不存在则创建文件)

```ts
const fs = require('fs');

fs.writeFile('2.txt', 'Hello world', (err) => {
  if (!err) {
    fs.readFile('2.txt', 'utf8', (err, data) => {
      if (!err) {
        console.log(data);
      }
    });
  }
});
```

- 同步追加写入方法 appendFileSync (如果目标文件不存在则创建文件)

```ts
const fs = require('fs');

try {
  fs.appendFileSync('2.txt', '我是追加的内容!');
  let data = fs.readFileSync('2.txt', 'utf8');
  console.log(data);
} catch (err) {
  console.log(err);
}
```

- 异步追加写入方法 appendFile (如果目标文件不存在则创建文件)

```ts
const fs = require('fs');

fs.appendFile('2.txt', ' 我是追加的内容', (err) => {
  if (!err) {
    fs.readFile('2.txt', 'utf8', (err, data) => {
      if (!err) {
        console.log(data);
      }
    });
  }
});
```

- 同步拷贝写入方法 copyFileSync (如果目标文件不存在则创建文件)

```ts
/** 如果文件存在则会覆盖原来文件的内容 如果不存在则重新创建  */
const fs = require('fs');

try {
  fs.copyFileSync('1.txt', '5.txt');
  let data = fs.readFileSync('5.txt', 'utf8');
  console.log(data);
} catch (err) {
  console.log(err);
}
```

- 异步拷贝写入方法 copyFile

```ts
/** 注意回调是没有参数的  */
fs.copyFile('3.txt', '4.txt', () => {
  fs.readFile('4.txt', 'utf8', (err, data) => {
    if (!err) {
      console.log(data);
    }
  });
});
```

- 异步打开文件 open

```ts
const fs = require('fs');

fs.open('4.txt', 'r', (err, fd) => {
  if (!err) {
    console.log(fd); // 3
    fs.open('5.txt', 'r', (err, fd) => {
      if (!err) {
        console.log(fd); // 4
      }
    });
  }
});
```

- 关闭文件 close

```ts
const fs = require('fs');

fs.open('5.txt', 'r', (err, fd) => {
  if (!err) {
    fs.close(fd, (err) => {
      if (!err) {
        console.log('关闭成功');
      }
    });
  }
});
```

- 读取文件 read

```ts
/**
 * 一般针对于文件太大，无法一次性读取全部内容到缓存中或文件大小未知的情况，都是多次读取到 Buffer 中。
 * read 方法中有六个参数：
 * 1.fd：文件描述符，需要先使用 open 打开；
 * 2.buffer：要将内容读取到的 Buffer；
 * 3.offset：整数，向 Buffer 写入的初始位置；
 * 4.length：整数，读取文件的长度；
 * 5.position：整数，读取文件初始位置；
 * 6.callback：回调函数，有三个参数
 *   err（错误）
 *   bytesRead（实际读取的字节数）
 *   buffer（被写入的缓存区对象），读取执行完成后执行
 */

const fs = require('fs');
let buf = Buffer.alloc(6);

// 打开文件
fs.open('1.txt', 'r', (err, fd) => {
  // 读取文件
  fs.read(fd, buf, 0, 3, 0, (err, bytesRead, buffer) => {
    if (!err) {
      console.log(bytesRead);
      console.log(buffer);

      // 继续读取
      fs.read(fd, buf, 3, 3, 3, (err, bytesRead, buffer) => {
        if (!err) {
          console.log(bytesRead);
          console.log(buffer);
          console.log(buffer.toString());
        }
      });
    }
  });
});

// 3
// <Buffer e4 bd a0 00 00 00>

// 3
// <Buffer e4 bd a0 e5 a5 bd>
// 你好
```

- 同步磁盘缓存 fsync 配合 写入文件 write 使用

```ts
/**
 * 在使用 write 方法向文件写入数据时，由于不是一次性写入，
 * 所以最后一次写入在关闭文件之前应先同步磁盘缓存，fsync 方法将在后面配合 write 一起使用。
 * fd：文件描述符，需要先使用 open 打开；
 * buffer：存储将要写入文件数据的 Buffer；
 * offset：整数，从 Buffer 读取数据的初始位置；
 * length：整数，读取 Buffer 数据的字节数；
 * position：整数，写入文件初始位置；
 * callback：回调函数，有三个参数
    err（错误），
    bytesWritten（实际写入的字节数），
    buffer（被读取的缓存区对象），写入完成后执行。
 */
// 1.txt，原内容为 “你好”

const fs = require('fs');
let buf = Buffer.from('你还好吗');

// 打开文件
fs.open('1.txt', 'r+', (err, fd) => {
  if (!err) {
    // 读取 buf 向文件写入数据
    fs.write(fd, buf, 3, 6, 3, (err, bytesWritten, buffer) => {
      // 同步磁盘缓存
      fs.fsync(fd, (err) => {
        // 关闭文件
        fs.close(fd, (err) => {
          if (!err) {
            console.log('关闭文件');
          }
        });
      });
    });
  }
});

// 这里为了看是否写入成功简单粗暴的使用 readFile 方法
fs.readFile('1.txt', 'utf8', (err, data) => {
  console.log(data);
});

// 你还好
```

- 针对大文件实现 copy

```ts
/**
 * 如果是一个大文件一次性写入不现实，所以需要多次读取多次写入 或未知大小
 */
// copy 方法
const fs = require('fs');
const BUFFER_SIZE = 3;
// 拷贝文件内容并写入
copy('1.txt', '7.txt', BUFFER_SIZE, () => {
  fs.readFile('7.txt', 'utf8', (err, data) => {
    // 拷贝完读取 7.txt 的内容
    console.log(data); // 你好
  });
});

function copy(src, dest, size = 16 * 1024, callback) {
  // 打开源文件
  fs.open(src, 'r', (err, readFd) => {
    // 打开目标文件
    fs.open(dest, 'w', (err, writeFd) => {
      let buf = Buffer.alloc(size);
      let readed = 0; // 下次读取文件的位置
      let writed = 0; // 下次写入文件的位置

      (function next() {
        // 读取
        fs.read(readFd, buf, 0, size, readed, (err, bytesRead) => {
          readed += bytesRead;

          // 如果度不到内容关闭文件
          console.log('bytesRead', bytesRead);
          if (!bytesRead) {
            fs.close(readFd, (err) => {
              console.log('关闭源文件');
            });
          }

          // 写入
          fs.write(writeFd, buf, 0, bytesRead, writed, (err, bytesWritten) => {
            // 如果没有内容了同步缓存，并关闭文件后执行回调
            console.log('bytesWritten', bytesWritten);
            if (!bytesWritten) {
              fs.fsync(writeFd, (err) => {
                fs.close(writeFd, (err) => {
                  return !err && callback();
                });
              });
            } else {
              writed += bytesWritten;
              // 继续读取、写入
              next();
            }
          });
        });
      })();
    });
  });
}
```

- 同步查看操作权限方法 accessSync

```ts
/**
 * 检查传入路径下的目录是否可读可写，当有操作权限的时候没有返回值，没有权限或路径非法时抛出一个 Error 对象
 */
const fs = require('fs');

try {
  fs.accessSync('a/');
  console.log('可读可写');
} catch (err) {
  console.error('不可访问');
}
```

- 异步查看操作权限方法 access

```ts
const fs = require('fs');

fs.access('a/', (err) => {
  if (err) {
    console.error('不可访问');
  } else {
    console.log('可读可写');
  }
});
```

- 同步获取 Stats 对象方法 statSync

```ts
/**
 * 文件目录的 Stats 对象存储着关于这个文件或文件夹的一些重要信息，如创建时间、
 * 最后一次访问的时间、最后一次修改的时间、文章所占字节和判断文件类型的多个方法等等。
 */

const fs = require('fs');

try {
  let statObj = fs.statSync('a/1.txt');
  console.log(statObj.size);
} catch (err) {
  console.log('errorInfo: ' + err);
}
```

- 异步获取 Stats 对象方法 stat

```ts
const fs = require('fs');

fs.stat('a/1.txt', (err, statObj) => {
  if (!err) {
    console.log(statObj.size);
  }
});
```

- 同步创建目录方法 mkdirSync

```ts
/**
 * 必须保证传入的路径前面的文件目录都存在，否则会抛出异常。
 * 如果目录已经存在也是会报错
 */
const fs = require('fs');
try {
  fs.mkdirSync('a/b');
  console.log('目录创建成功');
} catch (err) {
  console.log('errorInfo: ' + err);
}
```

- 异步创建目录方法 mkdir

```ts
const fs = require('fs');
fs.mkdir('a/b/c', (err) => {
  if (!err) {
    console.log('创建成功');
  }
});
```

- 同步读取目录方法 readdirSync

```ts
/**
 * 返回值为一个存储文件目录中成员名称的数组。
 * 如果目录不存在则报错
 */

const fs = require('fs');
try {
  let data = fs.readdirSync('a/b/c');
  console.log(data); // [ '1.txt', '2.txt', '4.txt', '5.txt', '7.txt', 'b' ]
} catch (err) {
  console.log('errorInfo: ' + err);
}
```

- 异步读取目录方法 readdir

```ts
const fs = require('fs');

fs.readdir('a/b/c', (err, data) => {
  if (!err) {
    console.log(data);
  }
});
```

- 同步删除目录方法 rmdirSync

```ts
/**
 * 删除文件目录时必须保证文件目录的路径存在，且被删除的文件目录为空，即不存在任何文件夹和文件。
 */
const fs = require('fs');
try {
  fs.rmdirSync('a/b/c');
  console.log('删除成功!');
} catch (err) {
  console.log('errorInfo: ' + err);
}
```

- 异步删除目录方法 rmdir

```ts
const fs = require('fs');

fs.rmdir('a/b/d', (err) => {
  if (!err) {
    console.log('删除成功');
  }
});
```

- 同步删除文件方法 unlinkSync

```ts
/**
 * 如果文件不存在会报错
 */
const fs = require('fs');
try {
  fs.unlinkSync('a/7.txt');
  console.log('删除成功!');
} catch (err) {
  console.log('errorInfo: ' + err);
}
```

- 异步删除文件方法 unlink

```ts
const fs = require('fs');

fs.unlink('a/5.txt', (err) => {
  if (!err) {
    console.log('删除成功');
  }
});
```

- 递归创建文件目录 —— 同步

```ts
const fs = require('fs');
const path = require('path');

// 同步创建文件目录
function mkPathSync(dirPath) {
  // path.sep 文件路径分隔符（mac 与 window 不同）
  // 转变成数组，如 ['a', 'b', 'c']
  let parts = dirPath.split(path.sep);
  for (let i = 1; i <= parts.length; i++) {
    // 重新拼接成 a a/b a/b/c
    let current = parts.slice(0, i).join(path.sep);

    // accessSync 路径不存在则抛出错误在 catch 中创建文件夹
    try {
      fs.accessSync(current);
    } catch (e) {
      fs.mkdirSync(current);
    }
  }
}

// 创建文件目录
mkPathSync(path.join('a', 'b', 'c'));
```

- 递归创建文件目录 —— 异步回调

```ts
const fs = require('fs');
const path = require('path');

function mkPathAsync(dirPath, callback) {
  // 转变成数组，如 ['a', 'b', 'c']
  let parts = dirPath.split(path.sep);
  let index = 1;

  // 创建文件夹方法
  function next() {
    // 重新拼接成 a a/b a/b/c
    let current = parts.slice(0, index).join(path.sep);
    index++;

    // 如果路径检查成功说明已经有该文件目录，则继续创建下一级
    // 失败则创建目录，成功后递归 next 创建下一级
    fs.access(current, (err) => {
      if (err) {
        fs.mkdir(current, (err) => {
          if (!err) {
            callback();
          }
        });
      } else {
        next();
      }
    });
  }
  next();
}

// 创建文件目录
mkPathAsync(path.join('a', 'b', 'c'), () => {
  console.log('创建文件目录完成');
});
```

- 异步 async/await 的实现

```ts
// 将一个异步方法转换成 Promise
function promisify(fn) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      fn.call(null, ...args, (err) => (err ? reject() : resolve()));
    });
  };
}

const fs = require('fs');
const path = require('path');

// 将 fs 中用到的方法转换成 Promise
const access = promisify(fs.access);
const mkdir = promisify(fs.mkdir);

// async/await 实现递归创建文件目录
async function mkPath(dirPath) {
  // 转变成数组，如 ['a', 'b', 'c']
  let parts = dirPath.split(path.sep);

  for (let i = 1; i <= parts.length; i++) {
    // 重新拼接成 a a/b a/b/c
    let current = parts.slice(0, i).join(path.sep);

    // accessSync 路径不存在则抛出错误在 catch 中创建文件夹

    try {
      await access(current);
    } catch (e) {
      await mkdir(current);
    }
  }
}

// 创建文件目录
mkPath(path.join('a', 'b', 'c')).then(() => {
  console.log('创建文件目录完成');
});
```

- 递归创建文件目录 —— 异步 async/await

```ts
// 将一个异步方法转换成 Promise

function test(...args) {
  console.log('args', args); // [ 1, 2, 3, 4, 5 ]
  console.log('args...', ...(args + ',')); // 1 , 2 , 3 , 4 , 5 ,
}

test(1, 2, 3, 4, 5);

function promisify(fn) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      fn.call(null, ...args, (err) => (err ? reject() : resolve()));
    });
  };
}

const fs = require('fs');
const path = require('path');

// 将 fs 中用到的方法转换成 Promise
const access = promisify(fs.access);
const mkdir = promisify(fs.mkdir);

// async/await 实现递归创建文件目录
async function mkPath(dirPath) {
  // 转变成数组，如 ['a', 'b', 'c']
  let parts = dirPath.split(path.sep);

  for (let i = 1; i <= parts.length; i++) {
    // 重新拼接成 a a/b a/b/c
    let current = parts.slice(0, i).join(path.sep);

    // accessSync 路径不存在则抛出错误在 catch 中创建文件夹

    try {
      await access(current);
    } catch (e) {
      await mkdir(current);
    }
  }
}

// 创建文件目录
mkPath(path.join('a', 'b', 'c')).then(() => {
  console.log('创建文件目录完成');
});
```

- 知识点补充：

```ts
/**
 * 一.Buffer
 * 1.可以在 TCP 流或文件系统操作等场景中处理二进制数据流。
 * 2.Buffer 属于 Global 对象，使用时不需引入，且 Buffer 的大小在创建时确定，无法调整。
 * 3.创建 Buffer 参数为创建 Buffer 的长度
 * Buffer.alloc 创建的 Buffer 是被初始化过的，即 Buffer 的每一项都用 00 填充
 * Buffer.allocUnsafe 创建的 Buffer 并没有经过初始化，在内存中只要有闲置的 Buffer 就直接 “抓过来” 使用。
 * Buffer.allocUnsafe 创建 Buffer 使得内存的分配非常快，但已分配的内存段可能包含潜在的敏感数据，有明显性能优势的同时又是不安全的，所以使用需格外 “小心”。
 * 4.创建的 Buffer 可以通过 toString 方法直接指定编码进行转换，默认编码为 UTF-8。
 * 5.Buffer 为引用类型
 * 6.Buffer.from 支持三种传参方式：
 *   第一个参数为字符串，第二个参数为字符编码，如 ASCII、UTF-8、Base64 等等。
 *   传入一个数组，数组的每一项会以十六进制存储为 Buffer 的每一项。
 *   传入一个 Buffer，会将 Buffer 的每一项作为新返回 Buffer 的每一项。
 *
 * 注意：
 * 1.在 NodeJS 中不支持 GB2312 编码，默认支持 UTF-8，在 GB2312 中，一个汉字占两个字节，而在 UTF-8 中，一个汉字占三个字节，所以上面 “你好” 的 Buffer 为 6 个十六进制数组成。
 * 2.apply 接受的是数组参数，call 接受的是连续参数。
 * 3.判断文件是否存在 使用 fs.stat() or fs.access() 代替。fs.exists()
 */
```

- 单词

```pug
opaque 不透明的
buffer 缓冲区
dirent 目录项
device 装置
character 性格 字母
stream 流动
mode 方式
birth 出生
access 入口 接近
constant 常数 常量
append 追加
mark 记号 评分
alloc 分配
unsafe 不安全的
stats 统计数据
separate 分离
```
