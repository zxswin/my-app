## CommonJs 的实现原理

```ts
/**
 * CommonJS的核心思想是通过rquire方法来同步加载依赖的其他模块，通过module.exports到处需要暴露的接口。
 */
```

- Module 对象

```ts
/**
 * Node内部提供了一个 Mudule构建函数。所有模块都是Module的实例。
 * require 的源码在 Node 的 lib/module.js 文件。
 * 
 * module.id 模块的识别符，通常是带有绝对路径的模块文件名。
 * module.filename 模块的文件名，带有绝对路径。
 * module.loaded 返回一个布尔值，表示模块是否已经完成加载。
 * module.parent 返回一个对象，表示调用该模块的模块。
 * module.children 返回一个数组，表示该模块要用到的其他模块。
 * module.exports 表示模块对外输出的值


 */

function Module(id, parent) {
  this.id = id;
  this.exports = {};
  this.parent = parent;
  this.filename = null;
  this.loaded = false;
  this.children = [];
}
module.exports = Module;
var module = new Module(filename, parent);

var a = require('./a.js');
// module.id:  /Users/danlan/workspace/node-stu/ree/a.js
// module.exports:  {}
// module.parent:  Module {
//   id: '.',
//   exports: {},
//   parent: null,
//   filename: '/Users/danlan/workspace/node-stu/ree/b.js',
//   loaded: false,
//   children:
//    [ Module {
//        id: '/Users/danlan/workspace/node-stu/ree/a.js',
//        exports: {},
//        parent: [Circular],
//        filename: '/Users/danlan/workspace/node-stu/ree/a.js',
//        loaded: false,
//        children: [],
//        paths: [Array] } ],
//   paths:
//    [ '/Users/danlan/workspace/node-stu/ree/node_modules',
//      '/Users/danlan/workspace/node-stu/node_modules',
//      '/Users/danlan/workspace/node_modules',
//      '/Users/danlan/node_modules',
//      '/Users/node_modules',
//      '/node_modules' ] }
// module.filename:  /Users/danlan/workspace/node-stu/ree/a.js
// module.loaded:  false
// module.children:  []
// module.paths:  [ '/Users/danlan/workspace/node-stu/ree/node_modules',
//   '/Users/danlan/workspace/node-stu/node_modules',
//   '/Users/danlan/workspace/node_modules',
//   '/Users/danlan/node_modules',
//   '/Users/node_modules',
//   '/node_modules' ]
```

- 模块实例的 require 方法

```ts
/**
 * 每个模块实例都有一个 require 方法。
 * require 并不是全局命令，而是每个模块提供的一个内部方法，也就是说，只有在模块内部才能使用require命令
 *
 * 检查 Module._cache，是否在缓存中有指定的模块，如果模块已经在缓存中，就从缓存取出。
 * 如果没有判断是否为内置模块，如果是内置模块就返回内置模块。
 * 如果缓存之中没有就会创建一个新的Moudle实例，将它保存到缓存中。
 * 加载模块
 * 如果加载/解析过程报错，就从缓存删除该模块
 * 返回该模块的 module.exports
 *
 */
Module.prototype.require = function (path) {
  return Module._load(path, this);
};

// require 其实内部调用 Module._load 方法。

// 下面来看 Module._load 的源码。

Module._load = function (request, parent, isMain) {
  //  计算绝对路径
  var filename = Module._resolveFilename(request, parent);

  //  第一步：如果有缓存，取出缓存
  var cachedModule = Module._cache[filename];
  if (cachedModule) {
    return cachedModule.exports;
  }

  // 第二步：是否为内置模块
  if (NativeModule.exists(filename)) {
    return NativeModule.require(filename);
  }

  // 第三步：生成模块实例，存入缓存
  var module = new Module(filename, parent);
  Module._cache[filename] = module;

  // 第四步：加载模块
  try {
    module.load(filename);
    hadException = false;
  } finally {
    if (hadException) {
      delete Module._cache[filename];
    }
  }

  // 第五步：输出模块的exports属性
  return module.exports;
};
```

- 模块的绝对路径

```ts
/**
 *
 */
// 下面是 Module._resolveFilename() 方法的源码。
Module._resolveFilename = function (request, parent) {
  // 第一步：如果是内置模块，不含路径返回
  if (NativeModule.exists(request)) {
    return request;
  }

  // 第二步：确定所有可能的路径
  var resolvedModule = Module._resolveLookupPaths(request, parent);
  var id = resolvedModule[0];
  var paths = resolvedModule[1];

  // 第三步：确定哪一个路径为真
  var filename = Module._findPath(request, paths);
  if (!filename) {
    var err = new Error("Cannot find module '" + request + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  }
  return filename;
};
```

- Module.\_findPath()的源码，用来确定到底哪一个是正确路径

```ts
Module._findPath = function (request, paths) {
  // 列出所有可能的后缀名：.js，.json, .node
  var exts = Object.keys(Module._extensions);

  // 如果是绝对路径，就不再搜索
  if (request.charAt(0) === '/') {
    paths = [''];
  }

  // 是否有后缀的目录斜杠
  var trailingSlash = request.slice(-1) === '/';

  // 第一步：如果当前路径已在缓存中，就直接返回缓存
  var cacheKey = JSON.stringify({ request: request, paths: paths });
  if (Module._pathCache[cacheKey]) {
    return Module._pathCache[cacheKey];
  }

  // 第二步：依次遍历所有路径
  for (var i = 0, PL = paths.length; i < PL; i++) {
    var basePath = path.resolve(paths[i], request);
    var filename;

    if (!trailingSlash) {
      // 第三步：是否存在该模块文件
      filename = tryFile(basePath);

      if (!filename && !trailingSlash) {
        // 第四步：该模块文件加上后缀名，是否存在
        filename = tryExtensions(basePath, exts);
      }
    }

    // 第五步：目录中是否存在 package.json
    if (!filename) {
      filename = tryPackage(basePath, exts);
    }

    if (!filename) {
      // 第六步：是否存在目录名 + index + 后缀名
      filename = tryExtensions(path.resolve(basePath, 'index'), exts);
    }

    // 第七步：将找到的文件路径存入返回缓存，然后返回
    if (filename) {
      Module._pathCache[cacheKey] = filename;
      return filename;
    }
  }

  // 第八步：没有找到文件，返回false
  return false;
};
```

- require.resolve 方法，供外部调用，用于从模块名取到绝对路径。

```ts
require.resolve = function (request) {
  return Module._resolveFilename(request, self);
};

// 用法
require.resolve('a.js');
// 返回  /Users/danlan/workspace/node-stu/ree/a.js
```

- 加载模块

```ts
// module.load 方法的源码
// 首先确定模块的后缀名，不同的后缀名对应不同的加载方法
Module.prototype.load = function (filename) {
  var extension = path.extname(filename) || 'js';
  if (!Module._extensions[extensions]) extension = '.js';
  Module._extensions[extension](this, filename);
  this.loaded = true;
};

Module._extensions['.js'] = function (module, filename) {
  var content = fs.readFileSync(filename, 'utf8');
  module._compile(stripBOM(content), filename);
};

Module._extensions['.json'] = function (module, filename) {
  var content = fs.readFileSync(filename, 'utf8');
  try {
    module.exports = JSON.parse(stripBOM(content));
  } catch (err) {
    err.message = filename + ': ' + err.message;
    throw err;
  }
};
```

- module.\_compile 方法用于模块的编译。

```ts
// 首先，将模块文件读取成字符串，然后剥离 utf8 编码特有的BOM文件头，最后编译该模块。
Module.prototype._compile = function (content, filename) {
  var self = this;
  var args = [self.exports, require, self, filename, dirname];
  return compiledWrapper.apply(self.exports, args);
};
```

- 上面的代码基本等同于下面的形式。

```ts
/**
 * 也就是说，模块的加载实质上就是，注入exports、require、module三个全局变量，
 * 然后执行模块的源码，然后将模块的 exports 变量的值输出。
 */
(function (exports, require, module, __filename, __dirname) {
  // 模块源码
});
```

## 关于模块化

- CommonJS 规范

```js
/**
 * 它采用同步步方式加载模块，必须等模块加载完才会执行后面的语句。
 * 所有代码都运行在模块作用域，不会污染全局作用域。
 * 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
 * 模块加载的顺序，按照其在代码中出现的顺序。
 * 通过require来加载模块；
 * 通过exports和module.exports来暴露模块中的内容；

 * CommonJS模块的加载机制是，输入的是被输出的值的拷贝。
 * 也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。

 * 为了方便，Node为每个模块提供一个exports变量，指向module.exports。
 * var exports = module.exports;

 * 模块的循环加载
 * 如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。
 */
var math = require('sum');
var x = 5;
var addX = math.add();
module.exports.x = x;
module.exports.addX = addX;
```

- AMD 规范

```js
/**
 * AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。
 * 采用异步方式加载模块，模块的加载不影响它后面语句的运行。
 * 所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。
 * 反复 require 相同的模块，它只加载一次

 * AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：
 * require([module], callback);
 * 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；
 * 第二个参数callback，则是加载成功之后的回调函数。
 */

// math.js
define(function () {
  var add = function (x, y) {
    return x + y;
  };
  return {
    add: add,
  };
});

// main.js 中使用
require(['math'], function (math) {
  alert(math.add(1, 1));
});
```

- UMD 规范

```js
/**
 * 兼容AMD和CommonJS的规范，还兼容全局引用的方式。因此在浏览器和服务器的环境都可以应用此规范。
 * 实际上就是一个兼容性的写法
 */
(function (name, definition) {
  // 检测上下文环境是否为AMD或CMD
  if (typeof define === 'function' && (define.amd || define.cmd)) {
    define(definition);

    // 检测上下文环境是否为Node
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = definition();
  } else {
    // 将模块的执行结果在window变量中，在浏览器中this指向window对象
    this[name] = definition();
  }
})('hello', function () {
  var hello = function () {};
  return hello;
});
```

- CMD 规范

```js
/**
 * 执行时机处理不同
 * CMD是在AMD基础上改进的一种规范，和AMD不同在于对依赖模块的执行时机处理不同，
 * CMD是就近依赖，而AMD是前置依赖。也就是说AMD要在一开始就加载所有的依赖，而CMD是一级一级的加载。
 * SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行
 * SeaJS只会在真正需要使用(依赖)模块时才执行该模块
 * SeaJS是异步加载模块的没错, 但执行模块的顺序也是严格按照模块在代码中出现(require)的顺序,
 * 模块的加载都是并行的, 没有区别, 区别在于执行模块的时机, 或者说是解析.


 * RequireJS的做法是并行加载所有依赖的模块, 并完成解析后, 再开始执行其他代码, 因此执行结果只会"停顿"1次, 完成整个过程是会比SeaJS要快.
 * SeaJS一样是并行加载所有依赖的模块, 但不会立即执行模块, 等到真正需要(require)的时候才开始解析, 这里耗费了时间, 因为这个特例中的模块巨大, 因此造成"停顿"2次的现象, 这就是我所说的SeaJS中的"懒执行".
  */
```

## ES6 的模块化

- ES6 的模块化 与 CommonJS 规范的区别

```js
/**
 * 主要区别
 * import是ES6标准中的模块化解决方案，require是node中遵循CommonJS规范的模块化解决方案
 *
 * import 不支持动态引入但是已经有提案
 * require支持动态引入，也就是require(${path}/xx.js)
 *
 * import是关键词，require不是
 *
 * import是编译时加载，必须放在模块顶部，在性能上会比后者好一些，
 * require是运行时加载，理论上来说放在哪里都可以
 *
 * import采用的是实时绑定方式，即导入和导出的值都指向同一个内存地址，所以导入值会随着导出值变化。
 * require在导出时是值的拷贝，就算导出的值变化了，导入的值也不会变化，如果想要更新值就要重新导入
 *
 * import会编译成require/exports来执行

 * 代码是在模块作用域,模块内部的顶层变量，外部不可见。
 * 模块脚本自动采用严格模式，不管有没有声明use strict。
 * 模块之中，可以使用import命令加载其他模块 .js后缀不可省略
 * 也可以使用export命令输出对外接口
 * 模块之中，顶层的this关键字返回undefined，而不是指向window。
 * 同一个模块如果加载多次，将只执行一次。
 */
```

- ES6 模块化的优势

```js
/**
 * CommonJS 和 AMD 模块，都只能在运行时确定依赖关系
 * CommonJS 模块就是对象，输入时必须查找对象属性。
 * 导致完全没办法在编译时做“静态优化”。

 * ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
 * ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。
 */

// ES6模块
// 实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载
import { stat, exists, readFile } from 'fs';
```

- export 命令

```js
/**
 * export 命令
 * export命令用于规定模块的对外接口
 * import命令用于输入其他模块提供的功能(接口)
 */

// 使用export命令输出变量
export var firstName = 'Michael';

// export命令除了输出变量，还可以输出函数或类（class）
export function multiply(x, y) {
  return x * y;
}

// 使用as关键字重命名
function v1() { ... }
function v2() { ... }

export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};


/**
  * export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系
  */
// 报错
// 第一种写法直接输出 1，
export 1;

// 报错
// 通过变量m，还是直接输出 1。1只是一个值，不是接口。
var m = 1;
export m;

/**
 * 正确的写法
 * 下面三种写法都是正确的，规定了对外的接口m。
 * 其他脚本可以通过这个接口，取到值1。
 * 它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。
 */


// 写法一
export var m = 1;

// 写法二
var m = 1;
export {m};

// 写法三
var n = 1;
export {n as m};


/**
 * 输出class
  */
// 报错
function f() {}
export f;

// 正确
export function f() {};

// 正确
function f() {}
export {f};

/**
 * export语句输出的接口，与其对应的值是动态绑定关系，
 * 即通过该接口，可以取到模块内部实时的值。
 * 输出变量foo，值为bar，500 毫秒之后变成baz
 * CommonJS 模块输出的是值的缓存，不存在动态更新
 */
export var foo = 'bar';
setTimeout(() => foo = 'baz', 500);


// export命令可以出现在模块的任何位置，只要处于模块顶层就可以。
// 如果处于块级作用域内，就会报错，
// 这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。
function foo() {
  export default 'bar' // SyntaxError
}
foo()

```

- import 命令

```js
/**
 * 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。
 * import命令是编译阶段执行的，在代码运行之前。
 * import语句会执行所加载的模块
 */
import { firstName, lastName, year } from './profile.js';

function setName(element) {
  element.textContent = firstName + ' ' + lastName;
}

/** 使用as关键字，将输入的变量重命名。  */
import { lastName as surname } from './profile.js';

/**
 * import命令输入的变量都是只读的，因为它的本质是输入接口。
 * 不允许在加载模块的脚本里面，改写接口
 */
import { a } from './xxx.js';
a = {}; // Syntax Error : 'a' is read-only;

// 如果a是一个对象，改写a的属性是允许的。
// a的属性可以成功改写，并且其他模块也可以读到改写后的值。
import { a } from './xxx.js';
a.foo = 'hello'; // 合法操作

/**
 * import命令具有提升效果，会提升到整个模块的头部，首先执行。
 * import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，
 * .js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。
 */
foo();
import { foo } from 'my_module';

/**
 * 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构
 * 表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。
 */
 // 报错
import { 'f' + 'oo' } from 'my_module';

// 报错
let module = 'my_module';
import { foo } from module;

// 报错
if (x === 1) {
  import { foo } from 'module1';
} else {
  import { foo } from 'module2';
}

/**
  * import语句会执行所加载的模块
  * 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。
  */
import 'lodash';

// 虽然foo和bar在两个语句中加载
import { foo } from 'my_module';
import { bar } from 'my_module';

// 等同于
import { foo, bar } from 'my_module';
```

- 仅为副作用而导入一个模块

```js
/**
 * 不导入模块中的任何内容（接口）。 这将运行模块中的全局代码, 但实际上不导入任何值。
 */
import '/modules/my-module.js';
```

- import 之 模块的整体加载

```js
/**
 * 用星号（*）指定一个对象，所有输出值都加载在这个对象上面
 */
import * as circle from './circle';

console.log('圆面积：' + circle.area(4));
console.log('圆周长：' + circle.circumference(14));

/**
 * 模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。
 */
import * as circle from './circle';

// 下面两行都是不允许的
circle.foo = 'hello';
circle.area = function () {};
```

- export default 命令

```js
/**
 * export default命令，为模块指定默认输出。
 */

// 默认输出是一个函数
export default function() {
  console.log('foo');
}

// 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。
// 这时import命令后面，不使用大括号。
import customName from './export-default';
customName(); // 'foo'

/**
 * export default命令其实只是输出一个叫做default的变量
 * 它后面不能跟变量声明语句。
 */
// 正确
export var a = 1;

// 正确
var a = 1;
export default a; // export default a的含义是将变量a的值赋给变量default。

// 错误
export default var a = 1;

// 可以直接将一个值写在export default之后。
// export default命令的本质是将后面的值，赋给default变量
// 指定对外接口为default。
// 正确
export default 42;
// 报错
export 42;

/**
  * 一条import语句中，同时输入默认方法和其他接口
  */
import _, { each, forEach } from 'lodash';

export default function (obj) {
  // ···
}

export function each(obj, iterator, context) {
  // 暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法。
}

export { each as forEach };

/**
 * export default也可以用来输出类。
 */
export default class { ... }

// main.js
import MyClass from 'MyClass';
let o = new MyClass();
```

- export 与 import 的复合写法

```js
/**
 * 在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。
 * foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。
 */
export { foo, bar } from 'my_module';

// 可以简单理解为
import { foo, bar } from 'my_module';
export { foo, bar };

/**
 * 模块的接口改名和整体输出
 */
// 接口改名
export { foo as myFoo } from 'my_module';

// 整体输出
export * from 'my_module';

// 默认接口
export { default } from 'foo';

// 具名接口改为默认接口的写法
export { es6 as default } from './someModule';

// 等同于
import { es6 } from './someModule';
export default es6;

// 默认接口也可以改名为具名接口
export { default as es6 } from './someModule';

/**
 * 下面三种import语句，没有对应的复合写法。
 */
import * as someIdentifier from 'someModule';
import someIdentifier from 'someModule';
import someIdentifier, { namedIdentifier } from 'someModule';
```

- 模块的继承

```js
/**
 * circleplus模块，继承了circle模块
 */

// export *，表示再输出circle模块的所有属性和方法。
// export *命令会忽略circle模块的default方法。
export * from 'circle';
export var e = 2.71828182846;
export default function (x) {
  return Math.exp(x);
}

// 以将circle的属性或方法，改名后再输出
// 只输出circle模块的area方法，且将其改名为circleArea。
export { area as circleArea } from 'circle';

// 加载上面模块的写法
import * as math from 'circleplus';
import exp from 'circleplus';
console.log(exp(math.e));
```

- 跨模块常量(转发模块)

```js
/**
 * 常规写法
 */
// constants.js 模块
export const A = 1;
export const B = 3;
export const C = 4;

// test1.js 模块
import * as constants from './constants';
console.log(constants.A); // 1
console.log(constants.B); // 3

// test2.js 模块
import { A, B } from './constants';
console.log(A); // 1
console.log(B); // 3

/**
 * 如果要使用的常量非常多，可以建一个专门的constants目录，
 * 将各种常量写在不同的文件里面，保存在该目录下。
 */
// constants/db.js
export const db = {
  url: 'http://my.couchdbserver.local:5984',
  admin_username: 'admin',
  admin_password: 'admin password',
};

// constants/user.js
export const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];

// constants/index.js 合并在index.js文件里面 对外转发模块
export { db } from './db';
export { users } from './users';

// script.js 使用的时候，直接加载index.js
import { db, users } from './constants/index';
```

## 不同模块规范的加载

```js
/**
 * ES6的模块必须使用import命令加载，不能使用require命令加载
 * CommonJS规范的模块必须使用require命令加载，而不能使用import命令加载

 * ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。
 * ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。
 *
 * 某些顶层变量在 ES6 模块之中都是不存在的
 * arguments require module exports __filename __dirname
 */
```

- ES6 模块加载 CommonJS 模块

```js
/**
 * Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，
 * 即等同于export default xxx。
 * module.exports会被视为默认输出，即import命令实际上输入的是这样一个对象{ default: module.exports }
 */
// a.js
module.exports = {
  foo: 'hello',
  bar: 'world',
};

// 等同于
export default {
  foo: 'hello',
  bar: 'world',
};

/** 拿到 CommonJS 模块的module.exports。  */
// 写法一
import baz from './a';
// baz = {foo: 'hello', bar: 'world'};

// 写法二
import { default as baz } from './a';
// baz = {foo: 'hello', bar: 'world'};

// 写法三
// 可以通过baz.default拿到module.exports。
import * as baz from './a';
// baz = {
//   get default() {return module.exports;},
//   get foo() {return this.default.foo}.bind(baz),
//   get bar() {return this.default.bar}.bind(baz)
// }

/** CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。  */
// foo.js
// module.exports将一直是123，而不会变成null。
module.exports = 123;
setTimeout((_) => (module.exports = null));

/** CommonJS 模块是运行时确定输出接口，所以采用import命令加载 CommonJS 模块时，不允许采用下面的写法。  */
// 不正确
import { readFile } from 'fs';

// 正确的写法一
import * as express from 'express';
const app = express.default();

// 正确的写法二
import express from 'express';
const app = express();
```

- CommonJS 模块加载 ES6 模块

```js
/**
 * CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。
 * ES6 模块的所有输出接口，会成为输入对象的属性。
 */

/** 示例一  */
// es.js
export let foo = { bar: 'my-default' };
export { foo as bar };
export function f() {}
export class c {}

// cjs.js
const es_namespace = await import('./es');
// es_namespace = {
//   get foo() {return foo;}
//   get bar() {return foo;}
//   get f() {return f;}
//   get c() {return c;}
// }

/** 示例二  */
// es.mjs
let foo = { bar: 'my-default' };
export default foo;

// cjs.js
const es_namespace = await import('./es.mjs');
// es_namespace = {
//   get default() {
//     ...
//   }
// }
console.log(es_namespace.default);
// { bar:'my-default' }
```

## 循环加载

- CommonJS 模块的循环加载

```js
/**
 * 一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。
 * CommonJS 输入的是被输出值的拷贝，不是引用
 */

/** a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。  */
exports.done = false;
var b = require('./b.js');
console.log('在 a.js 之中，b.done = %j', b.done);
exports.done = true;
console.log('a.js 执行完毕');

/**  b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，
 * 因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。 即exports.done = false;
 * 对于b.js来说，它从a.js只输入一个变量done，值为false。
 * 然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。
 * a.js接着往下执行，直到执行完毕。
 */
exports.done = false;
var a = require('./a.js');
console.log('在 b.js 之中，a.done = %j', a.done);
exports.done = true;
console.log('b.js 执行完毕');

/** 在main.js中执行  */

var a = require('./a.js');
var b = require('./b.js');
console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done);

// 输出结果
// 在 b.js 之中，a.done = false
// b.js 执行完毕
// 在 a.js 之中，b.done = true
// a.js 执行完毕
// 在 main.js 之中, a.done=true, b.done=true

/**
 * CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。
 * require('a').foo的值很可能后面会被改写，改用require('a')会更保险一点。
 */

var a = require('a'); // 安全的写法
var foo = require('a').foo; // 危险的写法
```

- ES6 模块的循环加载

```js
/**
 * ES6 模块是动态引用
 * 而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。
 */

// a.mjs
import { bar } from './b';
console.log('a.mjs');
console.log(bar);
export let foo = 'foo';

// b.mjs
import { foo } from './a';
console.log('b.mjs');
console.log(foo);
export let bar = 'bar';

/** 执行a.mjs，结果如下。
 * 执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。
 * 执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。
 * 执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。
 */

$ node --experimental-modules a.mjs
b.mjs
ReferenceError: foo is not defined

/**
 * 这可以通过将foo写成函数来解决报错问题
 * 因为函数具有提升作用，在执行import {bar} from './b'时，函数foo就已经有定义了，
 */
// a.mjs
import {bar} from './b';
console.log('a.mjs');
console.log(bar());
function foo() { return 'foo' }
export {foo};

// b.mjs
import {foo} from './a';
console.log('b.mjs');
console.log(foo());
function bar() { return 'bar' }
export {bar};

// $ node --experimental-modules a.mjs
// b.mjs
// foo
// a.mjs
// bar
```
