# 异常处理

- 为了保证异常可追踪，必须保证所有抛出的异常都是 Error 类型，
- 因为只有 Error 类型才会带上堆栈信息，定位到问题。
- 框架并不会将服务端返回的 404 状态当做异常来处理

## try catch 捕获普通异常

- 在编写应用代码时，所有地方都可以直接用 try catch 来捕获异常。

```js
// app/service/test.js
try {
  const res = await this.ctx.curl('http://eggjs.com/api/echo', {
    dataType: 'json'
  });
  if (res.status !== 200) throw new Error('response status is not 200');
  return res.data;
} catch (err) {
  this.logger.error(err);
  return {};
}
```

## 跳出了异步链，它里面的错误就无法被捕捉到了

```js
// app/controller/home.js
class HomeController extends Controller {
  async buy() {
    const request = {};
    const config = await ctx.service.trade.buy(request);
    // 下单后需要进行一次核对，且不阻塞当前请求
    setImmediate(() => {
      ctx.service.trade.check(request).catch(err => ctx.logger.error(err));
    });
  }
}
```

## ctx.runInBackground(scope) 辅助方法，

- 通过它又包装了一个异步链，所有在这个 scope 里面的错误都会统一捕获。

```js
class HomeController extends Controller {
  async buy() {
    const request = {};
    const config = await ctx.service.trade.buy(request);
    // 下单后需要进行一次核对，且不阻塞当前请求
    ctx.runInBackground(async () => {
      // 这里面的异常都会统统被 Backgroud 捕获掉，并打印错误日志
      await ctx.service.trade.check(request);
    });
  }
}
```

## errorPageUrl

```js
// config/config.default.js
module.exports = {
  onerror: {
    // 线上页面发生异常时，重定向到这个页面上
    errorPageUrl: '/50x.html'
  }
};
```

## 自定义统一异常处理

```js
// config/config.default.js
module.exports = {
  onerror: {
    all(err, ctx) {
      // 在此处定义针对所有响应类型的错误处理方法
      // 注意，定义了 config.all 之后，其他错误处理方法不会再生效
      ctx.body = 'error';
      ctx.status = 500;
    },
    html(err, ctx) {
      // html hander
      ctx.body = '<h3>error</h3>';
      ctx.status = 500;
    },
    json(err, ctx) {
      // json hander
      ctx.body = { message: 'error' };
      ctx.status = 500;
    },
    jsonp(err, ctx) {
      // 一般来说，不需要特殊针对 jsonp 进行错误定义，jsonp 的错误处理会自动调用 json 错误处理，并包装成 jsonp 的响应格式
    }
  }
};
```

## 将默认的 HTML 请求的 404 响应重定向到指定的页面

```js
// config/config.default.js
module.exports = {
  notfound: {
    pageUrl: '/404.html'
  }
};
```

## 自定义 404 响应

```js
// app/middleware/notfound_handler.js
module.exports = () => {
  return async function notFoundHandler(ctx, next) {
    await next();
    if (ctx.status === 404 && !ctx.body) {
      if (ctx.acceptJSON) {
        ctx.body = { error: 'Not Found' };
      } else {
        ctx.body = '<h1>Page Not Found</h1>';
      }
    }
  };
};

// 在配置中引入中间件：

// config/config.default.js
module.exports = {
  middleware: ['notfoundHandler']
};
```
