# 多进程模型和进程间通信

## 进程组成

- 1 个 Master 进程
  Master 进程它就会帮我们搞定所有的 Worker、Agent 进程的初始化以及重启等工作了

  > 启动 Master 进程 egg-scripts start --daemon

- 一个 Agent 进程
  Agent 进程在监听到未捕获异常时不会退出，但是会打印出错误日志

- 多个 Worker 进程(一般和 CPU 的核数保持一致)
  当 Worker 进程异常退出时，Master 进程会重启一个 Worker 进程。
  Egg 的定时任务也提供了只让一个 Worker 进程运行的能力
- app.js 执行的是工作进程
- agent.js 执行的是 Agent 进程

## Agent 进程与 Worker 进程的通讯实例(Master 进程起到转发消息的作用)

```js
// agent.js
module.exports = agent => {
  // 在这里写你的初始化逻辑

  // 也可以通过 messenger 对象发送消息给 App Worker
  // 但需要等待 App Worker 启动成功后才能发送，不然很可能丢失
  agent.messenger.on('egg-ready', () => {
    const data = { a: 1 };
    agent.messenger.sendToApp('action1', data); // action名是可以自定义的
  });
};

// app.js
module.exports = app => {
  app.messenger.on('action1', data => {
    console.log('子进程已经接收到agent进程发送来的信息=======', data);
  });
};
```

## 进程间通信使用的 api

- 注意，只有在 egg-ready 事件拿到之后才能发送消息

```bash
app.messenger.broadcast(action, data)：发送给所有的 agent / app 进程（包括自己）
app.messenger.sendToApp(action, data): 发送给所有的 app 进程
  在 app 上调用该方法会发送给自己和其他的 app 进程
  在 agent 上调用该方法会发送给所有的 app 进程
app.messenger.sendToAgent(action, data): 发送给 agent 进程
  在 app 上调用该方法会发送给 agent 进程
  在 agent 上调用该方法会发送给 agent 自己
agent.messenger.sendRandom(action, data):
  app 上没有该方法（现在 Egg 的实现是等同于 sentToAgent）
  agent 会随机发送消息给一个 app 进程（由 master 来控制发送给谁）
app.messenger.sendTo(pid, action, data): 发送给指定进程
```

## 多进程研发模式增强

- 通过建立 Agent 和 Worker 的 socket 直连跳过 Master 的中转。Agent 作为对外的门面维持多个 Worker 进程的共享连接。

### Leader 和 Follower

- Leader: 负责和远程服务端维持连接，对于同一类的客户端只有一个 Leader。
- Follower: 会将具体的操作委托给 Leader，常见的是订阅模型（让 Leader 和远程服务端交互，并等待其返回）。
- egg.js 框架里面我们采用的是强制指定模式，Leader 只能在 Agent 里面创建
- 启动的时候 Master 会随机选择一个可用的端口作为 Cluster Client 监听的通讯端口，并将它通过参数传递给 Agent 和 App Worker。
- Leader 和 Follower 之间通过 socket 直连（通过通讯端口），不再需要 Master 中转。

### Leader 和 Follower 通过下面的协议进行数据交换：

```bash
在通讯端口上 Leader 启动一个 Local Server，所有的 Leader/Follower 通讯都经过 Local Server。
Follower 连接上 Local Server 后，首先发送一个 register channel 的 packet（引入 channel 的概念是为了区别不同类型的客户端）。
Local Server 会将 Follower 分配给指定的 Leader（根据客户端类型进行配对）。
Follower 向 Leader 发送订阅、发布请求。
Leader 在订阅数据变更时通过 subscribe result packet 通知 Follower。
Follower 向 Leader 发送调用请求，Leader 收到后执行相应操作后返回结果。
```

## 具体的使用方法

- 一个客户端支持 Leader/Follower 模式

```js
// 第一步，我们的客户端最好是符合上面提到过的接口约定，例如：
// registry_client.js
const URL = require('url');
const Base = require('sdk-base');

class RegistryClient extends Base {
  constructor(options) {
    super({
      // 指定异步启动的方法
      initMethod: 'init'
    });
    this._options = options;
    this._registered = new Map();
  }

  /**
   * 启动逻辑
   */
  async init() {
    this.ready(true);
  }

  /**
   * 获取配置
   * @param {String} dataId - the dataId
   * @return {Object} 配置
   */
  async getConfig(dataId) {
    return this._registered.get(dataId);
  }

  /**
   * 订阅
   * @param {Object} reg
   *   - {String} dataId - the dataId
   * @param {Function}  listener - the listener
   */
  subscribe(reg, listener) {
    const key = reg.dataId;
    this.on(key, listener);

    const data = this._registered.get(key);
    if (data) {
      process.nextTick(() => listener(data));
    }
  }

  /**
   * 发布
   * @param {Object} reg
   *   - {String} dataId - the dataId
   *   - {String} publishData - the publish data
   */
  publish(reg) {
    const key = reg.dataId;
    let changed = false;

    if (this._registered.has(key)) {
      const arr = this._registered.get(key);
      if (arr.indexOf(reg.publishData) === -1) {
        changed = true;
        arr.push(reg.publishData);
      }
    } else {
      changed = true;
      this._registered.set(key, [reg.publishData]);
    }
    if (changed) {
      this.emit(
        key,
        this._registered.get(key).map(url => URL.parse(url, true))
      );
    }
  }
}

module.exports = RegistryClient;

// 第二步，使用 agent.cluster 接口对 RegistryClient 进行封装：
// agent.js
const RegistryClient = require('registry_client');

module.exports = agent => {
  // 对 RegistryClient 进行封装和实例化
  agent.registryClient = agent
    .cluster(RegistryClient)
    // create 方法的参数就是 RegistryClient 构造函数的参数
    .create({});

  agent.beforeStart(async () => {
    await agent.registryClient.ready();
    agent.coreLogger.info('registry client is ready');
  });
};

// 第三步，使用 app.cluster 接口对 RegistryClient 进行封装：
// app.js
const RegistryClient = require('registry_client');

module.exports = app => {
  app.registryClient = app.cluster(RegistryClient).create({});
  app.beforeStart(async () => {
    await app.registryClient.ready();
    app.coreLogger.info('registry client is ready');

    // 调用 subscribe 进行订阅
    app.registryClient.subscribe(
      {
        dataId: 'demo.DemoService'
      },
      val => {
        // ...
      }
    );

    // 调用 publish 发布数据
    app.registryClient.publish({
      dataId: 'demo.DemoService',
      publishData: 'xxx'
    });

    // 调用 getConfig 接口
    const res = await app.registryClient.getConfig('demo.DemoService');
    console.log(res);
  });
};
```
