# Cookie 与 Session 的使用

## Cookies

- 设置 Cookies 的值必须为字符串

### 设置和读取 Cookie

```js
class HomeController extends Controller {
  async add() {
    const ctx = this.ctx;
    // 获取cookies
    let count = ctx.cookies.get('count');
    count = count ? Number(count) : 0;
    // 设置cookies
    ctx.cookies.set('count', ++count);
    ctx.body = count;
  }
  async remove() {
    const ctx = this.ctx;
    // 设置cookies 清空 删除 cookies
    ctx.cookies.set('count', null);
    ctx.status = 204;
  }
}
```

### cookies 的设置选项

- 默认的配置下，Cookie 是加签不加密的，浏览器可以看到明文，js 不能访问，不能被客户端（手工）篡改。
  > ctx.cookies.set(key, value, options)

```bash
# 常规参数
{Number} maxAge  浏览器保存时间(毫秒)
{Date} expires 失效时间 会被maxAge覆盖 默认关闭浏览器失效
{String} path 设置cookies生效路径 默认根路径下所有域名均可访问
{String} domain 生效域名 默认没有设置
{Boolean} httpOnly 是否可以被js访问 默认不可访问
{Boolean} secure 只在 HTTPS 连接上传输 框架会自动配置

# 扩展了 3 个参数
{Boolean} overwrite 后面的设置是否覆盖前面的设置
{Boolean} signed 是否对键值对进行签名 默认为true
{Boolean} encrypt 对 Cookie 进行加密 默认为false 设置为true 则客户端无法看到cookies的明文
```

- cookies 设置

```js
/* 如果想要 Cookie 在浏览器端可以被 js 访问并修改 */
ctx.cookies.set(key, value, {
  httpOnly: false,
  signed: false,
});

/* 如果想要 Cookie 在浏览器端不能被修改，不能看到明文： */
ctx.cookies.set(key, value, {
  httpOnly: true, // 默认就是 true
  encrypt: true, // 加密传输
});
```

### cookies 设置的一些建议

- value 通过 base64 编码或者其他形式 encode 之后再写入
- 不要设置太长的 Cookie。一般来说不要超过 4093 bytes

### cookies 的获取

```js
/** 对cookies进行加签加密  */
ctx.cookies.set('frontend-cookie', '1', {
  signed: true, // 进行加签
  encrypt: true, // 进行加密
});

/** 对应加密加签的cookies的获取  */
ctx.cookies.get('frontend-cookie', {
  signed: true, // 进行验签
  encrypt: true, // 进行解密
});
```

### config/config.default.js 中配置秘钥

- keys 配置成一个字符串，可以按照逗号分隔配置多个 key

```js
/** 加密和加签时只会使用第一个秘钥。
解密和验签时会遍历 keys 进行解密。  */
module.exports = {
  keys: 'key1,key2',
};
```

## Session

- 专门用做用户身份识别
- 设置的 Session 存放在服务器端 客户端是看不到的

### Session 的设置和获取

```js
/* ctx.session 来访问或者修改当前用户 Session  */
class HomeController extends Controller {
  async fetchPosts() {
    const ctx = this.ctx;
    // 获取 Session 上的内容
    const userId = ctx.session.userId;
    const posts = await ctx.service.post.fetch(userId);
    // 修改 Session 的值
    ctx.session.visited = ctx.session.visited ? ctx.session.visited + 1 : 1;
    ctx.body = {
      success: true,
      posts,
    };
  }
}
```

- 删除 session
  > ctx.session = null;

### Session 设置要点

```js
/* 不要以 _ 开头
不能为 isNew */
// ❌ 错误的用法
ctx.session._visited = 1; //    --> 该字段会在下一次请求时丢失
ctx.session.isNew = 'HeHe'; //    --> 为内部关键字, 不应该去更改

// ✔️ 正确的用法
ctx.session.visited = 1; //   -->  此处没有问题
```

### Session 与 Cookies 的关系

```bash
1.Session 是 基于 Cookie 的
2.用户 Session 的内容加密后直接存储在 Cookie 中的一个字段中
3.用户每次请求我们网站的时候都会带上这个 Cookie 服务端解密后使用
```

- Session 的默认配置

```js
exports.session = {
  key: 'EGG_SESS', // key 代表了存储 Session 的 Cookie 键值对的 key 是什么
  maxAge: 24 * 3600 * 1000, // 1 天
  httpOnly: true, // 不允许客户端js获取
  encrypt: true, // 进行加密
};
```

### 修改 Session 的失效时间

```js
// 如果用户勾选了 `记住我`，设置 30 天的过期时间
if (rememberMe) ctx.session.maxAge = ms('30d');
```

### 延长 Session 有效期

- 默认情况下 当用户请求没有导致 Session 被修改时，框架都不会延长 Session 的有效期
- 用户如果长时间都在访问我们的站点，则延长他们的 Session 有效期，不让用户退出登录态。

```js
// config/config.default.js
module.exports = {
  session: {
    renew: true,
  },
};
```

## 问题一

- 为什么服务器能够为不同的浏览器用户提供不同 session

```js
/** plugin.js中配置的session
 * 服务器端设置session值后 服务器自动颁发一个key是EGG_SESS的cookie给浏览器 用于标识不同的浏览器
 * 浏览器EGG_SESS值是SessionID 不同浏览器是不一样的
 * cookies会通过请求传递给服务器 不同的浏览器可以获取不同的session值
 * Session存放在服务器的内存中，SessionID存放在服务器内存和客户机的Cookie里面。5万个用户就意味着服务器端存放了5W*n个Session
 * 当用户发出请求时，服务器将用户Cookie里面记录的SessionID和服务器内存中的SessionID进行比对，找到这个用户对应的Session进行操作。
 */
exports.session = {
  key: 'EGG_SESS', // key 代表了存储 Session 的 Cookie 键值对的 key 是什么
  maxAge: 24 * 3600 * 1000, // 1 天
  httpOnly: true, // 不允许客户端js获取
  encrypt: true, // 进行加密
};
```

## 问题二

- 只允许一个用户登录
  > 浏览器 EGG_SESS 值是 SessionID 不同浏览器是不一样的
