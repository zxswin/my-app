# 单元测试

## 一个简单的单元测试的写法

```js
/* eslint-disable no-undef */
let expect = require('chai').expect;

describe('单元测试名称', function() {
  before(function() {
    // 在本区块的所有测试用例之前执行
    console.log('在本区块的所有测试用例之前执行');
  });

  after(function() {
    // 在本区块的所有测试用例之后执行
    console.log('在本区块的所有测试用例之后执行');
  });

  beforeEach(function() {
    // 在本区块的每个测试用例之前执行
    console.log('在本区块的每个测试用例之前执行');
  });

  afterEach(function() {
    // 在本区块的每个测试用例之后执行
    console.log('在本区块的每个测试用例之后执行');
  });

  // eslint-disable-next-line no-undef
  it('4 + 5应该等于9', function() {
    expect(4 + 5).to.be.equal(9);
  });
});
```

## egg.js 的单元测试

- 内置 Mocha、co-mocha、power-assert，nyc
- 默认使用 Mocha 测试框架
- power-assert 作为默认的断言库。
- mock 扩展自 npm install mm --save-dev

## 测试目录结构

```bash
测试脚本文件统一按 ${filename}.test.js 命名，必须以 .test.js 作为文件后缀。

一个应用的测试目录示例：

test
├── controller
│   └── home.test.js
├── hello.test.js
└── service
    └── user.test.js
```

## 准备测试

- egg-mock
  有了它我们就可以非常快速地编写一个 app 的单元测试，并且还能快速创建一个 ctx 来测试它的属性、方法和 Service 等。

- 创建 app 实例

```js
// test/controller/home.test.js
const mock = require('egg-mock');

/** 快速获取app实例
 * const { app, mock, assert } = require('egg-mock/bootstrap');
 * return app.ready();
 */

describe('test/controller/home.test.js', () => {
  let app;
  before(() => {
    // 创建当前应用的 app 实例
    app = mock.app();
    // 等待 app 启动成功，才能执行测试用例
    return app.ready();
  });
});
```

- 快速创建一个 ctx 实例

```js
it('should get a ctx', () => {
  const ctx = app.mockContext();
  assert(ctx.method === 'GET');
  assert(ctx.url === '/');
});
```

- 模拟 ctx.user 这个数据

```js
it('should mock ctx.user', () => {
  const ctx = app.mockContext({
    user: {
      name: 'fengmk2'
    }
  });
  assert(ctx.user);
  assert(ctx.user.name === 'fengmk2');
});
```

## 异步测试

```js
// 使用返回 Promise 的方式
it('should redirect', () => {
  return app
    .httpRequest()
    .get('/')
    .expect(302);
});

// 使用 callback 的方式
it('should redirect', done => {
  app
    .httpRequest()
    .get('/')
    .expect(302, done);
});

// 使用 async
it('should redirect', async () => {
  await app
    .httpRequest()
    .get('/')
    .expect(302);
});
```

## Controller 测试

### 一个完整的 Controller 测试

- home.js

```js
/** 用于测试的接口  */
  async test() {
    const ctx = this.ctx;
    ctx.body = 'hello world';
  }
```

- router.js

```js
/** 测试用例  */
router.get('/api/test', controller.example.home.test);
```

- home.test.js 单元测试文件

```js
/* eslint-disable no-undef */
const { app, assert } = require('egg-mock/bootstrap');

describe('test/controller/example/home.test.js', () => {
  describe('测试test接口', () => {
    it('响应状态是200并且响应体符合要求', () => {
      // 对 app 发起 `GET /` 请求
      return app
        .httpRequest()
        .get('/api/test')
        .expect(200) // 期望返回 status 200
        .expect('hello world'); // 期望 body 是 hello world
    });

    it('发起多次请求测试', async () => {
      // 使用 generator function 方式写测试用例，可以在一个用例中串行发起多次请求
      await app
        .httpRequest()
        .get('/api/test')
        .expect(200) // 期望返回 status 200
        .expect('hello world'); // 期望 body 是 hello world

      // 再请求一次
      const result = await app
        .httpRequest()
        .get('/api/test')
        .expect(200)
        .expect('hello world');

      // 也可以这样验证
      assert(result.status === 200);
    });
  });
});
```

### POST 方式发送一个 JSON 请求

```js
// app/controller/home.js
class HomeController extends Controller {
  async post() {
    this.ctx.body = this.ctx.request.body;
  }
}

// test/controller/home.test.js
it('should status 200 and get the request body', () => {
  // app.mockCsrf() 方法来模拟取 CSRF token 的过程 就会自动通过 CSRF 校验
  app.mockCsrf();
  return app
    .httpRequest()
    .post('/post')
    .type('form')
    .send({
      foo: 'bar'
    })
    .expect(200)
    .expect({
      foo: 'bar'
    });
});
```

## Service 测试

```js
// app/service/user.js
class UserService extends Service {
  async get(name) {
    return await userDatabase.get(name);
  }
}

// 单元测试代码
describe('get()', () => {
  it('should get exists user', async () => {
    // 创建 ctx
    const ctx = app.mockContext();
    // 通过 ctx 访问到 service.user
    const user = await ctx.service.user.get('fengmk2');
    assert(user);
    assert(user.name === 'fengmk2');
  });

  it('should get null when user not exists', async () => {
    const ctx = app.mockContext();
    const user = await ctx.service.user.get('fengmk1');
    assert(!user);
  });
});
```

## 还原避免 mock 污染

- egg-mock/bootstrap 时，会自动在 afterEach 钩子中还原所有的 mock，不需要在测试文件中再次编写。

```js
// afterEach 钩子里面还原掉所有 mock。
afterEach(mock.restore);
});
```

## 模拟 app/service/user 中的 get(name) 方法，让它返回一个本来不存在的用户数据。

```js
it('should mock fengmk1 exists', () => {
  app.mockService('user', 'get', () => {
    return {
      name: 'fengmk1'
    };
  });

  return (
    app
      .httpRequest()
      .get('/user?name=fengmk1')
      .expect(200)
      // 返回了原本不存在的用户信息
      .expect({
        name: 'fengmk1'
      })
  );
});
```

## 模拟请求返回值

```js
// app/controller/home.js
class HomeController extends Controller {
  async httpclient() {
    const res = await this.ctx.curl('https://eggjs.org');
    this.ctx.body = res.data.toString();
  }
}

// 单元测试文件模拟请求返回数据
describe('GET /httpclient', () => {
  it('should mock httpclient response', () => {
    app.mockHttpclient('https://eggjs.org', {
      // 模拟的参数，可以是 buffer / string / json，
      // 都会转换成 buffer
      // 按照请求时的 options.dataType 来做对应的转换
      data: 'mock eggjs.org response'
    });
    return app
      .httpRequest()
      .get('/httpclient')
      .expect('mock eggjs.org response');
  });
});
```

## 启动测试

```bash
只需要在 package.json 上配置好 scripts.test 即可。

{
  "scripts": {
    "test": "egg-bin test"
  }
}

```
