# 安全

## 框架提供的安全实践

- 在框架中内置了安全插件 egg-security， 提供了默认的安全实践。
- 框架的安全插件是默认开启的

## 开启与关闭配置

- 在 config.default.js 中配置
- 关闭 xframe 防范

```js
exports.security = {
  xframe: {
    enable: false
  }
};
```

- 只针对 /example 开启 CSP (match)

```js
exports.security = {
  csp: {
    match: '/example',
    policy: {
      //...
    }
  }
};
```

- 针对 /example 关闭 xframe(ignore)

```js
exports.security = {
  csp: {
    ignore: '/example',
    xframe: {
      //...
    }
  }
};
```

- 针对内部 ip 关闭部分安全防范：

```js
exports.security = {
  csrf: {
    // 判断是否需要 ignore 的方法，请求上下文 context 作为第一个参数
    ignore: ctx => isInnerIp(ctx.ip)
  }
};
```

## 安全威胁 XSS 的防范

- 框架提供了 helper.escape() 方法对字符串进行 XSS 过滤。

```js
const str = '><script>alert("abc") </script><';
console.log(ctx.helper.escape(str));
// => &gt;&lt;script&gt;alert(&quot;abc&quot;) &lt;/script&gt;&lt;
```

- helper.sjs() 变量中字符进行 JavaScript ENCODE

```js
const foo = '"hello"';

// 未使用 sjs
console.log(`var foo = "${foo}";`);
// => var foo = ""hello"";

// 使用 sjs
console.log(`var foo = "${this.helper.sjs(foo)}";`);
// => var foo = "\\x22hello\\x22";
```

- 框架提供了 helper.sjson() 宏做 json encode
  处理过程较复杂，性能损耗较大，请仅在必要时使用。

```js
<script>
  window.locals = {{ helper.sjson(locals) }};
</script>
```

## Stored XSS 攻击

- 框架提供了 helper.shtml() 方法对字符串进行 XSS 过滤。
  由于是一个非常复杂的安全处理过程，对服务器处理性能一定影响，如果不是输出 HTML，请勿使用。

```js
// js
const value = `<a href="http://www.domain.com">google</a><script>evilcode…</script>`;
// 模板
<html>
<body>
  {{ helper.shtml(value) }}
</body>
</html>
// => <a href="http://www.domain.com">google</a>&lt;script&gt;evilcode…&lt;/script&gt;

```

- config.helper.shtml.domainWhiteList: [] 可拓展 href 和 src 中允许的域名白名单。
- HTML 标签就不在白名单中
- 常见的 data-xx 属性由于不在白名单中，所以都会被过滤。

## JSONP XSS 攻击

- 框架内部使用 jsonp-body 来对 JSONP 请求进行安全防范。

## Web 安全头 开启防范

浏览器自身具有一定针对各种攻击的防范能力，他们一般是通过开启 Web 安全头生效的。框架内置了一些常见的 Web 安全头的支持。

- 框架内支持 CSP 的配置，不过是默认关闭的

```bash
X-Download-Options:noopen
默认开启，禁用 IE 下下载框Open按钮，防止 IE 下下载文件默认被打开 XSS。

X-Content-Type-Options:nosniff
禁用 IE8 自动嗅探 mime 功能例如 text/plain 却当成 text/html 渲染

X-XSS-Protection
IE 提供的一些 XSS 检测与防范，默认开启
```

## 安全威胁 CSRF 的防范

- CSRF（Cross-site request forgery 跨站请求伪造
- CSRF 攻击会对网站发起恶意伪造的请求，严重影响网站的安全。
- 框架内置了 CSRF 防范方案。

### 同步表单的 CSRF 校验

- 在同步渲染页面时，在表单请求中增加一个 name 为 \_csrf 的 url query，值为 ctx.csrf，
- 这样用户在提交这个表单的时候会将 CSRF token 提交上来：
- 通过同步方式渲染到页面上的 CSRF token 在每次请求时都会变化，
- egg-view-nunjucks 等 View 插件会自动对 Form 进行注入，对应用开发者无感知。

```js
<form
  method="POST"
  action="/upload?_csrf={{ ctx.csrf | safe }}"
  enctype="multipart/form-data"
>
  title: <input name="title" />
  file: <input name="file" type="file" />
  <button type="submit">upload</button>
</form>
```

### AJAX 请求

- 在 CSRF 默认配置下，token 会被设置在 Cookie 中，在 AJAX 请求的时候，
- 可以从 Cookie 中取到 token，放置到 query、body 或者 header 中发送给服务端。

```js
var csrftoken = Cookies.get('csrfToken');

function csrfSafeMethod(method) {
  // these HTTP methods do not require CSRF protection
  return /^(GET|HEAD|OPTIONS|TRACE)$/.test(method);
}
$.ajaxSetup({
  beforeSend: function(xhr, settings) {
    console.log('this', this);
    console.log('settings.type', settings.type); // POST
    console.log('this.crossDomain', this.crossDomain); // false 是否跨域
    if (!csrfSafeMethod(settings.type) && !this.crossDomain) {
      /** 关键代码 设置请求头  */
      xhr.setRequestHeader('x-csrf-token', csrftoken);
    }
  }
});
```

### Session vs Cookie 存储

### 刷新 CSRF token

- 当 CSRF token 存储在 Cookie 中时，一旦在同一个浏览器上发生用户切换，
- 新登陆的用户将会依旧使用旧的 token（之前用户使用的），这会带来一定的安全风险，
- 因此在每次用户登陆的时候都必须刷新 CSRF token。

```js
// 调用 rotateCsrfSecret 刷新用户的 CSRF token
ctx.rotateCsrfSecret();
```

## 安全威胁 XST 的防范

- 框架已经禁止了 trace，track，options 三种危险类型请求。

## 框架提供了安全跳转的方法，可以通过配置白名单避免这种风险。

- ctx.redirect(url) 如果不在配置的白名单内，则禁止。
- ctx.unsafeRedirect(url) 一般不建议使用，明确了解可能带来的风险后使用。

## 框架提供了 .surl() 宏做 url 过滤。

- 在需要解析 url 的地方，surl 外面一定要加上双引号，否则就会导致 XSS 漏洞。

```bash
不使用 surl
<a href="$value" />
output:
<a href="http://ww.safe.com<script>" />

使用 surl 要放在双引号中
<a href="helper.surl($value)" />
output:
<a href="http://ww.safe.com&lt;script&gt;" />
```

## 框架提供了 X-Frame-Options 这个安全头来防止 iframe 钓鱼。

- 默认值为 SAMEORIGIN，只允许同域把本页面当作 iframe 嵌入。

## 安全威胁 HPP 的防范

- 框架本身会在客户端传输 key 相同而 value 不同的参数时，强制使用第一个参数，因此不会导致 hpp 攻击。

## 中间人攻击与 HTTP / HTTPS

- 在没有 HTTPS 时，运营商可在用户发起请求时直接跳转到某个广告，
- 或者直接改变搜索结果插入自家的广告。如果劫持代码出现了 BUG ，则直接让用户无法使用，出现白屏。
- HTTPS 做的就是给请求加密，让其对用户更加安全。除了保障用户利益外，还可避免本属于自己的流量被挟持，以保护自身利益。
- HTTP 严格传输安全（HSTS），如果不使用 HSTS，当用户在浏览器中输入网址时没有加 HTTPS，浏览器会默认使用 HTTP 访问
- 框架提供了 hsts Strict-Transport-Security 这个头的默认开启。让 HTTPS 站点不跳转到 HTTP
  如果我们的 Web 站点是 http 站点，需要关闭这个头。配置如下：
  maxAge 默认一年 365 _ 24 _ 3600。
  includeSubdomains 默认 false, 可以添加子域名，保证所有子域名都使用 HTTPS 访问。

## 安全威胁 SSRF 的防范

- 通过对解析域名后得到的 IP 做过滤，禁止访问内部 IP 地址来达到防范 SSRF 攻击的目的。
- 框架在 ctx, app 和 agent 上都提供了 safeCurl 方法，在发起网络请求的同时会对指定的内网 IP 地址过滤
- 该方法和框架提供的 curl 方法一致。

```bash
ctx.safeCurl(url, options)
app.safeCurl(url, options)
agent.safeCurl(url, options)
```

- 直接调用 safeCurl 方法其实并没有任何作用，还需要配合安全配置项。
  ipBlackList(Array) -  配置内网 IP 名单，在这些网段内的 IP 地址无法被访问。
  checkAddress(Function) - 直接配置一个检查 IP 地址的函数，
  根据函数的返回值来判断是否允许在 safeCurl 中被访问，当返回非 true 时，该 IP 无法被访问。
  checkAddress 优先级高于 ipBlackList。

```js
// config/config.default.js
exports.security = {
  ssrf: {
    ipBlackList: [
      '10.0.0.0/8', // 支持 IP 网段
      '0.0.0.0/32',
      '127.0.0.1' // 支持指定 IP 地址
    ],
    // 配置了 checkAddress 时，ipBlackList 不会生效
    checkAddress(ip) {
      return ip !== '127.0.0.1';
    }
  }
};
```

## 其他安全工具

```bash
ctx.isSafeDomain(domain)
是否为安全域名。安全域名在配置中配置，见 ctx.redirect 部分。

app.injectCsrf(str)
这个函数提供了模板预处理－自动插入 CSRF key 的能力，可以自动在所有的 form 标签中插入 CSRF 隐藏域，用户就不需要手动写了。

app.injectNonce(str)
这个函数提供了模板预处理－自动插入 nonce 的能力，如果网站开启了 CSP 安全头，并且想使用 CSP 2.0 nonce 特性，可以使用这个函数。参考 CSP 是什么。

这个函数会扫描模板中的 script 标签，并自动加上 nonce 头。

app.injectHijackingDefense(str)
对于没有开启 HTTPS 的网站，这个函数可以有限的防止运营商劫持。
```

## 配置

- 传递 CSRF token 的字段可以在配置中改变：

```js
// config/config.default.js
module.exports = {
  security: {
    csrf: {
      queryName: '_csrf', // 通过 query 传递 CSRF token 的默认字段为 _csrf
      bodyName: '_csrf' // 通过 body 传递 CSRF token 的默认字段为 _csrf
    }
  }
};
```

- 通过 header 传递 CSRF token 的字段也可以在配置中改变：

```js
// config/config.default.js
module.exports = {
  security: {
    csrf: {
      headerName: 'x-csrf-token' // 通过 header 传递 CSRF token 的默认字段为 x-csrf-token
    }
  }
};
```

- 将 token 存放到 Session 中

```js
// config/config.default.js
module.exports = {
  security: {
    csrf: {
      useSession: true, // 默认为 false，当设置为 true 时，将会把 csrf token 保存到 Session 中
      cookieName: 'csrfToken', // Cookie 中的字段名，默认为 csrfToken
      sessionName: 'csrfToken' // Session 中的字段名，默认为 csrfToken
    }
  }
};
```

- 基本上所有的现代浏览器都不允许跨域发起 content-type 为 JSON 的请求
  设置直接放过类型的 JSON 格式的请求

```js
// config/config.default.js
module.exports = {
  security: {
    csrf: {
      ignoreJSON: true // 默认为 false，当设置为 true 时，将会放过所有 content-type 为 `application/json` 的请求
    }
  }
};
```

- 设置跳转白名单
  若用户没有配置 domainWhiteList 或者 domainWhiteList 数组内为空，则默认会对所有跳转请求放行

```js
// config/config.default.js
exports.security = {
  domainWhiteList: ['.domain.com'] // 安全白名单，以 . 开头
};
```

- 内网 ip 地址访问过滤

```js
// config/config.default.js
exports.security = {
  ssrf: {
    ipBlackList: [
      '10.0.0.0/8', // 支持 IP 网段
      '0.0.0.0/32',
      '127.0.0.1' // 支持指定 IP 地址
    ],
    // 配置了 checkAddress 时，ipBlackList 不会生效
    checkAddress(ip) {
      return ip !== '127.0.0.1';
    }
  }
};
```
