# 基础

- 安装及编译 TypeScript

```bash
# 安装
npm install -g typescript
# 编译
tsc hello.ts
```

```bash
1.tsconfig.json 中配置 noEmitOnError 发生编译错误的时候不生成js文件
```

## 原始数据类型

```bash
## 布尔值、数值、字符串、null、undefined, Symbol
boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数

## 可以用 void 表示没有任何返回值的函数：
只能将它赋值为 undefined 和 null

## undefined 和 null
undefined 和 null 是所有类型的子类型

```

- 任意值

```bash
# 任意值（Any）用来表示允许赋值为任意类型
# 声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值
any 类型允许被赋值为任意类型
在任意值上访问任何属性都是允许的
也允许调用任何方法
变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型
```

- 类型推论

```bash
# 如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型
# 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查
# 联合类型使用 | 分隔每个类型
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;

# 访问联合类型的属性或方法
只能访问此联合类型的所有类型里共有的属性或方法
联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型

```

## 对象类型

- 接口

```bash
## 接口是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）
## TypeScript 中的接口也常用于对「对象的形状（Shape）」进行描述
interface Person {
    name: string;
    age: number;
}

let tom: Person = {
    name: 'Tom',
    age: 25
};

# 可选属性
interface Person {
    name: string;
    age?: number;
}

let tom: Person = {
    name: 'Tom'
};

# 任意属性
# 一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集
interface Person {
    name: string;
    age?: number;
    [propName: string]: any;
}

let tom: Person = {
    name: 'Tom',
    gender: 'male'
};

# 只读属性
字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性
interface Person {
    readonly id: number;
    name: string;
    age?: number;
    [propName: string]: any;
}

let tom: Person = {
    id: 89757,
    name: 'Tom',
    gender: 'male'
};
```

- 数组的类型

```bash
# 「类型 + 方括号」表示法
let fibonacci: number[] = [1, 1, 2, 3, 5];

# 数组泛型
let fibonacci: Array<number> = [1, 1, 2, 3, 5];

# 用接口表示数组
interface NumberArray {
    [index: number]: number;
}
let fibonacci: NumberArray = [1, 1, 2, 3, 5];

# 类数组
# arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：
function sum() {
  let args: {
    [index: number]: number;
    length: number;
    callee: Function;
  } = arguments;
}

# IArguments 是 TypeScript 中定义好了的类型，它实际上就是
interface IArguments {
  [index: number]: any;
  length: number;
  callee: Function;
}

# 用 any 表示数组中允许出现任意类型
let list: any[] = ['xcatliu', 25, { website: 'http://xcatliu.com' }];

```

- 函数的类型

```bash
# 函数声明的类型定义
function sum(x: number, y: number): number {
  return x + y;
}

# 函数表达式的类型定义
# 在 TypeScript 的类型定义中，=> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型
let mySum: (x: number, y: number) => number = function (x: number, y: number): number {
  return x + y;
};


# 用接口定义函数的形状
interface SearchFunc {
    (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    return source.search(subString) !== -1;
}

# 可选参数
# 可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了
function buildName(firstName: string, lastName?: string) {
    if (lastName) {
        return firstName + ' ' + lastName;
    } else {
        return firstName;
    }
}
let tomcat = buildName('Tom', 'Cat');
let tom = buildName('Tom');

# 参数默认值
# 我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数
# 此时就不受「可选参数必须接在必需参数后面」的限制了
function buildName(firstName: string, lastName: string = 'Cat') {
    return firstName + ' ' + lastName;
}
let tomcat = buildName('Tom', 'Cat');
let tom = buildName('Tom');

# 剩余参数
# 使用 ...rest 的方式获取函数中的剩余参数
# 注意，rest 参数只能是最后一个参数
function push(array: any[], ...items: any[]) {
    items.forEach(function(item) {
        array.push(item);
    });
}

let a = [];
push(a, 1, 2, 3);

# 重载
# 重载允许一个函数接受不同数量或类型的参数时，作出不同的处理
# 能清晰地表达输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串
# 重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现
# TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面
function reverse(x: number): number;
function reverse(x: string): string;
function reverse(x: number | string): number | string {
    if (typeof x === 'number') {
        return Number(x.toString().split('').reverse().join(''));
    } else if (typeof x === 'string') {
        return x.split('').reverse().join('');
    }
}
```

- 类型断言

```bash
# 类型断言（Type Assertion）可以用来手动指定一个值的类型

# 语法
# 在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用后一种
# 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的
<类型>值
function getLength(something: string | number): number {
    if ((<string>something).length) {
        return (<string>something).length;
    } else {
        return something.toString().length;
    }
}

值 as 类型

```

## 声明文件

- 初步理解

```bash
# 当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能
# 引入jQuery后的类型声明
# 声明语句 declare var 并没有真的定义一个变量，只是定义了全局变量 jQuery 的类型，
# 仅仅会用于编译时的检查
declare var jQuery: (selector: string) => any;
```

- 什么事声明文件

```bash
# 声明文件必需以 .d.ts 为后缀
# tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 jQuery.d.ts 文件
# 自动引入只在你使用了全局的声明（相反于模块）时是重要的。 如果你使用 import "foo"语句，TypeScript仍然会查找node_modules和node_modules/@types文件夹来获取foo包。
# jQuery.d.ts 放到项目中时，其他所有 *.ts 文件就都可以获得 jQuery 的类型定义了
/path/to/project
├── src
|  ├── index.ts
|  └── jQuery.d.ts
└── tsconfig.json
// src/jQuery.d.ts
declare var jQuery: (selector: string) => any;

// src/index.ts
jQuery('#foo');

# 全局变量这种模式的声明文件的相关配置选项

# files、include 和 exclude 配置
# files 指定一个包含相对或绝对文件路径的列表。
# 通过 "files"属性明确指定的文件却总是会被包含在内，不管"exclude"如何设置
"files": [
  "core.ts",
]
# include和exclude属性指定一个文件glob匹配模式列表。 支持的glob通配符有：
# "exclude"默认情况下会排除node_modules，bower_components，jspm_packages和<outDir>目录。
* 匹配0或多个字符（不包括目录分隔符）
? 匹配一个任意字符（不包括目录分隔符）
**/ 递归匹配任意子目录
"include": [
  "src/**/*"
],
"exclude": [
  "node_modules",
  "**/*.spec.ts"
]

# 编译器默认包含当前目录和子目录下所有的TypeScript文件
# 指定了 "files"或"include"，编译器会将它们结合一并包含进来
# "outDir"指定的目录下的文件永远会被编译器排除，除非你明确地使用"files"将其包含进来（这时就算用exclude指定也没用）

# 需要注意编译器不会去引入那些可能做为输出的文件；比如，假设我们包含了index.ts，那么index.d.ts和index.js会被排除在外。
# 通常来讲，不推荐只有扩展名的不同来区分同目录下的文件。

# @types，
默认所有可见的"@types"包会在编译过程中被包含进来。 node_modules/@types文件夹下以及它们子文件夹下的所有包都是可见的

# typeRoots
指定了typeRoots，只有typeRoots下面的包才会被包含进来
这个配置文件会包含所有./typings下面的包，而不包含./node_modules/@types里面的包

{
"compilerOptions": {
  "typeRoots" : ["./typings"]
}
}

# types
如果指定了types，只有被列出来的包才会被包含进来
这个tsconfig.json文件将仅会包含 ./node_modules/@types/node，./node_modules/@types/lodash和./node_modules/@types/express。
/@types/。 node_modules/@types/*里面的其它包不会被引入进来。
{
  "compilerOptions": {
  "types" : ["node", "lodash", "express"]
 }
}

# 使用extends继承配置
在原文件里的配置先被加载，然后被来至继承文件里的配置重写
{
 "extends": "./configs/base",
 "files": [
  "main.ts",
  "supplemental.ts"
 ]
}

# compileOnSave
可以让IDE在保存文件的时候根据tsconfig.json重新生成文件
{
  "compileOnSave": true,
  "compilerOptions": {
    "noImplicitAny" : true
  }
}

```

- 引入第三方库的声明文件

```bash
# @types 统一管理第三方库的声明文件
# @types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：
npm install @types/jquery --save-dev
```

- 书写声明文件

```bash
# 全局变量
如果是以 npm install @types/xxx --save-dev 安装的，则不需要任何配置
如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 src 目录下（或者对应的源码目录下）
如果没有生效，可以检查下 tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 jQuery.d.ts 文件
/path/to/project
├── src
|  ├── index.ts
|  └── jQuery.d.ts
└── tsconfig.json

# 全局变量的声明文件
# declare var | declare let | declare const
使用 const 定义时，表示此时的全局变量是一个常量，不允许再去修改它的值了
declare const jQuery: (selector: string) => any;
jQuery('#foo');
// 使用 declare const 定义的 jQuery 类型，禁止修改这个全局变量
jQuery = function(selector) {
    return document.querySelector(selector);
};
// ERROR: Cannot assign to 'jQuery' because it is a constant or a read-only property

# declare function 定义全局函数
declare function 用来定义全局函数的类型
jQuery 其实就是一个函数，所以也可以用 function 来定义：

支持函数重载
// src/jQuery.d.ts
declare function jQuery(selector: string): any;
declare function jQuery(domReadyCallback: () => any): any;

# declare class 定义全局类
// src/Animal.d.ts
declare class Animal {
    name: string;
    constructor(name: string);
    sayHi(): string;
}

# declare enum
使用 declare enum 定义的枚举类型也称作外部枚举（Ambient Enum)
declare enum Directions {
  Up,
  Down,
  Left,
  Right
}
// 使用
let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];

# declare namespace 定义命名空间 用于处理模块化问题
namespace 被淘汰了，但是在声明文件中，declare namespace 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。
比如 jQuery 是一个全局变量，它是一个对象，提供了一个 jQuery.ajax 方法可以调用
// src/jQuery.d.ts
declare namespace jQuery {
  function ajax(url: string, settings?: any): void;
  const version: number;
  class Event {
    blur(eventType: EventType): void
  }
  enum EventType {
    CustomClick
  }
}

// src/index.ts
jQuery.ajax('/api/get_something');

嵌套的命名空间
declare namespace jQuery {
  function ajax(url: string, settings?: any): void;
  namespace fn {
    function extend(object: any): void;
  }
}

jQuery 下仅有 fn 这一个属性（没有 ajax 等其他属性或方法），则可以不需要嵌套 namespace
declare namespace jQuery.fn {
  function extend(object: any): void;
}

# interface 和 type
type 与 interface 类似

两者的使用
interface User {
 name: string
 age: number
}

type User = {
 name: string
 age: number
};

两者可以相互扩展
1.interface extends interface
interface Name {
 name: string;
}
interface User extends Name {
 age: number;
}

2.type extends type
type Name = {
 name: string;
}
type User = Name & { age: number };

3.interface extends type
type Name = {
 name: string;
}
interface User extends Name {
 age: number;
}

4.type extends interface
interface Name {
 name: string;
}
type User = Name & {
 age: number;
}

## type 可以而 interface 不行
type 可以声明基本类型别名，联合类型，元组等类型
// 基本类型别名
type Name = string

// 联合类型
interface Dog {
 wong();
}
interface Cat {
 miao();
}

type Pet = Dog | Cat

// 具体定义数组每个位置的类型
type PetList = [Dog, Pet]

# type 语句中还可以使用 typeof 获取实例的 类型进行赋值
// 当你想获取一个变量的类型时，使用 typeof
let div = document.createElement('div');
type B = typeof div

# interface 可以而 type 不行
# interface 能够声明合并
interface User {
 name: string
 age: number
}

interface User {
 sex: string
}

/*
User 接口为 {
 name: string
 age: number
 sex: string
}
*/

# 使用 interface 或 type 来声明一个全局的接口或类型
interface AjaxSettings {
  method?: 'GET' | 'POST'
  data?: any;
}
declare namespace jQuery {
  function ajax(url: string, settings?: AjaxSettings): void;
}

# 声明合并
可以组合多个声明语句，它们会不冲突的合并起来
declare function jQuery(selector: string): any;
declare namespace jQuery {
  function ajax(url: string, settings?: any): void;
}

```

- npm 包

```bash
# 推荐的声明文件放置位置及配置
创建一个 types 目录，专门用来管理自己写的声明文件，将 foo 的声明文件放到 types/foo/index.d.ts 中。
这种方式需要配置下 tsconfig.json 中的 paths 和 baseUrl 字段。
/path/to/project
├── src
|  └── index.ts
├── types
|  └── foo
|     └── index.d.ts
└── tsconfig.json

下面配置后 通过 import 导入 foo 的时候，也会去 types 目录下寻找对应的模块的声明文件了
{
"compilerOptions": {
  "module": "commonjs",
  "baseUrl": "./",
  "paths": {
      "*": ["types/*"] // 此处映射是相对于"baseUrl"
      "jquery": ["node_modules/jquery/dist/jquery"] // 此处映射是相对于"baseUrl"
    }
  }
}

## export
在 npm 包的声明文件中，使用 declare 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。
只有在声明文件中使用 export 导出，然后在使用方 import 导入后，才会应用到这些类型声明
// types/foo/index.d.ts
export const name: string;
export function getName(): string;
export class Animal {
    constructor(name: string);
    sayHi(): string;
}
export enum Directions {
    Up,
    Down,
    Left,
    Right
}
export interface Options {
    data: any;
}

// src/index.ts文件中导入 对应的模块
import { name, getName, Animal, Directions, Options } from 'foo';

# 可以使用 declare 先声明多个变量，最后再用 export 一次性导出
// types/foo/index.d.ts

declare const name: string;
declare function getName(): string;
declare class Animal {
    constructor(name: string);
    sayHi(): string;
}
declare enum Directions {
    Up,
    Down,
    Left,
    Right
}
interface Options {
    data: any;
}

export { name, getName, Animal, Directions, Options };

# export namespace 用来导出一个拥有子属性的对象
// types/foo/index.d.ts
export namespace foo {
  const name: string;
  namespace bar {
    function baz(): string;
  }
}

# export default
在 ES6 模块系统中，使用 export default 可以导出一个默认值
在 ES6 中导入对应的模块
import foo from 'foo'

在类型声明文件中，export default 用来导出默认值的类型
function、class 和 interface 可以直接默认导出，其他的变量需要先定义出来，再默认导出
// types/foo/index.d.ts
export default function foo(): string;

// src/index.ts
import foo from 'foo';
foo();

针对这种默认导出，我们一般会将导出语句放在整个声明文件的最前面
// types/foo/index.d.ts
export default Directions;
declare enum Directions {
  Up,
  Down,
  Left,
  Right
}

# 在 commonjs 规范中
在 commonjs 规范中导出文件
// 整体导出
module.exports = foo;
// 单个导出
exports.bar = bar;

# 第一种导入commonjs模块的方式
// 整体导入
const foo = require('foo');
// 单个导入
const bar = require('foo').bar;

# 第二种方式是 import ... from，注意针对整体导出，需要使用 import * as 来导入
// 整体导入
import * as foo from 'foo';
// 单个导入
import { bar } from 'foo';

# 第三种方式是 import ... require，这也是 ts 官方推荐的方式
// 整体导入
import foo = require('foo');
// 单个导入
import bar = foo.bar;

# 对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 export = 这种语法
# 使用了 export = 之后，就不能再单个导出 export { bar }
# import ... require 和 export = 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用
// types/foo/index.d.ts
export = foo;
declare function foo(): string;
declare namespace foo {
    const bar: number;
}

```

- UMD 库的类型声明文件写法

```bash
# 既可以通过 <script> 标签引入，又可以通过 import 导入的库，称为 UMD 库。
# 一般使用 export as namespace 时，都是先有了 npm 包的声明文件，再基于它添加一条 export as namespace 语句，
# 即可将声明好的一个变量声明为全局变量

// types/foo/index.d.ts
export as namespace foo;
export = foo;

declare function foo(): string;
declare namespace foo {
    const bar: number;
}

# 与 export default 一起使用
// types/foo/index.d.ts

export as namespace foo;
export default foo;

declare function foo(): string;
declare namespace foo {
    const bar: number;
}
```

- 直接扩展全局变量

```bash
# 扩展全局变量的类型
# 通过声明合并，使用 interface String 即可给 String 添加属性或方法
interface String {
    prependHello(): string;
}
// 使用
'foo'.prependHello();

# 也可以使用 declare namespace 给已有的命名空间添加类型声明
// types/jquery-plugin/index.d.ts

declare namespace JQuery {
  interface CustomOptions {
    bar: string;
  }
}

interface JQueryStatic {
  foo(options: JQuery.CustomOptions): string;
}

```

- 在 npm 包或 UMD 库中扩展全局变量

```bash
# 需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 declare global
# 使用 declare global 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型
# 注意即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。
使用 declare global 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型
// types/foo/index.d.ts

declare global {
  interface String {
    prependHello(): string;
  }
}

export {};

// src/index.ts
'bar'.prependHello();

```

- 模块插件

```bash
# ts 提供了一个语法 declare module，它可以用来扩展原有模块的类型
# 如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用 declare module 扩展原有模块
// types/moment-plugin/index.d.ts
import * as moment from 'moment';
declare module 'moment' {
    export function foo(): moment.CalendarKey;
}

// src/index.ts
import * as moment from 'moment';
import 'moment-plugin';

moment.foo();

# declare module 也可用于在一个文件中一次性声明多个模块的类型
// types/foo-bar.d.ts

declare module 'foo' {
  export interface Foo {
    foo: string;
  }
}

declare module 'bar' {
  export function bar(): string;
}

// src/index.ts

import { Foo } from 'foo';
import * as bar from 'bar';

let f: Foo;
bar.bar();

```

- 声明文件的导入方式

```bash

# import 导入另一个声明文件

// types/moment-plugin/index.d.ts

import * as moment from 'moment';

declare module 'moment' {
    export function foo(): moment.CalendarKey;
}

# 通过三斜线指令导入另一个声明文件
使用场景
1.当我们在书写一个全局变量的声明文件时
2.当我们需要依赖一个全局变量的声明文件时

# 在全局变量的声明文件中，是不允许出现 import, export 关键字的
# 一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了
# 三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释
// types/jquery-plugin/index.d.ts
/// <reference types="jquery" />
declare function foo(options: JQuery.AjaxSettings): string;

# 需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 import 导入，当然也就必须使用三斜线指令来引入了
// types/node-plugin/index.d.ts
/// <reference types="node" />
export function foo(p: NodeJS.Process): string;

# 不是必要使用三斜线指令的情况下，就都需要使用 import 来导入

```

- 拆分声明文件

```bash
# 当我们的全局变量的声明文件太大时，可以通过拆分为多个文件
# types 用于声明对另一个库的依赖，而 path 用于声明对另一个文件的依赖
// node_modules/@types/jquery/index.d.ts

/// <reference types="sizzle" />
/// <reference path="JQueryStatic.d.ts" />
/// <reference path="JQuery.d.ts" />
/// <reference path="misc.d.ts" />
/// <reference path="legacy.d.ts" />

export = jQuery;

```

- 自动生成声明文件

```bash
# 如果库的源码本身就是由 ts 写的，那么在使用 tsc 脚本将 ts 编译为 js 的时候，
# 添加 declaration 选项，就可以同时也生成 .d.ts 声明文件了
# outDir 选项，将 ts 文件的编译结果输出到 lib 目录下
# declaration 选项，设置为 true，表示将会由 ts 文件自动生成 .d.ts 声明文件，也会输出到 lib 目录下

{
  "compilerOptions": {
  "module": "commonjs",
  "outDir": "lib",
  "declaration": true,
  }
}

```

- 将声明文件和源码放在一起

```bash
# 如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别：
# 给 package.json 中的 types 或 typings 字段指定一个类型声明文件地址
# 指定了 types 为 foo.d.ts 之后，导入此库的时候，就会去找 foo.d.ts 作为此库的类型声明文件了。
# typings 与 types 一样，只是另一种写法。
{
    "name": "foo",
    "version": "1.0.0",
    "main": "lib/index.js",
    "types": "foo.d.ts",
}
# 在项目根目录下，编写一个 index.d.ts 文件
# 如果没有指定 types 或 typings，那么就会在根目录下寻找 index.d.ts 文件，将它视为此库的类型声明文件

# 针对入口文件（package.json 中的 main 字段指定的入口文件），编写一个同名不同后缀的 .d.ts 文件
# 如果没有找到 index.d.ts 文件，那么就会寻找入口文件（package.json 中的 main 字段指定的入口文件）是否存在对应同名不同后缀的 .d.ts 文件。
{
  "name": "foo",
  "version": "1.0.0",
  "main": "lib/index.js"
}

# 有的库为了支持导入子模块，比如 import bar from 'foo/lib/bar'，
# 就需要额外再编写一个类型声明文件 lib/bar.d.ts 或者 lib/bar/index.d.ts，这与自动生成声明文件类似，一个库中同时包含了多个类型声明文件
```

## 内置对象

```bash

# 内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。
# ECMAScript 标准提供的内置对象有 Boolean、Error、Date、RegExp 等
let b: Boolean = new Boolean(1);
let e: Error = new Error('Error occurred');
let d: Date = new Date();
let r: RegExp = /[a-z]/;

# DOM 和 BOM 提供的内置对象有：
Document、HTMLElement、Event、NodeList 等。
let body: HTMLElement = document.body;
let allDiv: NodeList = document.querySelectorAll('div');
document.addEventListener('click', function(e: MouseEvent) {
  // Do something
});

# 用 TypeScript 写 Node.js
引入第三方声明问题
npm install @types/node --save-dev

```
