# 项目经验总结

## 联合类型与交叉类型

- 联合类型

```ts
interface Foo {
  foo: string;
  name: string;
}

interface Bar {
  bar: string;
  name: string;
}

const sayHello = (obj: Foo | Bar) => {
  // 在 sayHello 内部只能访问 obj.name，因为它是两种类型都包含的唯一属性
  obj.name;
};

sayHello({ foo: 'foo', name: 'lolo' });
sayHello({ bar: 'bar', name: '
```

- 交叉类型

```ts
/**
 * TypeScript 交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。
 */
interface IPerson {
  id: string;

  age: number;
}

interface IWorker {
  companyId: string;
}

type IStaff = IPerson & IWorker;

const staff: IStaff = {
  id: 'E1006',
  age: 33,
  companyId: 'EXE',
};

/**
 * 如果交叉的类型中存在相同的key但是类型不同 多个类型的时候会进行合并
 */

interface X {
  c: string;

  d: string;
}

interface Y {
  c: number;

  e: string;
}
// 混入后成员 c 的类型为 string&number，即成员 c 的类型既是 string 类型又是number 类型。
// 很明显这种类型是不存在的，所以混入后成员 c 的类型为 never
type XY = X & Y;
```

- 交叉类型的使用案例

```ts
// 基础接口
export interface ArgBase<T> {
  name?: string;

  description?: string;

  hidden?: boolean;

  parse: ParseFn<T>;

  default?: T | (() => T);

  input?: string;

  options?: string[];
}

// 请求参数接口1
export type RequiredArg<T> = ArgBase<T> & {
  required: true;
  value: T;
};

// 请求参数接口2
export type OptionalArg<T> = ArgBase<T> & {
  required: false;
  value?: T;
};
```

## 索引类型

- keyof 的用法

```ts
/**
 * keyof 可以用于获取某种类型的所有键，其返回类型是联合类型
 */

// 对接口的支持
interface Person {
  name: string;
  age: number;
  location: string;
}

type K1 = keyof Person; // "name" | "age" | "location"
type K2 = keyof Person[]; // number | "length" | "push" | "concat" | ...
type K3 = keyof { [x: string]: Person }; // string | number

// 对类的支持
class Person {
  name: string = 'Semlinker';
}

let sname: keyof Person;
sname = 'name';

// 对基础类型的支持
let K1: keyof boolean; // let K1: "valueOf"
let K2: keyof number; // let K2: "toString" | "toFixed" | "toExponential" | ...
let K3: keyof symbol; // let K1: "valueOf"
```

- keyof 的运用

```ts
type Todo = {
  id: number;
  text: string;
  done: boolean;
};

const todo: Todo = {
  id: 1,
  text: 'Learn TypeScript keyof',
  done: false,
};

function prop<T extends object, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}

const id = prop(todo, 'id'); // const id: number
const text = prop(todo, 'text'); // const text: string
const done = prop(todo, 'done'); // const done: boolean
```

- keyof 与对象的数值属性

```ts
enum Currency {
  CNY = 6,
  EUR = 8,
  USD = 10,
}

const CurrencyName = {
  [Currency.CNY]: '人民币',
  [Currency.EUR]: '欧元',
  [Currency.USD]: '美元',
};

function getCurrencyName<T, K extends keyof T>(key: K, map: T): T[K] {
  return map[key];
}

console.log(`name = ${getCurrencyName(Currency.CNY, CurrencyName)}`);
```

- keyof 与 typeof 操作符

```ts
/**
 * typeof 操作符用于获取变量的类型。因此这个操作符的后面接的始终是一个变量，且需要运用到类型定义当中。
 */
const COLORS = {
  red: 'red',
  blue: 'blue',
};

// 首先通过typeof操作符获取color变量的类型，然后通过keyof操作符获取该类型的所有键，
// 即字符串字面量联合类型 'red' | 'blue'
type Colors = keyof typeof COLORS;
let color: Colors;
color = 'red'; // Ok
color = 'blue'; // Ok

// Type '"yellow"' is not assignable to type '"red" | "blue"'.
color = 'yellow'; // Error
```

- keyof 特殊用例

```ts
interface StringIndexArray {
  [index: string]: string;
}

interface NumberIndexArray {
  [index: number]: string;
}

type K1 = keyof StringIndexArray; // type K1 = string | number
type K2 = keyof NumberIndexArray; // type K2 = number
```

## TypeScript 设计模式之适配器模式

- 日志系统适配器完整示例

```ts
// 接口定义

interface Logger {
  info(message: string): Promise<void>;
}

interface CloudLogger {
  sendToServer(message: string, type: string): Promise<void>;
}

// 日志实现类
class AliLogger implements CloudLogger {
  public async sendToServer(message: string, type: string): Promise<void> {
    console.info(message);

    console.info('This Message was saved with AliLogger');
  }
}

// 适配器

class CloudLoggerAdapter implements Logger {
  protected cloudLogger: CloudLogger;

  constructor(cloudLogger: CloudLogger) {
    this.cloudLogger = cloudLogger;
  }

  public async info(message: string): Promise<void> {
    await this.cloudLogger.sendToServer(message, 'info');
  }
}

// 通知服务类
class NotificationService {
  protected logger: Logger;

  constructor(logger: Logger) {
    this.logger = logger;
  }

  public async send(message: string): Promise<void> {
    await this.logger.info(`Notification sended: ${message}`);
  }
}

// 使用示例
(async () => {
  const aliLogger = new AliLogger();
  const cloudLoggerAdapter = new CloudLoggerAdapter(aliLogger);
  const notificationService = new NotificationService(cloudLoggerAdapter);
  await notificationService.send('Hello Kakuqo, To Cloud');
})();
```
