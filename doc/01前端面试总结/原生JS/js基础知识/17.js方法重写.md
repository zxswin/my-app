## js 方法重写

- call 方法重写

```ts
Function.prototype.myCall = function (ctx) {
  ctx = ctx ? Object(ctx) : window;
  ctx.originFn = this; // this 就是对于方法的引用

  const args = [];

  // 拿到myCall的第二个参数开始到结束的所有参数作为方法的实参列表
  for (let i = 1; i < arguments.length; i++) {
    args.push(`arguments[${i}]`);
  }

  // 使用eval执行
  const ret = eval(`ctx.originFn(${args})`);
  delete ctx.originFn; // 删除属性

  return ret;
};

// 测试代码
const obj = {
  a: 1,
  b: 2,
  test: function () {
    console.log(this.a);
    console.log('arguments', arguments);
  },
};

obj.test();

obj.test.myCall({ a: 5 }, 1, 2, 3);
```

- apply 方法的重写

```ts
/**
 * apply -> 第二个参数是参数列表
 * apply -> 只取到第二个参数 -> 第三个参数开始到后面忽略
 * apply -> 第二个参数可以是null 或 undefined 但是argument.length = 0
 * apply -> 如果第二个参数是原始值的话会报错
 */

Function.prototype.myApply = function (ctx, args) {
  ctx = ctx ? Object(ctx) : window;
  ctx.originFn = this;

  if (typeof args !== 'object' && typeof args !== 'function') {
    throw new TypeError('参数是原始类型,报错');
  }

  if (!Array.isArray(args)) {
    // 如果不是数组则直接执行
    return ctx.originFn();
  }

  let ret = eval(`ctx.originFn(${args})`);

  return ret;
};

// 测试代码
const obj = {
  a: 1,
  b: 2,
  test: function () {
    console.log(this.a);
    console.log('arguments', arguments);
  },
};

obj.test();

obj.test.myApply({ a: 5 }, [1, 2, 3]);
```

- bind 方法重写

```ts
/**
 * bind后函数不执行而是返回一个新的函数
 * bind的第一个参数传入要绑定的this对象
 * bind可以分离test的参数
 * bind接收一部分的参数 返回的新函数接收一部分参数
 * bing 和 call的参数传递规则是一样的
 * 实例化返回的新函数 -> this 指向的是test的实例
 * 实例应该基础test构造函数上的原型属性
 */

Function.prototype.myBind = function (ctx) {
  let originFn = this;
  // bind传递的test的参数
  args = [].slice.call(arguments, 1);

  const _tempFn = function () {};

  const newFn = function () {
    // 返回的新函数t的参数列表
    var newArgs = [].slice.call(arguments);
    return originFn.apply(
      this instanceof newFn ? this : ctx,
      args.concat(newArgs)
    );
  };

  // 原型的继承
  _tempFn.prototype = this.prototype;
  newFn.prototype = new _tempFn();

  return newFn;
};

// 测试代码
function test(user, car) {
  console.log(`${user}刚刚买了一辆${car}车`);
  console.log(this, arguments);
}

const t = test.myBind(
  {
    a: 1,
    b: 2,
  },
  '张三丰'
);

t('奔驰');

const newT = new t('奔驰');
console.log(newT); // 指向原来的方法
```

- 重写 instanceof 方法

```ts
function instanceOf(target, type) {
  type = type.prototype;
  target = target.__proto__;

  while (true) {
    if (target === null) {
      return false;
    }
    if (target === type) {
      return true;
    }

    target = target.__proto__;
  }
}

// 测试代码
class A {
  constructor() {
    this.a = 1;
  }
}

const a = new A();

console.log(instanceOf(a, A));
```

- new 方法重写

```ts
function _new(fn, ...arg) {
  const obj = Object.create(fn.prototype);
  const ret = fn.apply(obj, arg);
  return ret instanceof Object ? ret : obj;
}
```
