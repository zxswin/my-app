## WebSocket

- 概念与原理部分

```ts
/**
 * WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。
 * 让浏览器和服务器之间建立无限制的全双工通信，任何一方都可以主动发消息给对方。
 * WebSocket 连接必须由浏览器发起，因为请求协议是一个标准的 HTTP 请求
 * 握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
 * 数据格式比较轻量，性能开销小，通信高效。
 * 可以发送文本，也可以发送二进制数据。
 * WebSocket 协议本身不要求同源策略（Same-origin Policy）
 * 但是，浏览器会发送 Origin 的 HTTP 头给服务器，服务器可以根据 Origin 拒绝这个 WebSocket 请求。
 * 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。
 * ws://example.com:80/some/path
 *
 * 安全的WebSocket连接机制和HTTPS类似。
 * 首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，
 * 然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议
 *
 * 连接过程
 * 浏览器发起一个标准的HTTP请求，请求头格式如下
 * 通过Upgrade等响应头告诉服务器这个连接将要被转换为WebSocket连接,并指定了WebSocket的协议版本
 * 服务器如果接受该请求，返回101响应代码
 * 表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议
 * websocket连接建立后客户端和服务器就可以进行全双工通信了
 * 
 * GET请求的地址不是类似/path/，而是以ws://开头的地址；
 * 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；
 * Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；
 * Sec-WebSocket-Version指定了WebSocket的协议版本。

 * GET ws://localhost:3000/ws/chat HTTP/1.1
 * Host: localhost
 * Upgrade: websocket
 * Connection: Upgrade
 * Origin: http://localhost:3000
 * Sec-WebSocket-Key: client-random-string
 * Sec-WebSocket-Version: 13
 * 
 * 
 * 服务器如果接受该请求，就会返回如下响应
 * 响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议
 * 版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等
 * 
 * HTTP/1.1 101 Switching Protocols
 * Upgrade: websocket
 * Connection: Upgrade
 * Sec-WebSocket-Accept: server-random-string
 *
 *
 * 实现原理
 * 实际上 HTTP 协议是建立在 TCP 协议之上的，TCP 协议本身就实现了全双工通信，但是 HTTP 协议的请求－应答机制限制了全双工通信
 */
```

## 客户端的 WebSocket

- 简单使用案例

```ts
// 执行这个语句之后，客户端就会与服务器进行连接
var ws = new WebSocket('wss://echo.websocket.org');

ws.onopen = function (evt) {
  console.log('Connection open ...');
  ws.send('Hello WebSockets!');
};

ws.onmessage = function (evt) {
  console.log('Received Message: ' + evt.data);
  ws.close();
};

ws.onclose = function (evt) {
  console.log('Connection closed.');
};
```

- webSocket.readyState

```ts
/**
 * readyState属性返回实例对象的当前状态
 * CONNECTING：值为0，表示正在连接。
 * OPEN：值为1，表示连接成功，可以通信了。
 * CLOSING：值为2，表示连接正在关闭。
 * CLOSED：值为3，表示连接已经关闭，或者打开连接失败。
 */
switch (ws.readyState) {
  case WebSocket.CONNECTING:
    // do something
    break;
  case WebSocket.OPEN:
    // do something
    break;
  case WebSocket.CLOSING:
    // do something
    break;
  case WebSocket.CLOSED:
    // do something
    break;
  default:
    // this never happens
    break;
}
```

- 常用

```ts
// webSocket.onopen
// 用于指定连接成功后的回调函数
ws.onopen = function () {
  ws.send('Hello Server!');
};

// 指定多个回调函数，可以使用addEventListener方法
ws.addEventListener('open', function (event) {
  ws.send('Hello Server!');
});

// webSocket.onclose
// 用于指定连接关闭后的回调函数
ws.onclose = function (event) {
  var code = event.code;
  var reason = event.reason;
  var wasClean = event.wasClean;
  // handle close event
};

ws.addEventListener('close', function (event) {
  var code = event.code;
  var reason = event.reason;
  var wasClean = event.wasClean;
  // handle close event
});

// webSocket.onmessage
// 用于指定收到服务器数据后的回调函数
ws.onmessage = function (event) {
  var data = event.data;
  // 处理数据
};

ws.addEventListener('message', function (event) {
  var data = event.data;
  // 处理数据
});

// 服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）
ws.onmessage = function (event) {
  if (typeof event.data === String) {
    console.log('Received data string');
  }

  if (event.data instanceof ArrayBuffer) {
    var buffer = event.data;
    console.log('Received arraybuffer');
  }
};

// 使用binaryType属性，显式指定收到的二进制数据类型
// 收到的是 blob 数据
ws.binaryType = 'blob';
ws.onmessage = function (e) {
  console.log(e.data.size);
};

// 收到的是 ArrayBuffer 数据
ws.binaryType = 'arraybuffer';
ws.onmessage = function (e) {
  console.log(e.data.byteLength);
};

// send()方法用于向服务器发送数据
ws.send('your message');

// 发送 ArrayBuffer 对象的例子
var img = canvas_context.getImageData(0, 0, 400, 320);
var binary = new Uint8Array(img.data.length);
for (var i = 0; i < img.data.length; i++) {
  binary[i] = img.data[i];
}
ws.send(binary.buffer);

// webSocket.bufferedAmount
// 实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束
var data = new ArrayBuffer(10000000);
socket.send(data);

if (socket.bufferedAmount === 0) {
  // 发送完毕
} else {
  // 发送还没结束
}

// webSocket.onerror
// 实例对象的onerror属性，用于指定报错时的回调函数。
socket.onerror = function (event) {
  // handle error event
};

socket.addEventListener('error', function (event) {
  // handle error event
});
```

## 服务端的 WebSocket

```ts
/**
 * 1.安装依赖
 * cnpm i ws -S
 */
// app.js 实例代码
// 导入 WebSocket 模块
const WebSocket = require('ws');

// 引用 Server 类
const WebSocketServer = WebSocket.Server;

// 实例化
const wss = new WebSocketServer({
  port: 3000, // 在 3000 端口上打开一个 WebSocket Server
});

// 如果有 WebSocket 请求接入 wws 对象可以响应 connection 事件来处理这个 WebSocket
wss.on('connection', function (ws) {
  console.log(`[SERVER] connection()`);
  ws.on('message', function (message) {
    console.log(`[SERVER] Received: ${message}`); //服务器接收到的信息
    setTimeout(() => {
      ws.send(`What's your name?`, (err) => {
        // 服务器发送信息
        if (err) {
          console.log(`[SERVER] error: ${err}`);
        }
      });
    }, 1000);
  });
});

console.log('ws server started at port 3000...');
```

```ts
// 客户端测试代码 实际代码中并不需要 仅用于测试
let count = 0;

let ws = new WebSocket('ws://localhost:3000/ws/chat');

ws.on('open', function () {
  console.log(`[CLIENT] open()`);
  ws.send('Hello!');
});

ws.on('message', function (message) {
  console.log(`[CLIENT] Received: ${message}`); // 客户端接收到的信息
  count++;
  if (count > 3) {
    ws.send('Goodbye!'); //客户端发送的信息
    ws.close();
  } else {
    setTimeout(() => {
      ws.send(`Hello, I'm Mr No.${count}!`); // 客户端发送的信息
    }, 1000);
  }
});
```
