## 探索 JS 中的函数秘密

```ts
let cms = function () {
  console.log('houdunren.com');
};

cms();

window.cms(); // 使用let声明的变量 不会直接放在window下面 var声明的变量则可以
```

- 立即执行函数

```ts
/* 使用立即执行函数形成独立的作用域 */
(function (window) {
  function hd() {
    console.log('模块1-hd');
  }
  function show() {
    console.log('模块2');
  }
  window.js1 = {
    hd,
    show,
  };
})(window);
```

- 默认参数的使用

```ts
// 排序函数的实现
function sortArray(array, type = 'asc') {
  return array.sort((a, b) => (type === 'asc' ? a - b : b - a));
}

console.log(sortArray([3, 4, 5, , 1, 2, 3], 'desc'));

// 一个求和函数的实现(1)

function sum() {
  // arguments是一个类数组对象
  // 类数组对象没有reduce这些数组操作的方法
  // [...arguments] 这样就可以把类数组对象转换为数组了
  console.log(arguments);
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }

  return total;
}

// 一个求和函数的实现(2)
function sum(...args) {
  return args.reduce((a, b) => a + b);
}

console.log(sum(1, 2, 3, 4, 5));
```

- 箭头函数的使用

```ts
let sum = [1, 2, 3, 4, 5, 6].reduce((a, b) => a + b);
console.log(sum);
```

- 递归函数的实现

```ts
// 递归函数实现阶乘
function factorial(num) {
  if (num === 1) {
    return 1;
  }

  return num * factorial(num - 1);
}

console.log(factorial(5));

// 递归函数实现求和
function sum(...args) {
  if (args.length === 0) {
    return 0;
  }

  return args.pop() + sum(...args);
}

console.log(sum(1, 2, 4, 6, 5, 8));

// 递归附加参数的使用技巧
// 使用递归来实现数组的遍历操作

function change(lessons, num = 100, i = 0) {
  if (i === lessons.length) {
    return lessons;
  }

  lessons[i].click += num;
  return change(lessons, num, ++i);
}

console.log(change(lessons, 90));
```

- 展开语法在函数中的使用

```ts
function sum(discount = 0, ...price) {
  let total = price.reduce((a, b) => a + b);

  return Math.round(total * (1 - discount));
}

console.log(sum(0.2, 199, 2900, 888));
```

- 函数与方法中 this 的不同

```ts
// 当前对象的引用
let edu = {
  name: 'abc',
  lists: ['js', 'css', 'mysql'],
  show: function () {
    console.log(this); // 方法是对象的属性 这里的this指向当前对象edu

    function render() {
      console.log(this); // 普通函数的this指向window
    }
    return this.name;
  },
  showList: function () {
    return this.lists.map(function (value) {
      console.log(this);
    }, this); // 如果map的第二个参数传入了this则方法体里面的this就是你传入的this,否则它会指向window
  },
};

console.log(edu.show());
```

- 箭头函数带来 this 变化的实例

```ts
/**
 * 箭头函数的this是指向当前父级作用域下的this
 */
let edu = {
  name: 'abc',
  lists: ['js', 'css', 'mysql'],

  showList: function () {
    return this.lists.map((value) => {
      console.log(this); // 这个this指向的是父级作用域下的this
    });
  },
};

// 事件处理
let Dom = {
  site: 'abc',
  handleEvent: function (event) {
    console.log(this); // 方法是对象的属性 this指向dom
  },
  bind: function () {
    const button = document.querySelector('button');
    console.log(button);
    button.addEventListener('click', this.handleEvent); // 会绑定handleEvent属性下法方法 此时的this指向的是button
  },
};

Dom.bind();
```

- this 的构造原理实现

```ts
// 新建一个构造函数
function User(name) {
  this.name = name;

  return { a: 'a1' }; // 默认隐式return出this 也可以显式return出其他
}

let list = new User('李四'); // 初始化一个构造函数

// 使用call可以改变this指向
let hdcms = { url: 'abc.com' };
User.call(hdcms, '开源系统');
console.log(hdcms); // name的属性会被加进去
```

- call 与 apply 的区别

```ts
let lisi = {
  name: '李四',
};

let wangwu = {
  name: '王五',
};

function User(web, url) {
  console.log(web + url + this.name);
}

// call 和 apply 会改变构造函数的this指针并立即调用
User.call(list, 'a', 'abc.com'); // call的参数是一个个传进去的
User.apply(list, ['a', 'abc.com']); // apply则是按数组的形式传递进去的

/* call 和 apply的使用案例 */
function show() {
  console.log(this.innerHTML);
}

let buttons = document.querySelectorAll('button');

for (let i = 0; i < buttons.length; i++) {
  buttons[i].addEventListener('click', (event) => {
    show.call(event.target); // 也可以使用apply
  });
}

/* 获取数组中的最大值 */
let arr = [1, 2, 3, 4, 5];
console.log(Math.max.apply(Math, arr));
```

- 构造函数的方法继承

```ts
/* 一个根据参数来获取文章和用户Url的方法 */
function Request() {
  this.get = function (params) {
    let str = Object.keys(params)
      .map((k) => `${k}=${params[k]}`)
      .json('&');
    let url = `https://abc.com?${this.url}/${str}`;
    console.log(url);
  };
}

function Article() {
  this.url = 'article/lists';
  Request.apply(this); // 继承Request 获取到get方法
}

let a = new Article();
console.log(a.get({ id: 1, cat: 'js' }));
```

- 一个面板切换的效果

```ts
function panel(i) {
  let dds = document.querySelectorAll('dd');

  dds.forEach((dd) => dd.setAttribute('hidden', 'hidden'));
  dds[i].removeAttribute('hidden');
}

document.querySelectorAll('dt').forEach((dt, i) => {
  dt.addEventListener('click', () => {
    panel.call(null, i); // 如果不需要改变this指向则传null
  });
});
```

- bind 的使用

```ts
/* 基本使用 */
function show() {
  console.log(this.name);
}

// call 和 apply 都会立即执行
show.apply({ name: '后盾人' });
show.call({ name: 'abc' });

// bind不会立即执行它会返回一个新的函数
let bindfn = show.bind({ name: 'efg' });
bindfn();

/* bind 参数的传递 */
function show(a, b) {
  console.log(this.name, a, b);
}
// bind不会立即执行它会返回一个新的函数
// let bindfn = show.bind({ name: "efg" }, 1, 2); // 这里也可以传递参数 如果这里传递参数则后面传递的参数将失效
let bindfn = show.bind({ name: 'efg' });
bindfn(4, 5);

/* 适合使用bind的场景 例如在事件函数中 */
document.querySelector('button').addEventListener(
  'click',
  function (event) {
    console.log(this.url + event.target.innerHTML);
  }.bind({ url: 'houdunren.com' })
);
```
