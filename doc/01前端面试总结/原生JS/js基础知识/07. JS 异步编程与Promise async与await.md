## 07. JS 异步编程与 Promise async 与 await

- 异步加载图片体验 js 异步操作

```ts
/**
 * 会先把图片加载放入异步任务的执行队列里面
 * 等主进程的任务完成后,再取执行异步任务队列里的代码
 */
function loadImage(src, resolve, reject) {
  let image = new Image();
  image.src = src;
  image.onload = resolve;
  image.onerror = reject;
}
loadImage(
  'images/1.jpg',
  () => {
    console.log('图片加载成功');
  },
  () => {
    console.log('图片加载失败');
  }
);

console.log('这个执行完成后再执行图片加载任务');
```

- 定时器的任务轮询

```ts
function interval(callback, delay = 50) {
  let id = setInterval(callback(id), delay);
}

interval((timeId) => {
  const div = document.querySelector('div');
  let left = parseInt(window.getComputedStyle(div).left);
  div.style.left = left + 10 + 'px';

  if (left >= 200) {
    clearInterval(timeId);
  }
});

console.log('abc.com');
```

- 通过任务依赖了解任务排序

```ts
function load(src, resolve) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = resolve;
  document.body.appendChild(script);
}

// 1.js 和 2.js的加载顺序是不定的谁快就先加载谁
load('./1.js', () => {
  hd();
});

load('./2.js', () => {
  houdunren();
});

// 解决方法 先加载1.js 在1.js的回调中取加载2.js
load('./1.js', () => {
  hd();
  load('./2.js', () => {
    houdunren();
  });
});
console.log('主进程代码先执行');
```

- ajax 异步请求任务管理

```ts
// ajax是一种异步任务
// 主进程先执行完毕后再执行异步任务
```

- promise 的微任务处理机制

```ts
/**
 * 任务队列分为 宏任务队列 和 微任务队列
 * 微任务队列的执行优先级比宏队列的优先级要高
 * 定时器这类属于宏任务队列
 * Promise这类属于微任务队列
 */

// pending 准备阶段
// resolved 成功状态
// rejected 拒绝状态
new Promise((resolve, reject) => {
  const random = Math.random();
  if (random > 0.5) {
    resolve('执行成功');
  } else {
    reject('执行失败');
  }
}).then(
  (value) => {
    console.log(value);
  },
  (reason) => {
    console.log(reason);
  }
);
```

- 宏任务与微任务的执行顺序

```ts
setTimeout(() => {
  console.log('setTimeout会放入宏任务队列中,执行优先级小于微任务队列中的任务');
}, 0);

new Promise((resolve) => {
  console.log('这里的代码会同步执行');
  resolve();
}).then((value) => console.log('这里的代码会放入到微任务队列里异步执行'));

console.log('同步执行');
```

- 宏任务的提升原来是误解

```ts
setTimeout(() => {
  console.log('setTimeout会放入宏任务队列中,执行优先级小于微任务队列中的任务');
}, 0);

new Promise((resolve) => {
  setTimeout(() => {
    resolve();
    console.log(
      '微任务是在宏任务的执行过程中创建的,要等宏任务执行完成后再执行'
    );
  }, 0);

  console.log('这里的代码会同步执行');
}).then((value) => console.log('这里的代码会放入到微任务队列里异步执行'));

console.log('同步执行');
```

- promise 单一状态与状态中转

```ts
// promise是单向的不可逆的
new Promise((resolev, reject) => {
  resolev('成功');
  reject('失败'); // 这里将永远不会被执行
});
```

- promise.then 的基本语法

```ts
new Promise((resolev, reject) => {
  // resolev("一瓶可乐");
  reject('涨价了,买不起了');
}).then(null, (reason) => {
  // 如果只关注失败的情况,那么第一个参数可以传入null
  console.log('reason', reason);
});
```

- promise.then 也是一个 promise

```ts
let p1 = new Promise((resolve, reject) => {
  // resolve("fulfilled");
  reject('rejected');
});

let p2 = p1
  .then(
    (value) => console.log(value),
    (reason) => console.log(reason)
  )
  .then(
    (a) => console.log('成功'), // 即使p1是reject状态 还是会执行这里的成功
    (b) => console.log(b)
  );

// console.log("p1", p1); // Promise {<rejected>: "rejected"}
// console.log("p2", p2); // Promise {<pending>}  // 此时p2是pending状态还未执行

// 如果是放在宏任务中
// 因为微任务要早于宏任务执行
// 所有Promise的状态为完成状态
setTimeout(() => {
  console.log('p1', p1); // Promise {<rejected>: "rejected"}
  console.log('p2', p2); // Promise {<fulfilled>: undefined}
});
```

- then 返回值的处理技巧

```ts
let p1 = new Promise((resolve, reject) => {
  resolve('成功了');
})
  .then((value) => {
    console.log(value); // 成功了
    return '这个值会传递给下个then';
  })
  .then((value) => {
    console.log('第二个then接收到的值', value); // 第二个then接收到的值 这个值会传递给下个then
    return new Promise((resolve, reject) => {
      resolve('返回一个Promise');
    });
  })
  .then((value) => {
    console.log('第三个then接收到的值', value); // 第三个then接收到的值 返回一个Promise
  });
```

- 其他类型的 Promise 封装

```ts
let p1 = new Promise((resolve, reject) => {
  resolve('成功了');
})
  .then((value) => {
    console.log(value); // 成功了
    return {
      then(resolve, reject) {
        setTimeout(() => {
          resolve('如果返回的对象或类中包含then方法,其效果和返回Promise类似');
        }, 10);
      },
    };
  })
  .then((value) => {
    console.log(value);
  });
```

- 使用 Promise 封装 Ajax 异步请求

```ts
function ajax(url) {
  return new Promise((resolve, reject) => {
    let xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.send();
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(JSON.parse(this.response));
      } else {
        reject('加载失败');
      }
    };
    xhr.onerror = function () {
      reject(this);
    };
  });
}
```

- Promise 多种错误监控与 catch 的使用

```ts
new Promise((resolve, reject) => {
  // resolve("fulfilled"); // 成功
  // reject(new Error("promise fail")); 可以接收一个错误的对象
  // throw new Error("fail"); // 也可以直接抛出一个异常
  // hd + 1; // 会直接进行错误处理
  // reject("直接reject一个错误信息");

  resolve('第一个Promise处理成功了');
})
  .then(
    (value) => {
      console.log(value);
      return new Promise((resolve, reject) => {
        reject('第二个Promise处理失败');
      });
    },
    (reason) => console.log(reason)
  )
  .then((value) => {
    console.log(value);
  })
  .catch((reason) => {
    // 如果上面的then里面没有对应的错误处理函数则发生错误后会走到这里
    // 如果then里面存在对应的错误处理函数则走自己的错误处理逻辑
    console.log(reason);
  });
```

- 自定义错误处理

```ts
// 自定义错误
// 自定义一种错误类型
class ParamError extends Error {
  constructor(msg) {
    super(msg);
    this.name = 'ParamError';
  }
}

function ajax(url) {
  return new Promise((resolve, reject) => {
    if (!/^http/.test(url)) {
      throw new ParamError('请求地址格式错误'); // 同步执行的时候可以这样抛出错误
    }

    setTimeout(() => {
      // 如果是异步执行需要这样抛出错误
      reject(new ParamError('用户不存在'));
    }, 10);
  });
}

ajax('www.abc.com')
  .then()
  .catch((reason) => {
    console.log(reason);
  });
```

- 使用 finally 实现异步加载动画

```ts
/**
 * finally 无论成功或失败都会执行
 */
let p1 = new Promise((resolve, reject) => {
  resolve('成功了');
})
  .then((val) => {
    console.log(val);
  })
  .catch((reason) => {
    console.log('失败了', reason);
  })
  .finally(() => {
    console.log('无论成功或失败都会执行');
  });
```

- Promise 异步加载图片

```ts
function loadImage(src) {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.src = src;
    image.onload = () => {
      resolve(image);
    };
    image.onerror = () => {
      reject('图片加载失败');
    };

    document.body.appendChild(image);
  });
}

loadImage('./img/11.jpg')
  .then((image) => {
    image.style.border = 'solid 6px red';
  })
  .catch((reason) => {
    console.log(reason);
  });
```

- 封装 setTimeout 定时器

```ts
function timeout(delay = 1000) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}

timeout(2000)
  .then(() => {
    console.log('第一次执行');
    return timeout(2000);
  })
  .then(() => {
    console.log('过两秒后再次执行');
  });
```

- 扁平化的 setInterval

```ts
function interval(delay = 1000, callback) {
  return new Promise((resolve) => {
    let id = setInterval(() => {
      callback(id, resolve);
    }, delay);
  });
}

interval(100, (id, resolve) => {
  console.log(12);
  clearInterval(id);
  resolve();
}).then((value) => {
  console.log('完成了');
});
```

- script 脚本的 Promise 加载引擎

```ts
function loadScript(src) {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = src;
    script.onload = () => resolve(script);
    script.onerror = reject;
    document.body.appendChild(script);
  });
}

loadScript('js/hd.js')
  .then((script) => {
    return loadScript('js/2.js');
  })
  .then((script) => {
    houdunren();
  })
  .catch((reason) => {
    console.log(reason);
  });
```

- Promise.resolve() 缓存后台数据

```ts
Promise.resolve('后盾人').then((value) => {
  console.log(value);
});
```

- Promise.reject() 的使用

```ts
Promise.reject('fail')
  .then((value) => {
    console.log(value);
  })
  .catch((error) => {
    console.log(error);
  });

// 使用场景
new Promise((resolve, reject) => {
  resolve('后盾人');
})
  .then((value) => {
    if (value !== '成功') {
      return Promise.reject('参数错误');
    }
  })
  .catch((error) => {
    console.log(error + 'fail');
  });
```

- Promise.all() 批量获取数据

```ts
/**
 * 批量执行promise 并把每个promise的返回值拼装成数组返回
 * 如果有一个promise失败来 则返回这个promise的reject的错误信息 并通过catch获取
 */
let p1 = new Promise((resolve, reject) => {
  resolve('p1');
});

let p2 = new Promise((resolve, reject) => {
  reject('p2发生错误');
}).catch((reason) => {
  // 如果promise有自己的错误处理函数
  // 则对应Promise.all()来说它的状态是resolve 值是undefined
  console.log('p2自己接受了错误信息');
});

let p3 = new Promise((resolve, reject) => {
  resolve('p3');
});

Promise.all([p1, p2, p3])
  .then((values) => {
    console.log('Promise-all返回的结果', values); // ["p1", undefined, "p3"]
  })
  .catch((reason) => {
    console.log('reason', reason); // 返回第一个发生错误的promise的错误信息 p2发生错误
  });

/** 使用案例 */

function getUsers(names) {
  let promises = names.map((name) => {
    return ajax(`http://api.com${name}`);
  });

  return Promise.all(promises);
}

getUsers(['a', 'b']).then((users) => {
  console.log(users);
});
```

- Promise.settled() 的使用

```ts
/**
 * 批量执行多个Promise
 * 不管成功还是失败都会返回
 * 返回值是每个Promise执行状态对象组成的数组
 */
let p1 = new Promise((resolve, reject) => {
  resolve('p1');
});

let p2 = new Promise((resolve, reject) => {
  reject('p2发生错误');
});

let p3 = new Promise((resolve, reject) => {
  resolve('p3');
});

Promise.allSettled([p1, p2, p3]).then((values) => {
  console.log('Promise-all返回的结果', values);
  // 获取到的结果
  // [
  //   {
  //     status: "fulfilled",
  //     value: "p1"
  //   },
  //   {
  //     reason: "p2发生错误",
  //     status: "rejected"
  //   },
  //   {
  //     status: "fulfilled",
  //     value: "p3"
  //   }
  // ]
});
```

- Promise.race() 后台请求超时处理

```ts
/**
 * 批量执行多个promise
 * 那个返回得快就取那个Promise返回得快就取那个
 */

let p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p1');
  }, 200);
});

let p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('p2发生错误');
  }, 50);
});

let p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p3');
  }, 10);
});

Promise.race([p1, p2, p3])
  .then((value) => {
    console.log(value); // 最先执行的Promise
  })
  .catch((reason) => {
    // 如果最先执行的Promise是reject状态 则会走到这里来
    console.log(reason);
  });
```

- Promise 队列原理

```ts
let p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p1');
  }, 200);
})
  .then((v) => {
    console.log(v);
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve('abc');
      }, 10);
    });
  })
  .then((v) => {
    // 10毫秒后才会打印出来
    console.log(v);
  });
```

- 使用 Map 实现 Promise 队列

```ts
function queue(num) {
  let promise = Promise.resolve();
  num.map((v) => {
    promise = promise.then((_) => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          console.log(v);
          resolve();
        }, 1000);
      });
    });
  });
}

queue([1, 2, 3, 4, 5, 6]);
```

- 使用 reduce 封装 Promise 队列

```ts
function queue(num) {
  num.reduce((promise, n) => {
    return promise.then((_) => {
      return new Promise((resolve) => {
        setTimeout(() => {
          console.log(n);
          resolve();
        }, 10);
      });
    });
  }, Promise.resolve());
}

queue(['p1', 'p2', 'p3']);
```

- async 和 await 语法糖

```ts
// 加上async 后返回的是一个Promise对象
async function hd() {
  let name = await new Promise((resolve) => {
    setTimeout(() => {
      resolve('abc');
    }, 2000);
  });
  console.log(name);

  return 'hd的返回值';
}

async function init() {
  const res = await hd();

  console.log(res);
}

init();
```

- Promise.any()

```ts
/**
 * 该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。
 * 只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；
 * 如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。
 * Promise.any()跟Promise.race()方法很像，只有一点不同，
 * 就是不会因为某个 Promise 变成rejected状态而结束。
 */

const promises = [
  Promise.resolve('a'),
  Promise.reject('err'),
  Promise.resolve('c'),
];

Promise.any(promises)
  .then((v) => {
    console.log('v', v); // a
  })
  .catch((err) => {
    console.log('err', err);
  });
```

- Promise.try()

```ts
/**
 * 让同步函数同步执行，异步函数异步执行
 * 事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块
 */
const f = () => console.log('now');
Promise.try(f);
console.log('next');
// now
// next
```

- async 延时函数

```ts
async function sleep(delay = 2000) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, delay);
  });
}

async function show() {
  for (const user of ['a', 'b', 'c']) {
    await sleep();
    console.log(user);
  }
}

show();
```

- class 与 async 结合使用

```ts
class User {
  constructor(name) {
    this.name = name;
  }

  // 类里面的then方法会被任务是Promise对象里面的then方法也是
  then(resolve, reject) {
    resolve(`${this.name}User`);
  }
}

async function get() {
  let user = await new User('abc');
  console.log(user);
}

get();
```

- async 基本错误处理

```ts
async function show() {
  throw new Error('fail');
}

show()
  .then((v) => {})
  .catch((reason) => {
    console.log('reason', reason);
  });
```

- 标准的 async 错误处理流程

```ts
async function show() {
  try {
    console.log(a);
  } catch (err) {
    console.log(err);
  }
  // 即使是上面出错类这里的代码还是可以继续执行
  console.log('333');
}

show().then((v) => {});
```

- await 的并行执行技巧

```ts
let p1 = Promise.resolve('p1');
let p2 = Promise.resolve('p2');

async function hd() {
  let res = await Promise.all([p1, p2]); // p1 p2 是同步执行
  console.log(res);
}

hd();
```

## JS 中的宏任务与微任务，及 JAVASCRIPT 任务调度流程

- 宏任务与微任务

```ts
setTimeout(() => {
  console.log('定时器'); // 最后打印宏任务里面的任务
});

Promise.resolve().then((value) => {
  console.log('Promise'); // 再打印微任务队列里的任务
});

console.log('后盾人'); // 最先打印主线程里面的任务
```

- 定时器的任务编排

```ts
setTimeout(() => {
  // 这个定时器会放入到宏任务列表中的第二位执行
  // 放入宏任务列表后开始计时
  // 等主进行里的任务都完成后,同时计时到了就会被推到主进程里面立即执行
  console.log('定时器1');
}, 2000);

setTimeout(() => {
  // 这个定时器会放入到宏任务列表中的第一位执行
  console.log('定时器2');
}, 1000);

console.log('abc');

for (let i = 0; i < 10000; i++) {
  console.log('');
}
```

- Promise 微任务的处理逻辑

```ts
setTimeout(() => {
  console.log('定时器');

  new Promise((resolve) => {
    console.log('这里会和上面的打印定时器同步执行');
    resolve();
  }).then(() => {
    console.log('定时器中-这里是会放在微任务队列中等待执行');
  });
}, 0);

new Promise((resolve) => {
  // 这里的代码是在主进程中执行的
  console.log('Promise');
  resolve();
}).then(() => {
  // 这里的代码是会放入到微任务队列中等待被执行的
  console.log('这里是会放在微任务队列中等待执行');
});

console.log('主进程代码');
```

- DOM 渲染任务

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>代码实例</title>
  </head>

  <body>
    <button>后盾人</button>
  </body>
  <!-- 建议把js脚本放在dom后面这样dom就会先渲染在执行js -->
  <!-- 如果js脚本是放在dom前面的则必须等待js执行完毕后再执行dom的渲染任务 -->
  <script src="./index.js"></script>
</html>
```

- 任务共享内存

```ts
let i = 0;
setTimeout(() => {
  // 宏任务队列里会先把这个推入到主进程中执行
  console.log(++i); // 1
}, 1000);

setTimeout(() => {
  // 然后再从宏任务列表中把这个推入到主进程中执行
  // 定时器的时间虽然相同但是不会影响宏任务队列的执行顺序
  console.log(++i); // 2
}, 1000);
```

- 进度条实例体验任务轮询

```ts
function handle() {
  let i = 0;
  (function run() {
    hd.innerHTML = i;
    hd.style.width = i + '%';
    if (++i <= 100) {
      setTimeout(run, 20);
    }
  })();
}

handle();
```

- Promise 微任务处理复杂逻辑

```ts
async function hd(num) {
  let res = await Promise.resolve().then((_) => {
    let count = 0;
    for (let i = 0; i < num; i++) {
      count += num--;
    }

    return count;
  });

  console.log(res);
}

hd(10000000);
console.log('这里会先执行');
```

## 手写 PROMISE 核心代码

- 声明 Promise 类并绑定 this

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    executor(this.resolve.bind(this), this.reject.bind(this));
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    this.status = HD.FUFILLED;
    this.value = value;
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    this.status = HD.REJECTED;
    this.value = reason;
  }
}

const p1 = new HD((resolve, reject) => {
  resolve('成功');
  // reject("失败");
});

console.log(p1);
```

## 单词

```pug
executor 执行人
```

- 状态保护与执行者异步捕获

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      // 状态为pending的时候才允许改变状态
      this.status = HD.FUFILLED;
      this.value = value;
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      // 状态为pending的时候才允许改变状态
      this.status = HD.REJECTED;
      this.value = reason;
    }
  }
}

const p1 = new HD((resolve, reject) => {
  resolve('成功', a);
  reject('失败');
});

console.log(p1);
```

- then 的基础构建

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;
    }
  }

  // then构建基础核心代码
  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {};
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {};
    }

    if (this.status === HD.FUFILLED) {
      onFulfilled(this.value);
    }

    if (this.status === HD.REJECTED) {
      onRejected(this.value);
    }
  }
}

const p1 = new HD((resolve, reject) => {
  resolve('成功');
  reject('失败');
}).then(
  (v) => {
    console.log(v);
  },
  (reason) => {
    console.log(reason);
  }
);
```

- 实现 then 的异步操作与异步捕获

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {};
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {};
    }

    if (this.status === HD.FUFILLED) {
      // 异步操作与异步捕获逻辑处理
      setTimeout(() => {
        try {
          onFulfilled(this.value);
        } catch (error) {
          onRejected(error);
        }
      });
    }

    if (this.status === HD.REJECTED) {
      // 异步操作与异步捕获逻辑处理
      setTimeout(() => {
        try {
          onRejected(this.value);
        } catch (error) {
          onRejected(error);
        }
      });
    }
  }
}

const p1 = new HD((resolve, reject) => {
  resolve('成功');
  reject('失败');
}).then(
  (v) => {
    console.log('aa', a);
    console.log(v);
  },
  (reason) => {
    console.log(reason);
  }
);

console.log('这里会先执行');
```

- Promise 的 PENDDING 状态处理

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    this.callbacks = []; // 压入解决状态和拒接状态下要执行的函数
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;
      this.callbacks.map((callback) => {
        callback.onFulfilled(value);
      });
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;
      this.callbacks.map((callback) => {
        callback.onRejected(reason);
      });
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {};
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {};
    }

    // 等待状态下的处理
    if (this.status === HD.PENDING) {
      this.callbacks.push({
        onFulfilled,
        onRejected,
      });
    }

    if (this.status === HD.FUFILLED) {
      // 异步操作与异步捕获逻辑处理
      setTimeout(() => {
        try {
          onFulfilled(this.value);
        } catch (error) {
          onRejected(error);
        }
      });
    }

    if (this.status === HD.REJECTED) {
      // 异步操作与异步捕获逻辑处理
      setTimeout(() => {
        try {
          onRejected(this.value);
        } catch (error) {
          onRejected(error);
        }
      });
    }
  }
}

const p1 = new HD((resolve, reject) => {
  setTimeout(() => {
    resolve('解决');
    // reject("拒绝");
  });

  // resolve("解决");
  // reject("拒绝");
}).then(
  (v) => {
    // console.log("aa", a);
    console.log(v);
  },
  (reason) => {
    console.log(reason);
  }
);

console.log('这里会先执行');
```

- Pending 状态异常处理

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    this.callbacks = []; // 压入解决状态和拒接状态下要执行的函数
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;
      this.callbacks.map((callback) => {
        callback.onFulfilled(value);
      });
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;
      console.log('执行到了callbacks');
      this.callbacks.map((callback) => {
        console.log('执行到了callbacks');
        callback.onRejected(reason);
      });
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {};
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {};
    }

    // 等待状态下的处理
    if (this.status === HD.PENDING) {
      this.callbacks.push({
        onFulfilled: (value) => {
          try {
            onFulfilled(value);
          } catch (error) {
            onRejected(error);
          }
        },
        onRejected: (reason) => {
          try {
            onRejected(reason);
          } catch (error) {
            onRejected(error);
          }
        },
      });
    }

    if (this.status === HD.FUFILLED) {
      // 异步操作与异步捕获逻辑处理
      setTimeout(() => {
        try {
          onFulfilled(this.value);
        } catch (error) {
          onRejected(error);
        }
      });
    }

    if (this.status === HD.REJECTED) {
      // 异步操作与异步捕获逻辑处理
      setTimeout(() => {
        try {
          onRejected(this.value);
        } catch (error) {
          onRejected(error);
        }
      });
    }
  }
}

const p1 = new HD((resolve, reject) => {
  setTimeout(() => {
    resolve('解决');

    // reject("拒绝");
  });

  // resolve("解决");
  // reject("拒绝");
}).then(
  (v) => {
    console.log('aa', a);
    console.log(v);
  },
  (reason) => {
    console.log(reason);
  }
);

console.log('这里会先执行');
```

- Pending 的异步任务处理技巧

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    this.callbacks = []; // 压入解决状态和拒接状态下要执行的函数
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onFulfilled(value);
        });
      });
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;
      console.log('执行到了callbacks');

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          console.log('执行到了callbacks');
          callback.onRejected(reason);
        });
      });
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {};
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {};
    }

    // 等待状态下的处理
    if (this.status === HD.PENDING) {
      this.callbacks.push({
        onFulfilled: (value) => {
          try {
            onFulfilled(value);
          } catch (error) {
            onRejected(error);
          }
        },
        onRejected: (reason) => {
          try {
            onRejected(reason);
          } catch (error) {
            onRejected(error);
          }
        },
      });
    }

    if (this.status === HD.FUFILLED) {
      // 异步操作与异步捕获逻辑处理
      setTimeout(() => {
        try {
          onFulfilled(this.value);
        } catch (error) {
          onRejected(error);
        }
      });
    }

    if (this.status === HD.REJECTED) {
      // 异步操作与异步捕获逻辑处理
      setTimeout(() => {
        try {
          onRejected(this.value);
        } catch (error) {
          onRejected(error);
        }
      });
    }
  }
}

const p1 = new HD((resolve, reject) => {
  setTimeout(() => {
    resolve('解决');

    console.log('解决了');

    // reject("拒绝");
  });

  // resolve("解决");
  // reject("拒绝");
}).then(
  (v) => {
    console.log('aa');
    console.log(v);
  },
  (reason) => {
    console.log(reason);
  }
);

console.log('这里会先执行');
```

- then 链式操作原理分析

```ts
// then 返回的是一个Promise
// 当前then如果是拒绝状态并不会影响到一个then的执行
let p2 = new Promise((resolve, reject) => {
  reject('拒绝');
});

p2.then(
  (value) => {
    console.log(value);
  },
  (reason) => {
    console.log(reason);
    return '处于拒绝的状态';
  }
).then(
  (value) => {
    console.log(`成功接收${value}`);
  },
  (reason) => {
    console.log(reason);
  }
);
```

- 实现 Promise 的链式操作

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    this.callbacks = []; // 压入解决状态和拒接状态下要执行的函数
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onFulfilled(value);
        });
      });
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onRejected(reason);
        });
      });
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {};
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {};
    }

    // 实现then 链式操作的关键是要返回一个Promise
    return new HD((resolve, reject) => {
      // 等待状态下的处理
      if (this.status === HD.PENDING) {
        this.callbacks.push({
          onFulfilled: (value) => {
            try {
              let result = onFulfilled(value);
              resolve(result); // resolve 后下一个 then 的resolve能接收到
            } catch (error) {
              onRejected(error);
            }
          },
          onRejected: (reason) => {
            try {
              let result = onRejected(reason);
              resolve(result);
            } catch (error) {
              onRejected(error);
            }
          },
        });
      }

      if (this.status === HD.FUFILLED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          try {
            let result = onFulfilled(this.value);
            resolve(result);
          } catch (error) {
            onRejected(error);
          }
        });
      }

      if (this.status === HD.REJECTED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          try {
            let result = onRejected(this.value);
            resolve(result);
          } catch (error) {
            onRejected(error);
          }
        });
      }
    });
  }
}

const p1 = new HD((resolve, reject) => {
  setTimeout(() => {
    // resolve("解决");

    reject('拒绝');
  });

  // resolve("解决");
  // reject("拒绝");
})
  .then(
    (v) => {
      console.log(v);
    },
    (reason) => {
      console.log(reason);
      return '被拒绝了';
    }
  )
  .then(
    (v) => {
      console.log(`成功接收${v}`);
    },
    (reason) => {
      console.log(reason);
    }
  );

console.log('这里会先执行1');
```

- then 新增 Promise 异常处理

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    this.callbacks = []; // 压入解决状态和拒接状态下要执行的函数
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onFulfilled(value);
        });
      });
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onRejected(reason);
        });
      });
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {};
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {};
    }

    return new HD((resolve, reject) => {
      // 等待状态下的处理
      if (this.status === HD.PENDING) {
        this.callbacks.push({
          onFulfilled: (value) => {
            try {
              let result = onFulfilled(value);
              resolve(result);
            } catch (error) {
              // 这里用于执行异常处理程序
              reject(error);
            }
          },
          onRejected: (reason) => {
            try {
              let result = onRejected(reason);
              resolve(result);
            } catch (error) {
              // 这里用于执行异常处理程序
              reject(error);
            }
          },
        });
      }

      if (this.status === HD.FUFILLED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          try {
            let result = onFulfilled(this.value);
            resolve(result);
          } catch (error) {
            // 这里用于执行异常处理程序
            reject(error);
          }
        });
      }

      if (this.status === HD.REJECTED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          try {
            let result = onRejected(this.value);
            resolve(result);
          } catch (error) {
            // 这里用于执行异常处理程序
            reject(error);
          }
        });
      }
    });
  }
}

const p1 = new HD((resolve, reject) => {
  setTimeout(() => {
    // resolve("解决");

    reject('拒绝');
  });

  // resolve("解决");
  // reject("拒绝");
})
  .then(
    (v) => {
      console.log(v);
    },
    (reason) => {
      console.log(reason);
      console.log(abc);
      return '被拒绝了';
    }
  )
  .then(
    (v) => {
      console.log(`成功接收${v}`);
    },
    (reason) => {
      console.log(reason);
    }
  );

console.log('这里会先执行1');
```

- 实现 then 穿透传递

```ts
/* then 的穿透效果 */
let p2 = new Promise((resolve, reject) => {
  resolve('成功');
})
  .then() // 如果这个then里面什么也没有 则上面resolve的值会穿透到下一个then
  .then(
    (v) => {
      console.log(`第二个then${v}`);
    },
    (reason) => {
      console.log(reason);
    }
  );

/* 原理实现 */
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    this.callbacks = []; // 压入解决状态和拒接状态下要执行的函数
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onFulfilled(value);
        });
      });
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onRejected(reason);
        });
      });
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    return new HD((resolve, reject) => {
      // 等待状态下的处理
      if (this.status === HD.PENDING) {
        this.callbacks.push({
          onFulfilled: (value) => {
            try {
              let result = onFulfilled(value);
              resolve(result);
            } catch (error) {
              // 这里用于执行异常处理程序
              reject(error);
            }
          },
          onRejected: (reason) => {
            try {
              let result = onRejected(reason);
              resolve(result);
            } catch (error) {
              // 这里用于执行异常处理程序
              reject(error);
            }
          },
        });
      }

      if (this.status === HD.FUFILLED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          try {
            let result = onFulfilled(this.value);
            resolve(result);
          } catch (error) {
            // 这里用于执行异常处理程序
            reject(error);
          }
        });
      }

      if (this.status === HD.REJECTED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          try {
            let result = onRejected(this.value);
            resolve(result);
          } catch (error) {
            // 这里用于执行异常处理程序
            reject(error);
          }
        });
      }
    });
  }
}

const p1 = new HD((resolve, reject) => {
  setTimeout(() => {
    resolve('解决');

    // reject("拒绝");
  });

  // resolve("解决");
  // reject("拒绝");
})
  .then()
  .then(
    (v) => {
      console.log(`成功接收${v}`);
    },
    (reason) => {
      console.log(reason);
    }
  );

console.log('这里会先执行1');
```

- then 返回 Promise 的处理

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    this.callbacks = []; // 压入解决状态和拒接状态下要执行的函数
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onFulfilled(value);
        });
      });
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onRejected(reason);
        });
      });
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    return new HD((resolve, reject) => {
      // 等待状态下的处理
      if (this.status === HD.PENDING) {
        this.callbacks.push({
          onFulfilled: (value) => {
            try {
              let result = onFulfilled(value);
              // 处理then返回的是一个Promise的情况
              if (result instanceof HD) {
                result.then(resolve, reject);
              } else {
                resolve(result);
              }
            } catch (error) {
              // 这里用于执行异常处理程序
              reject(error);
            }
          },
          onRejected: (reason) => {
            try {
              let result = onRejected(reason);
              resolve(result);
            } catch (error) {
              // 这里用于执行异常处理程序
              reject(error);
            }
          },
        });
      }

      if (this.status === HD.FUFILLED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          try {
            let result = onFulfilled(this.value);

            // 处理then返回的是一个Promise的情况
            if (result instanceof HD) {
              result.then(resolve, reject);
            } else {
              resolve(result);
            }
          } catch (error) {
            // 这里用于执行异常处理程序
            reject(error);
          }
        });
      }

      if (this.status === HD.REJECTED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          try {
            let result = onRejected(this.value);
            // 处理then返回的是一个Promise的情况
            if (result instanceof HD) {
              result.then(resolve, reject);
            } else {
              resolve(result);
            }
          } catch (error) {
            // 这里用于执行异常处理程序
            reject(error);
          }
        });
      }
    });
  }
}

const p1 = new HD((resolve, reject) => {
  setTimeout(() => {
    resolve('解决');

    // reject("拒绝");
  });

  // resolve("解决");
  // reject("拒绝");
})
  .then((v) => {
    return new HD((resolve, reject) => {
      // resolve("第一个then返回一个Promise对象");
      reject('第一个then返回一个Promise对象失败状态');
    });
  })
  .then(
    (v) => {
      console.log(`成功接收${v}`);
    },
    (reason) => {
      console.log(reason);
    }
  );

console.log('这里会先执行1');
```

- then 代码冗余优化

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    this.callbacks = []; // 压入解决状态和拒接状态下要执行的函数
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onFulfilled(value);
        });
      });
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onRejected(reason);
        });
      });
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    return new HD((resolve, reject) => {
      // 等待状态下的处理
      if (this.status === HD.PENDING) {
        this.callbacks.push({
          onFulfilled: (value) => {
            let result = onFulfilled(value);
            this.parse(result, resolve, reject);
          },
          onRejected: (reason) => {
            try {
              let result = onRejected(reason);
              resolve(result);
            } catch (error) {
              // 这里用于执行异常处理程序
              reject(error);
            }
          },
        });
      }

      if (this.status === HD.FUFILLED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          let result = onFulfilled(this.value);

          this.parse(result, resolve, reject);
        });
      }

      if (this.status === HD.REJECTED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          let result = onRejected(this.value);
          this.parse(result, resolve, reject);
        });
      }
    });
  }

  // 把冗余代码合并到为一个函数
  parse(result, resolve, reject) {
    try {
      // 处理then返回的是一个Promise的情况
      if (result instanceof HD) {
        result.then(resolve, reject);
      } else {
        resolve(result);
      }
    } catch (error) {
      // 这里用于执行异常处理程序
      reject(error);
    }
  }
}

const p1 = new HD((resolve, reject) => {
  setTimeout(() => {
    resolve('解决');
  });
})
  .then((v) => {
    return new HD((resolve, reject) => {
      // resolve("第一个then返回一个Promise对象");
      reject('第一个then返回一个Promise对象失败状态');
    });
  })
  .then(
    (v) => {
      console.log(`成功接收${v}`);
    },
    (reason) => {
      console.log(reason);
    }
  );

console.log('这里会先执行1');
```

- Promise 返回类型约束

```ts
/**
 * then 里面如果返回的是Promise则不能返回自己
 */
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    this.callbacks = []; // 压入解决状态和拒接状态下要执行的函数
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onFulfilled(value);
        });
      });
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onRejected(reason);
        });
      });
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    let promise = new HD((resolve, reject) => {
      // 等待状态下的处理
      if (this.status === HD.PENDING) {
        this.callbacks.push({
          onFulfilled: (value) => {
            let result = onFulfilled(value);
            this.parse(promise, result, resolve, reject);
          },
          onRejected: (reason) => {
            let result = onRejected(reason);
            this.parse(promise, result, resolve, reject);
          },
        });
      }

      if (this.status === HD.FUFILLED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          let result = onFulfilled(this.value);

          this.parse(promise, result, resolve, reject);
        });
      }

      if (this.status === HD.REJECTED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          let result = onRejected(this.value);
          this.parse(promise, result, resolve, reject);
        });
      }
    });
    return promise;
  }

  // 把冗余代码合并到为一个函数
  parse(promise, result, resolve, reject) {
    if (promise === result) {
      throw new TypeError('不能返回自己');
    }
    try {
      // 处理then返回的是一个Promise的情况
      if (result instanceof HD) {
        result.then(resolve, reject);
      } else {
        resolve(result);
      }
    } catch (error) {
      // 这里用于执行异常处理程序
      reject(error);
    }
  }
}

let p1 = new HD((resolve, reject) => {
  resolve('解决');
});

let p = p1.then((v) => {
  return p;
});
```

- 实现 resolve 和 reject

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    this.callbacks = []; // 压入解决状态和拒接状态下要执行的函数
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onFulfilled(value);
        });
      });
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onRejected(reason);
        });
      });
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    let promise = new HD((resolve, reject) => {
      // 等待状态下的处理
      if (this.status === HD.PENDING) {
        this.callbacks.push({
          onFulfilled: (value) => {
            let result = onFulfilled(value);
            this.parse(promise, result, resolve, reject);
          },
          onRejected: (reason) => {
            let result = onRejected(reason);
            this.parse(promise, result, resolve, reject);
          },
        });
      }

      if (this.status === HD.FUFILLED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          let result = onFulfilled(this.value);

          this.parse(promise, result, resolve, reject);
        });
      }

      if (this.status === HD.REJECTED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          let result = onRejected(this.value);
          this.parse(promise, result, resolve, reject);
        });
      }
    });
    return promise;
  }

  // 把冗余代码合并到为一个函数
  parse(promise, result, resolve, reject) {
    if (promise === result) {
      throw new TypeError('不能返回自己');
    }
    try {
      // 处理then返回的是一个Promise的情况
      if (result instanceof HD) {
        result.then(resolve, reject);
      } else {
        resolve(result);
      }
    } catch (error) {
      // 这里用于执行异常处理程序
      reject(error);
    }
  }

  // resolve 静态方法的实现
  static resolve(value) {
    return new HD((resolve, reject) => {
      if (value instanceof HD) {
        value.then(resolve, reject);
      } else {
        resolve(value);
      }
    });
  }

  // reject 静态方法的实现
  static reject(value) {
    return new HD((resolve, reject) => {
      reject(value);
    });
  }
}

// let p1 = new HD((resolve, reject) => {
//   resolve("解决");
// });

// let p = p1.then((v) => {
//   return p;
// });

// 使用静态方法
let p1 = HD.resolve('aaa').then((v) => {
  console.log(v);
});

let p2 = HD.reject('拒绝').then(null, (reason) => {
  console.log(reason);
});
```

- Promise all 方法的实现

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    this.callbacks = []; // 压入解决状态和拒接状态下要执行的函数
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onFulfilled(value);
        });
      });
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onRejected(reason);
        });
      });
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    let promise = new HD((resolve, reject) => {
      // 等待状态下的处理
      if (this.status === HD.PENDING) {
        this.callbacks.push({
          onFulfilled: (value) => {
            let result = onFulfilled(value);
            this.parse(promise, result, resolve, reject);
          },
          onRejected: (reason) => {
            let result = onRejected(reason);
            this.parse(promise, result, resolve, reject);
          },
        });
      }

      if (this.status === HD.FUFILLED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          let result = onFulfilled(this.value);

          this.parse(promise, result, resolve, reject);
        });
      }

      if (this.status === HD.REJECTED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          let result = onRejected(this.value);
          this.parse(promise, result, resolve, reject);
        });
      }
    });
    return promise;
  }

  // 把冗余代码合并到为一个函数
  parse(promise, result, resolve, reject) {
    if (promise === result) {
      throw new TypeError('不能返回自己');
    }
    try {
      // 处理then返回的是一个Promise的情况
      if (result instanceof HD) {
        result.then(resolve, reject);
      } else {
        resolve(result);
      }
    } catch (error) {
      // 这里用于执行异常处理程序
      reject(error);
    }
  }

  // resolve 静态方法的实现
  static resolve(value) {
    return new HD((resolve, reject) => {
      if (value instanceof HD) {
        value.then(resolve, reject);
      } else {
        resolve(value);
      }
    });
  }

  // reject 静态方法的实现
  static reject(value) {
    return new HD((resolve, reject) => {
      reject(value);
    });
  }

  // all 静态方法的实现
  static all(promises) {
    const values = [];
    return new HD((resolve, reject) => {
      promises.forEach((promise) => {
        promise.then(
          (value) => {
            values.push(value);
            if (values.length === promises.length) {
              resolve(values);
            }
          },
          (reason) => {
            reject(reason);
          }
        );
      });
    });
  }

  // race 静态方法的实现
  static race(promises) {
    return new HD((resolve, reject) => {
      promises.map((promise) => {
        promise.then(
          (value) => {
            resolve(value);
          },
          (reason) => {
            reject(reason);
          }
        );
      });
    });
  }
}

// let p1 = new HD((resolve, reject) => {
//   resolve("解决");
// });

// let p = p1.then((v) => {
//   return p;
// });

// 使用静态方法
let p1 = HD.resolve('aaa');

let p2 = HD.reject('bbb');

HD.race([p1, p2]).then(
  (v) => {
    console.log(v);
  },
  (reason) => {
    console.log(reason);
  }
);
```

## promise race 静态方法的实现(终极源码)

```ts
class HD {
  static PENDING = 'pending';
  static FUFILLED = 'fulfilled';
  static REJECTED = 'rejected';

  constructor(executor) {
    this.status = HD.PENDING;
    this.value = null;
    this.callbacks = []; // 压入解决状态和拒接状态下要执行的函数
    try {
      executor(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      // 用于捕获executor执行过程中的异常
      this.reject(error);
    }
  }

  resolve(value) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.FUFILLED;
      this.value = value;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onFulfilled(value);
        });
      });
    }
  }
  reject(reason) {
    // 这里的this指向需要重新绑定 要不然它在严格模式下是undefined 非严格模式下指向window
    if (this.status === HD.PENDING) {
      this.status = HD.REJECTED;
      this.value = reason;

      // 这里也是需要异步执行的
      setTimeout(() => {
        this.callbacks.map((callback) => {
          callback.onRejected(reason);
        });
      });
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    if (typeof onRejected !== 'function') {
      onRejected = () => {
        return this.value; // 用于穿透的时候往下传递值
      };
    }

    let promise = new HD((resolve, reject) => {
      // 等待状态下的处理
      if (this.status === HD.PENDING) {
        this.callbacks.push({
          onFulfilled: (value) => {
            let result = onFulfilled(value);
            this.parse(promise, result, resolve, reject);
          },
          onRejected: (reason) => {
            let result = onRejected(reason);
            this.parse(promise, result, resolve, reject);
          },
        });
      }

      if (this.status === HD.FUFILLED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          let result = onFulfilled(this.value);

          this.parse(promise, result, resolve, reject);
        });
      }

      if (this.status === HD.REJECTED) {
        // 异步操作与异步捕获逻辑处理
        setTimeout(() => {
          let result = onRejected(this.value);
          this.parse(promise, result, resolve, reject);
        });
      }
    });
    return promise;
  }

  // 把冗余代码合并到为一个函数
  parse(promise, result, resolve, reject) {
    if (promise === result) {
      throw new TypeError('不能返回自己');
    }
    try {
      // 处理then返回的是一个Promise的情况
      if (result instanceof HD) {
        result.then(resolve, reject);
      } else {
        resolve(result);
      }
    } catch (error) {
      // 这里用于执行异常处理程序
      reject(error);
    }
  }

  // resolve 静态方法的实现
  static resolve(value) {
    return new HD((resolve, reject) => {
      if (value instanceof HD) {
        value.then(resolve, reject);
      } else {
        resolve(value);
      }
    });
  }

  // reject 静态方法的实现
  static reject(value) {
    return new HD((resolve, reject) => {
      reject(value);
    });
  }

  // all 静态方法的实现
  static all(promises) {
    const values = [];
    return new HD((resolve, reject) => {
      promises.forEach((promise) => {
        promise.then(
          (value) => {
            values.push(value);
            if (values.length === promises.length) {
              resolve(values);
            }
          },
          (reason) => {
            reject(reason);
          }
        );
      });
    });
  }

  // race 静态方法的实现
  static race(promises) {
    return new HD((resolve, reject) => {
      promises.map((promise) => {
        promise.then(
          (value) => {
            resolve(value);
          },
          (reason) => {
            reject(reason);
          }
        );
      });
    });
  }
}

// let p1 = new HD((resolve, reject) => {
//   resolve("解决");
// });

// let p = p1.then((v) => {
//   return p;
// });

// 使用静态方法
let p1 = HD.resolve('aaa');

let p2 = HD.reject('bbb');

HD.race([p1, p2]).then(
  (v) => {
    console.log(v);
  },
  (reason) => {
    console.log(reason);
  }
);
```
