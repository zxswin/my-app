## JavaScript 数据结构与算法

- 什么是数据结构和算法

```ts
/**
 * 1.什么是数据结构
 * 数据结构就是在计算机中存储和组织数据的方式
 *
 * 2.什么是算法
 * 一个有限指令集 每条指令的描述不依赖与语言
 * 接受一些输入(有些情况下不需要输入)
 * 产生输出
 * 一定在有限的步骤之后终止
 *
 * 3.数据结构的实现离不开算法
 */
```

- 数组

```ts
/**
 * 数组的插入删除操作效率比较低
 * 数组通过下标查找值和修改值效率比较高
 */
```

- 栈结构

```ts
/**
 * 数组是一种线性结构 可以在任意位置插入和删除数据
 * 栈和队列是比较常见的受限的线性结构
 *
 *
 * 栈: 它是一种受限的线性表 后进先出(LIFO)
 * 其限制是仅允许在表的一端进行插入和删除运算
 * 栈顶
 * 栈底
 * 进栈
 * 出栈
 *
 *
 * 实现栈结构有两种比较常见的方式
 * 1.基于数组实现
 * 2.基于链表实现
 *
 * 栈常用的操作
 * 方法 和某个对象实例有联系称之为方法 类中称为方法
 * 1.push(element) 添加一个新元素到栈顶的位置
 * 2.pop() 移除栈顶的元素 同时返回被移除的元素
 * 3.peek() 返回栈顶的元素 不对栈做任何修改
 * 4.isEmpty() 如果栈没有任何元素就返回true 否则返回false
 * 5.size() 返回栈里的元素个数
 * 6.toString() 将栈结构的内容以字符形式返回
 */
class Stack {
  // 栈中的属性
  items = [];

  /**  1.将元素压入到栈  */
  push(element) {
    this.items.push(element);
  }

  /**  2.从栈中取出元素 */
  pop() {
    return this.items.pop();
  }

  /**  3.查看栈顶的元素 */
  peek() {
    return this.items[this.items.length - 1];
  }

  /**  4.判断栈是否为空 */
  isEmpty() {
    return this.items.length === 0;
  }

  /**  5.获取栈中元素的个数 */
  size() {
    return this.items.length;
  }

  /**  6.toSting方法 */
  toString() {
    // return `[${this.items.join(",")}]`;
    return JSON.stringify(this.items);
  }
}

let stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);

console.log(stack);
console.log(stack.toString());
console.log(stack.pop());
console.log(stack.toString());
```

- 十进制转二进制

```ts
/**
 * 通过栈实现十进制转二进制
 * @param {number} decNumber 要转换的十进制数字
 */

function dec2bin(decNumber) {
  const stack = new Stack();

  while (decNumber > 0) {
    stack.push(decNumber % 2);
    decNumber = Math.floor(decNumber / 2);
  }

  let binaryString = '';
  while (!stack.isEmpty()) {
    binaryString += stack.pop();
  }

  return binaryString;
}

console.log(dec2bin(100));
```

- 队列结构

```ts
/**
 * 队列,它是一种受限的线性表
 * 先进先出(FIFO First in First Out)
 * 只允许在表的前端(front)进行删除操作
 * 而在表的后段(rear)进行插入操作
 *
 * 运用场景：
 * 线程队列
 *
 * 队列实现的两种方案
 * 1.基于数组实现
 * 2.基于链表实现
 *
 * 队列要实现的功能
 * 1.enqueue(element) 向队列尾部添加一个或多个新的项
 * 2.dequeue() 移除队列的第一(即排在队列最前面的项) 并返回被删除的元素
 * 3.front() 返回队列中的第一个元素-最先被添加也是最先被移除的元素 队列不做任何变动
 * 4.isEmpty() 如果队列中不包含任何元素 返回true 否则返回false
 * 5.size() 返回队列包含的元素个数 与数组的length属性类似
 * 6.toString() 将队列中的内容转成字符串的形式
 */
class Queue {
  items = [];

  /** 1.向队列里添加元素  */
  enqueue(element) {
    this.items.push(element);
  }
  /** 2.从队列中删除前端元素  */
  dequeue() {
    return this.items.shift();
  }
  /** 3.查看前端的元素  */
  front() {
    return this.items[0];
  }
  /** 4.查看队列是否为空  */
  isEmpty() {
    return this.items.length === 0;
  }
  /** 5.查看队列中元素的个数  */
  size() {
    return this.items.length;
  }
  /** 6.toString方法  */
  toString() {
    return JSON.stringify(this.items);
  }
}

let queue = new Queue();
queue.enqueue('111');
console.log(queue);
```

- 队列击鼓传花规则

```ts
/**
 * 游戏规则:
 * 围成一圈 开始数数 数到某个数字的人自动淘汰
 * 最后剩下的人会获得胜利 请问最后剩下的是原来在那个位置上的人;
 *
 * 封装一个基于队列的函数
 * 参数:所有参与人的姓名 基于的数字
 * 结果 最终剩下的人的姓名
 */

/**
 * 面试题 击鼓传花的代码实现
 * @param {array} nameList 列表
 * @param {number} num 数到的数字
 */
function passGame(nameList, num) {
  // 1.创建一个队列结构
  let queue = new Queue();

  // 2.将所有人依次加入到队列中

  nameList.forEach((item) => {
    queue.enqueue(item);
  });

  // 开始数数字
  while (queue.size() > 1) {
    // 不是num的时候重新加入到队列的末尾
    // 是num这个数字 将其从队列中删除
    // num数字之前的人重新放入到队列的末尾中
    for (let i = 0; i < num - 1; i++) {
      queue.enqueue(queue.dequeue());
    }

    // num对应这个人 直接从队列中删除掉
    queue.dequeue();
  }

  // 获取剩下的那个人
  console.log(queue.size());
  let enName = queue.front();

  console.log('最终剩下的人', enName);

  return nameList.indexOf(enName);
}

let names = ['lily', 'lucy', 'tom', 'lilei', 'why'];
console.log(passGame(names, 3));
```

- 优先级队列

```ts
/**
 * 优先级队列要考虑的问题
 * 1.每个元素不再只是一个数据 而且包含数据的优先级
 * 2.在添加方式中 根据优先级放入正确的位置
 */

class PriorityQueue extends Queue {
  items = [];
  constructor() {
    super();
  }

  /**
   * 创建插入元素
   * @param element 插入的元素
   * @param priority 插入元素的优先级
   */
  createElement(element, priority) {
    return {
      element,
      priority,
    };
  }

  /**
   * 实现插入方法
   * @param element 插入的元素
   * @param priority 插入元素的优先级
   */
  enqueue(element, priority) {
    // 1.创建QueueElement对象
    const queueElement = this.createElement(element, priority);

    // 2.判断队列是否为空
    if (this.items.length === 0) {
      this.items.push(queueElement);
    } else {
      let added = false;
      for (let i = 0; i < this.items.length; i++) {
        const item = this.items[i];
        if (queueElement.priority < item.priority) {
          this.items.splice(i, 0, queueElement);
          added = true;
          break;
        }
      }

      if (!added) {
        this.items.push(queueElement);
      }
    }
  }
}

// 测试代码
const pq = new PriorityQueue();

pq.enqueue('a', 3);
pq.enqueue('b', 1);
pq.enqueue('c', 2);
pq.enqueue('d', 4);

console.log(pq.toString());
```

- 链表

```ts
/**
 * 链表
 * 1.要存储多个元素可以选择链表
 * 2.不同于数组 链表中的元素在内存中不必是连续的空间
 * 3.链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针或链接)组成
 *
 * 链表相对于数组的优点:
 * 内存空间不是必须连续的
 * 链表不存在创建时就确定大小 并且大小可以无限的延伸下去
 * 链表在插入和删除数据时,时间复杂度可以达到O(1),相对于数组效率高很多
 *
 * 链表的缺点:
 * 链表访问任何一个位置的元素时 都需要从头开始访问(无法跳过第一个元素访问任何一个元素)
 * 无法通过下标直接访问元素 需要从头一个个访问 直到找到对应的元素
 *
 * 什么是链表
 * 链表的结构类似于火车:有一个火车头 火车头会连接一个节点 节点上有乘客(类似于数据)并且这个节点会连接下个节点 以此类推
 *
 *
 *
 * 链表常见的操作
 * append(element) 向列表尾部添加一个新的项
 * insert(position,element) 向列表的特定位置插入一个新的项
 * get(position) 获取对应位置的元素
 * indexOf(element) 返回元素在列表中的索引 如果列表中没有该元素则返回-1
 * update(position) 修改某个位置的元素
 * removeAt(position) 从列表的特定位置移除一项
 * remove(element) 从列表中移除一项
 * isEmpty() 如果链表中不包含任何元素 返回true 如果链表长度大于0则返回false
 * size() 返回链表包含的元素个数 与数组的length属性类似
 * toString():由于列表项使用链Node类 就需要重写继承自js对象默认的toString方法 让其只输出元素的值
 */

class LinkedList {
  /**  链表的头部  */
  head = null;
  /** 链表的长度  */
  length = 0;

  /**
   * 根据传进来的数据创建节点
   * @param {any} data 要创建节点的数据
   */
  createNode(data) {
    return {
      data,
      next: null,
    };
  }

  /**
   * 添加方法
   * @param {any} 要添加到链表中的数据
   */
  append(data) {
    // 1.创建新的节点
    let newNode = this.createNode(data);

    // 2.判断是否添加的是第一个节点
    if (this.length === 0) {
      this.head = newNode;
    } else {
      // 找到最后一个节点
      let current = this.head;
      while (current.next) {
        current = current.next;
      }
      // 最后节点的next指向新的节点
      current.next = newNode;
    }

    // 改变长度
    this.length += 1;
  }

  /**
   * insert插入数据方法
   * @param {number} position 插入数据的位置
   * @param {any} data 插入的数据
   * @returns {boolean}
   */

  insert(position, data) {
    // 1.对position进行越界判断
    if (position < 0 || position > this.length) return false;
    // 2.根据data创建newNode
    let newNode = this.createNode(data);

    // 3.判断插入为是否是第一个
    if (position === 0) {
      newNode.next = this.head;
      this.head = newNode;
    } else {
      let index = 0;
      let current = this.head;
      let previous = null;

      while (index++ < position) {
        previous = current;
        current = current.next;
      }

      newNode.next = current;
      previous.next = newNode;
    }

    // 4.插入成功改变长度
    this.length += 1;
    return true;
  }

  /**
   * get方法 获取指定位置的数据
   * @param {number} position 想要获取的数据位置
   */

  get(position) {
    // 1.越界判断
    if (position < 0 || position >= this.length) return null;

    // 获取对应的data
    let current = this.head;
    let index = 0;
    while (index++ < position) {
      current = current.next;
    }

    return current.data;
  }

  /**
   * indexOf方法 根据传入数据找到对应的索引
   * @param {any} data
   */
  indexOf(data) {
    // 1.定义变量
    let current = this.head;
    var index = 0;

    // 开始查找
    while (current) {
      if (current.data == data) {
        return index;
      }
      current = current.next;
      index += 1;
    }

    // 3.找到最后没有找到 返回-1
    return -1;
  }

  /**
   * update方法
   * @param {number} position 要修改的数据位置
   * @param {any} newData 修改后的新数据
   */

  update(position, newData) {
    // 1.越界判断
    if (position < 0 || position >= this.length) return false;
    // 2.查找正确额节点
    let current = this.head;
    let index = 0;
    while (index++ < position) {
      current = current.next;
    }

    // 3.将position位置的node的data修改成newData
    current.data = newData;

    return true;
  }

  /**
   * removeAt 根据索引移除元素方法
   * @param {number} position
   */

  removeAt(position) {
    // 1.越界判断
    if (position < 0 || position >= this.length) return null;

    // 2.判断是否删除的是第一个节点
    let current = this.head;
    if (position === 0) {
      this.head = this.head.next;
    } else {
      let index = 0;

      let previous = null;
      while (index++ < position) {
        previous = current;
        current = current.next;
      }
      // 前一个节点的next指向 current的next即可
      previous.next = current.next;
    }

    // 改变长度
    this.length -= 1;
    return current.data;
  }

  /**
   * remvoe 删除元素方法
   * @param {any} data 要删除的链表中的数据
   */

  remove(data) {
    // 1.获取data在链表中的位置
    let position = this.indexOf(data);
    // 2.根据位置信息 删除节点
    return this.removeAt(position);
  }

  /**
   * isEmpty方法
   * 数据链表是否为空
   */
  isEmpty() {
    return this.length === 0;
  }

  /**
   * size 方法 返回链表的长度
   */

  size() {
    return this.length;
  }

  /** toString方法 */
  toString() {
    // 1.定义变量
    let current = this.head;
    let listString = '';

    // 循环获取一个个的节点
    while (current) {
      listString += current.data + ' ';
      current = current.next;
    }

    return listString;
  }
}

const linkedList = new LinkedList();

// 测试append方法
linkedList.append('a');
linkedList.append('b');
linkedList.append('c');

// 测试insert方法
linkedList.insert(0, '1');
linkedList.insert(4, '2');
linkedList.insert(3, '66');

console.log(linkedList.toString());

// 测试get方法
console.log(linkedList.get(2));

// 测试index方法
console.log(linkedList.indexOf('b'));
console.log(linkedList.indexOf('bbbb'));

// 测试update方法
linkedList.update(3, 'update3');

console.log(linkedList.toString());

// 测试removeAt方法
console.log(linkedList.removeAt(1));

console.log(linkedList.toString());

// 测试remove方法
console.log(linkedList.remove('b'));
console.log(linkedList.toString());

// 测试isEmpty 和 size方法
console.log(linkedList.isEmpty(), linkedList.size());
```

- 双向数据链表

```ts
/**
 * 单向列表的缺点
 * 1.只能从头遍历到尾 不能从尾遍历到头
 * 2.链表的相连的过程是单向的 从上一个节点指向下一个节点的引用
 * 3.可以轻松到达下一个节点 但是回到前一个节点很难
 *
 *
 * 双向链表
 * 既可以从头遍历到尾 也可以从尾遍历到头
 * 也就是链表相连的过程是双向的
 * 一个节点既有向前的连接的引用 也有一个向后连接的引用
 *
 * 双向列表的缺点
 * 1.每次插入或删除某个节点时 需要处理4个引用
 * 2.相对于单向列表占用内存空间更大一些
 *
 *
 * 双向链表的特点
 * 1.可以使用一个head和一个tail分别指向头部和尾部的节点
 * 2.每个节点都由三部分组成 前一个节点的指针(pre)/保存的元素(item)/后一个节点的指针(next);
 * 3.双向链表的第一个节点的prev 是null
 * 4.双向链表的最后一个节点的next是null
 *
 *
 * 双向链表常见的操作
 * append(element) 向列表尾部添加一个新的项
 * insert(position,element) 向列表的特定位置插入一个新的项
 * get(position) 获取对应位置的元素
 * indexOf(element) 返回元素在列表中的索引 如果列表中没有该元素则返回-1
 * update(position) 修改某个位置的元素
 * removeAt(position) 从列表的特定位置移除一项
 * remove(element) 从列表中移除一项
 * isEmpty() 如果链表中不包含任何元素 返回true 如果链表长度大于0则返回false
 * size() 返回链表包含的元素个数 与数组的length属性类似
 * toString():由于列表项使用链Node类 就需要重写继承自js对象默认的toString方法 让其只输出元素的值
 * forwardString(): 返回正向遍历的节点字符串形式
 * backwordString(): 返回反向遍历的节点字符字符串形式
 */

class DoublyLinkedList {
  // 相关属性
  head = null; // 头部
  tail = null; // 尾部
  length = 0; // 长度

  /**
   * 根据data创建新的节点数据
   * @param {any} data 要创建新节点的数据
   */

  createNode(data) {
    return {
      data,
      prev: null,
      next: null,
    };
  }

  /**
   * append 方法添加节点
   * @param {any} data 要添加的节点数据
   */

  append(data) {
    // 1.根据data创建节点
    let newNode = this.createNode(data);

    // 2.判断添加的节点是否是第一个节点
    if (this.length === 0) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      newNode.prev = this.tail;
      this.tail.next = newNode;
      this.tail = newNode;
    }

    // 修改长度
    this.length += 1;
  }

  /**
   * insert 方法插入数据
   * @param {number} position 要插入数据的位置
   * @param {any} data 要插入的数据
   */
  insert(position, data) {
    // 1.越界判断
    if (position < 0 || position > this.length) return false;

    // 2.根据data创建新的节点
    let newNode = this.createNode(data);

    // 3.判断原来的列表是否为空
    if (this.length === 0) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      // 判断position是否为0
      if (position === 0) {
        this.head.prev = newNode;
        newNode.next = this.head;
        this.head = newNode;
      } else if (position === this.length) {
        // 如果是插入到最后
        newNode.prev = this.tail;
        this.tail.next = newNode;
        this.tail = newNode;
      } else {
        // 如果是往中间插入
        let current = this.head;
        let index = 0;

        while (index++ < position) {
          current = current.next;
        }

        // 修改指针
        newNode.next = current;
        newNode.prev = current.prev;
        current.prev.next = newNode;
        current.prev = newNode;
      }
    }

    // 修改长度
    this.length += 1;
  }

  /**
   * get方法 返回指定位置的数据
   * @param {number} position
   */

  get(position) {
    // 1.越界判断
    if (position < 0 || position >= this.length) return null;

    // 从前往后找 还是 从后往前找
    let queryFlag = this.length / 2 > position;
    // 2.获取元素
    let current;

    if (queryFlag) {
      // 前往后找
      current = this.head;
      let index = 0;
      while (index++ < position) {
        current = current.next;
      }
    } else {
      // 从后往前找
      current = this.tail;
      let index = this.length;
      while (index-- > position) {
        current = current.prev;
      }
    }

    return current.data;
  }

  /**
   * indexOf 方法
   * 找到传入数据在链表中的索引
   * @param {null} data
   */

  indexOf(data) {
    // 1.定义变量
    let current = this.head;
    let index = 0;

    // 查找和data相同的节点
    while (current) {
      if (current.data == data) {
        return index;
      }
      current = current.next;
      index += 1;
    }

    return -1;
  }

  /**
   * update 方法
   * @param {number} position 要更新的数据的索引
   * @param {any} newData 修改后的数据
   */

  update(position, newData) {
    // 1.越界的判断
    if (position < 0 || position >= this.length) return false;

    // 2.寻找正确的节点
    let current = this.head;
    let index = 0;

    while (index++ < position) {
      current = current.next;
    }

    // 3.修改找到节点的data信息
    current.data = newData;
    return true;
  }

  /**
   * removeAt方法 删除指定位置的节点元素
   * @param {number} position
   */

  removeAt(position) {
    // 1.越界判断
    if (position < 0 || position >= this.length) return null;

    // 2.判断是否只有一个节点
    let current = this.head;
    if (this.length == 1) {
      this.head = null;
      this.tail = null;
    } else {
      if (position === 0) {
        // 判断是否删除的是第一个节点
        this.head.next.prev = null;
        this.head = this.head.next;
      } else if (position === this.length - 1) {
        // 如果删除的是最后一个节点
        current = this.tail;
        this.tail.prev.next = null;
        this.tail = this.tail.prev;
      } else {
        // 如果删除的是中间的节点
        let index = 0;
        while (index++ < position) {
          current = current.next;
        }
        current.prev.next = current.next;
        current.next.prev = current.prev;
      }
    }

    this.length -= 1;

    return current.data;
  }

  /**
   * remove 方法 删除指定的节点数据
   * @param {any} data 要删除的节点数据
   */

  remove(data) {
    // 1.根据data获取下标值
    let index = this.indexOf(data);

    // 2.根据index删除对应的节点
    return this.removeAt(index);
  }

  /**
   * isEmpty方法
   * 数据链表是否为空
   */
  isEmpty() {
    return this.length === 0;
  }

  /**
   * size 方法 返回链表的长度
   */

  size() {
    return this.length;
  }

  /**
   * getHead 获取链表的第一个元素
   *
   */

  getHead() {
    return this.head.data;
  }

  /**
   * getTail 获取链表的最后一个元素
   */

  getTail() {
    return this.tail.data;
  }

  /**
   * toString方法
   */

  toString() {
    return this.backwardString();
  }

  /**
   * forwardString方法
   * 依次向前遍历获取每一个节点 并返回对应的字符串
   */

  forwardString() {
    // 1.定义变量
    let current = this.tail;
    let resultString = '';

    // 2.依次向后遍历获取每一个节点
    while (current) {
      resultString += current.data + ' ';
      current = current.prev;
    }

    return resultString;
  }

  /**
   * backwardString方法
   * 依次向后遍历获取每一个节点 并返回对应的字符串
   */

  backwardString() {
    // 1.定义变量
    let current = this.head;
    let resultString = '';

    // 2.依次向后遍历获取每一个节点
    while (current) {
      resultString += current.data + ' ';
      current = current.next;
    }

    return resultString;
  }
}

let list = new DoublyLinkedList();

list.append('a');
list.append('b');
list.append('c');
list.append('e');
list.append('f');

console.log(list.remove('f'));

console.log(list.remove('a'));

console.log(list.remove('e1'));

console.log(list.toString());
console.log(list.isEmpty());
console.log(list.size());

console.log(list.getHead());

console.log(list.getTail());
```

- 集合

```ts
/**
 * 集合的概念
 * 集合比较常见的实现方式是哈希表
 *
 * 集合通常是由一组无序的 不能重复的元素构成
 * 1.在数学中的集合名词比较相似 但数学中的集合范围更大一些 也允许集合中的元素重复
 * 2.在计算机中 集合通常表示的结构中元素是不能重复的
 *
 * 不能通过下标值进行访问
 * 相同的对象在集合中只能存一份
 *
 *
 * ES6中包含的Set类就是集合的实现
 *
 *
 * 集合常用的操作方法
 * 1.add(value):向集合添加一个新的项
 * 2.remove(value): 从集合移除一个值
 * 3.has(valus):如果值在集合中 返回true 否则返回false
 * 4.clear() 移除集合中的所有项
 * 5.size() 返回集合所有包含元素的数量 于数组的length 属性类似
 * 6.values() 返回一个包含集合中所有值的数组
 *
 */

/**
 * 集合间的通常操作
 * 1.并集 对于给定的两个集合 返回一个包含两个集合中所有元素的新集合
 * 2.交集 对于给定的两个集合 返回一个包含两个元素共有元素的新集合
 * 3.差集 对于给定的两个集合 返回一个包含所有存在于第一个合集且不存在于第二个集合的元素的新集合
 * 4.子集 验证一个给定集合是否是另一个集合的子集
 */

/** 集合类  */
class Set {
  items = {};

  /**
   * add方法 添加数据
   * @param value 要添加的数据
   */
  add(value) {
    // 判断当前的集合中是否以及包含了该元素
    if (this.has(value)) return;

    // 将元素添加到集合中
    this.items[value] = value;
  }

  /**
   * has
   * 集合中是否以及包含某个数据
   * @param value 要检查的数据
   */
  has(value) {
    return this.items.hasOwnProperty(value);
  }

  /**
   * remove 删除元素的方法
   * @param {any} value 要删除的元素
   */
  remove(value) {
    // 1.判断该集合中是否包含该元素
    if (!this.has(value)) return false;

    // 2.将元素从属性中删除
    delete this.items[value];
    return true;
  }

  /**
   * clear 情况集合的方法
   */
  clear() {
    this.items = {};
  }

  /**
   * size 方法 返回集合的长度
   */
  size() {
    return Object.keys(this.items).length;
  }

  /**
   * 获取集合中所有的值
   */
  values() {
    return Object.keys(this.items);
  }

  /**
   * 集合间的操作 并集的实现
   * @param {Set} otherSet
   */
  union(otherSet) {
    // 1.创建一个新的集合
    let unionSet = new Set();

    // 2.将A集合中所有的元素添加到新集合中
    let values = this.values();
    values.forEach((item) => {
      unionSet.add(item);
    });

    // 3.取出B集合中的元素 判断是否需要加入到新集合中
    values = otherSet.values();
    values.forEach((item) => {
      unionSet.add(item);
    });

    return unionSet.values();
  }

  /**
   * 集合间的操作 交集的实现
   * @param {Set} otherSet
   */
  intersection(otherSet) {
    // 1.创建新的集合
    let intersectionSet = new Set();

    // 从A中取出一个个元素,判断是否同时存在于集合B中 如果存在则放入到新的集合中
    let values = this.values();
    values.forEach((item) => {
      if (otherSet.has(item)) {
        intersectionSet.add(item);
      }
    });

    return intersectionSet.values();
  }

  /**
   * 集合间的操作 差集的实现
   * @param {Set} otherSet
   */
  difference(otherSet) {
    // 1.创建新的集合
    let defferenceSet = new Set();

    // 从A中取出一个个元素,判断是否同时存在于集合B中 如果不存在则放入到新的集合中
    let values = this.values();
    values.forEach((item) => {
      if (!otherSet.has(item)) {
        defferenceSet.add(item);
      }
    });

    return defferenceSet.values();
  }

  /**
   * 集合间的操作 判断是否为子集的实现
   * @param {Set} otherSet
   */
  subset(otherSet) {
    // 遍历集合A中所有的元素 如果发现 集合A中的元素
    // 在集合B中不存在 那么返回false
    // 如果遍历完整个集合 依然没有返回false 那么返回true即可
    let values = this.values();
    for (let item of values) {
      if (!otherSet.has(item)) {
        return false;
      }
    }

    return true;
  }
}

let setA = new Set();

setA.add('c');
setA.add('d');

let setB = new Set();

setB.add('c');
setB.add('d');
setB.add('e');
setB.add('f');

let unionA = setA.subset(setB);
console.log(unionA);
```

- 字典

```ts
/**
 * ES6中的Map
 *
 * 字典的特点
 * 1.字典的主要特点是一一对应的关系
 * 2.例如保存一个人的信息 在合适的情况下取出这些信息
 * 3.使用数组的方式 可以通过下标取到信息
 * 4.使用字典的方式 可以通过key取出value
 * 5.另外字典中的key 是不可以重复的 而value可以重复 并且字典中的key是无序的
 *
 * 字典和映射的关系
 * 1.某些编程语言中称这种映射关系为字典
 * 2.有些编程语言中称这种映射关系为Map
 *
 * 字典和数组
 * 1.字典可以非常方便的通过key来搜索对应的value key可以包含特殊的含义 容易被人记住
 *
 * 字典和对象
 * 1.java中对象通常是一种在编辑其就确定下来的结构 不可以动态添加或删除属性
 * 1.字典通知会使用类似于哈希表的数据结构取实现一种可以动态的添加数据的结构
 *
 * 在js中对象本身就是一种字典 完成可以使用对象来替代字典
 */
```

- 哈希表

```ts
/**
 * 哈希表介绍
 * 1.几乎所有的编程语言都直接或者间接的应用到哈希表这种数据结构
 *
 * 哈希表通常基于数组进行实现 但是相对于数组 它有很多的优势
 * 1.它可以提供非常快速的插入-删除-查找操作
 * 2.无论多少数据 插入和删除值需要接近常量的时间:即O(1)的时间级 实际上只需要几个机器指令即可完成
 * 3.哈希表的速度比数还要快 基本可以瞬间查找到想要的元素
 * 4.哈希表相对于数来说编码要容易很多
 *
 * 哈希表相对于数组的一些不足
 * 1.哈希表中的数据是么有顺序的 所以不能以一种固定的方式例如从小到大来遍历其中的元素
 * 2.通常情况下 哈希表中的key是不允许重复的 不能放置相同的key 用于保存不同的元素
 *
 * 哈希表到底是什么
 * 1.哈希表的结构就是数组 当时它的神奇之处在于它对下标值的一种变换 这种变换我们可以称之为哈希函数
 * 通过哈希函数可以获取到HashCode
 *
 * 最好选择使用哈希表的案例
 * 1.公司使用一种数据结构来保存所有的员工
 * 2.设计一种数据结构 保存联系人和电话
 * 使用一种数据结构存储单词信息 例如50000个单词 找到单词后每个单词有字典的翻译|读音|运用
 *
 *
 * 字母转数字的方案1
 * 1.重点将字符串转成下标值
 * 2.我们需要设计一种方案 可以将单词转成适当的下标
 *
 * 第一种方案:使用编码
 * 例如ASCII编码 a是97 b是98 依次类推122是z
 * 暴露的问题 容易产生重复
 *
 * 第二种方案：幂的连乘
 * 我们平时使用的大于10的数组可以使用一种幂的连乘来表示它的唯一性
 * 例如：7654 = 7 * 10(3次方) + 6 * 10(2次方) + 5 * 10(1次方) + 4
 * 单词也可以使用这种方案来表示 例如cats
 * 3*27(3次方) + 1*27(2次方) + 20*27 + 17 = 60337 (选择27是因为有27个字符空格算一个)
 * 这样得到的数字可以基本保证它的唯一性 不会和别的单词重复
 * 该方案暴露的问题：
 * 如果下标很大会创建一个很大的数组 实际上有很多无效的单词
 * 创建这么大的数组是没有意义的
 *
 * 认识哈希化
 * 现在需要将幂连乘方案系统中得到的巨大整数范围压缩到可以接受的数组范围内
 * 1.有50000个单词 会定义一个长度为50000的数组
 * 2.实际需要更大的空间来存储这些单词 取两倍的大小100000
 * 3.压缩方案
 *   使用取余操作符
 *   一个数被另一个数整除后的余数
 *   下标的结果；index = lagerNumber % smallRange;
 *   lagerNumber表示 较大的数字 0-199
 *   smallRange表示要压缩到的范围 例如0-9
 *   例如一个数被10整除后 余数一定在0-9之间
 *   会有一定的概率出现重复的情况
 *
 * 什么是哈希化
 * 将大数字转化成数组范围内下标的过程 我们称之为哈希化
 *
 * 什么是哈希函数
 * 我们将单词转换为大数字 大数字在进行哈希化的代码实现函数 称为哈希函数
 *
 * 什么是哈希表
 * 最终将数据插入到这个数组 对整个结构的封装 我们称之为一个哈希表
 *
 *
 * 解决冲突的方案(下标重复)
 * 1.链地址法(拉链法)
 * 2.开放地址法
 *
 * 链地址法(拉链法)
 * 1.链地址法解决冲突的方法是每个数组单元中存储的不再是单个数据 而是一个链条(可以是数组或链表)
 * 2.例如链表 每个数组单位存储一个链表 如果有下标重复 将重复的元素插入到链表的首端或末端即可
 * 3.查询的时候,先根据哈希化后的下标找到对于的位置 取出链表 依次查询要寻找的数据
 *
 * 开放地址法
 * 1. 开放地址法的主要工作方式是寻找空白的单元个来添加重复的数据
 * 2.但是探索这个空白位置的方式不同 有三中方法(最大的区别在于寻找空位置的步长算法不同)
 *   线性探索
 *   二次探索
 *   再哈希法
 *
 * 线性探索
 * 1.经过哈希化后得到index=2,但是插入的时候发现该位置以及有82了
 * 2.从index位置+1开始一点点查找合适的位置来放置32
 * 3.空的位置就是合适的位置
 *
 * 查询32
 * 1.经过哈希化后得到index=2 看2的位置结果和查询的数值是否相同 如果相同则直接返回
 * 2.如果不同 从index位置+1开始查找32 如果查询到空位置则停止查找
 * 3.32不可能跳过空位置去其他的位置
 *
 * 删除32
 * 1.删除操作一个数据项 不可以将这个位置下标的内容设置为null
 * 2.通常删除一个位置的数据项时 把它的值设置为-1
 * 3.当查询看到-1位置的数据项的时候就知道要继续查询 但是插入时这个位置可以放置数据
 *
 * 线性探测的问题
 * 1.一连串填充单位叫做集聚,集聚会影响哈希表的性能 无论是插入/查询/删除都会有影响
 * 2.例如插入32 发现连续的单元都有值不允许我们放置数据 在这个过程我们需要探锁多次
 *
 * 二次探测
 * 1.二次探测主要优化的是探测步长
 * 2.线性探测可以看成是步长为1的探测 x+1 x+2 x+3 依次探测
 * 3.二次探测对步长做来优化 x+1(2次方) x+2(2次方) x+3(2次方)
 * 4.一次探测较长的距离 避免哪些聚集带来的影响
 *
 * 二次探测的问题
 * 1.如果出现步长不一的集聚 还是会影响效率
 *
 * 再哈希法
 * 1.把关键字用另外一个哈希函数 再做一次哈希化 用这次的哈希化的结果作为步长
 * 2.对于指定的关键字步长在整个探测的过程中是不变的 不过不同的关键字使用不同的步长
 *
 * 再哈希法特点
 * 1.不能和第一个哈希函数一样 否则结果还是原来的位置
 * 2.不能输出0 否则没有步长
 * 3.计算机专家以及设计出一种很好的哈希函数
 * stepSize = constant -(key % contant)
 * 其中constant 是质数 并且小于数组的容量
 * 例如 stepSize = 5 (key % 5) 满足需求 并且结果不可能为0
 *
 *
 * 哈希化的效率分析
 * 了解什么是装填因子
 * 1.装填因子 = 总数据项 / 哈希表长度
 * 2.开放地址法的装填因子最大是1,因为它必须找到空白的单元才能将元素放入
 * 3.链地址法的装填因子可以大于1 拉链法可以无限延伸下去
 *
 * 一次探测的效率
 * 1.当装填因子是1/2时 成功的搜索需要1.5次比较 不成功的搜索需要2.5次
 * 2.当装填因子为2/3 分别需要2.0次和5.0次
 * 3.如果装填因子更大 比较次数会非常大
 * 4.应该使装填因子保持在2/3以下 最好在1/2以下
 * 5.装填因子越低对于给定数量的数据项 就需要越多的空间
 * 6.随着装填因子装填因子变小 存储效率下降 而速度上升
 *
 * 二次探测和哈希化
 * 1.当装填因子是0.5时 成功和不成功的查找平均需要2次比较
 * 2.当装填因子是2/3时 分别需要2.37 和 3.0 次比较
 * 3.当装填因子为0.8时候 分别需要2.9 到 5.0次
 * 4.对于较高的装填因子 对比线性探测 二次探测和再哈希法效率要高一些
 *
 * 哈希表中执行插入和搜索的效率是非常高的
 * 1.如果没有冲突效率会很高
 * 2.如果发生冲突存取实际依赖后来的探测长度
 * 3.随着装填因子变大 探测长度会越来越长
 * 4.随着填充因子的变大 效率会下降
 *
 * 链地址法效率
 * 1.平均每个链表有多少个数据 N/arraySize (等同于装填因子)
 * 2.成功可能只要查找链表的一半即可 1+ loadFactor/2
 * 3.不成功要查询整个链表 1 + loadFactor
 * 4.链地址法的效率要好于开放地址法
 * 5.在实际开放中使用链地址法的情况比较多
 *   因为它不会因为添加链某个元素后性能出现急剧下降
 *   例如Java的HashMap中使用的就是链地址法
 *
 *
 * 优秀的哈希函数应该具备的特点
 * 1.快速计算
 * 2.均匀分布 尽可能地将元素映射到不同位置 让元素在哈希表中均匀的分布
 *
 * 快速计算:霍纳法则 或称为秦九韶算法
 * 多项式优化
 * 乘法次数N次
 * 加分次数N次
 * 如果用大O表示时间复杂度的化 相对应先前的算法 从O(N的2次方) 降到了O(N)
 *
 * 均匀分布
 * 1.需要用到常量的地方尽量使用质数
 * 质数的使用(一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数。)
 * 1.哈希表的长度
 * 2.N次幂的底数
 * 3.链地址法中质数没那么重要 甚至在java中故意是2的N次幂
 *
 * 什么情况下进行扩容呢
 * 1.比较常见的情况是loadFactor > 0.75 的时候进行扩容
 *
 * 质数的特点
 * 1.质数也称为素数
 * 2.质数表示大于1的自然数中 只能被1和自己整除的数
 * 3.一个数若可以被因式分解 那么分解的两个数 一个小于等于 它的开平方 一个大于它的开平方
 * 16 => 4*4  => 2*8  2小于4
 *
 *
 */
/**
 * HashTable 哈希表
 */

class HashTable {
  /** storage作为数组 数组中存放相关的元素  */
  storage = [];
  /** count表示当前已经存在多少数据  */
  count = 0;
  /** limit用于标记数组中一共可以存放多少个元素  */
  limit = 7;

  /**
   * 判断一个数是否为质数
   */
  isPrime(num) {
    let temp = parseInt(Math.sqrt(num));
    for (let i = 2; i < temp; i++) {
      if (num % i === 0) return false;
    }

    return true;
  }

  /**
   * 获取质数的方法
   * @param {number} num
   */

  getPrime(num) {
    while (!this.isPrime(num)) {
      num++;
    }

    return num;
  }

  /**
   * 设计哈希函数
   * 1.将字符串转换成比较大的数字 : hashCode
   * 2.将大的数字hashCode压缩到数组范围(大小)内
   * @param {string} str 要转换的字符串
   * @param {number} size 数组的长度
   */
  hashFunc(str, size) {
    // 1.定义hashCode变量
    let hashCode = 0;

    // 2.霍纳算法 来计算hashCode的值
    for (let i = 0; i < str.length; i++) {
      hashCode = 37 * hashCode + str.charCodeAt(i);
    }

    // 3.取余操作
    let index = hashCode % size;

    return index;
  }

  /**
   * 插入或修改操作
   * @param {string} key 要插入或修改的key
   * @param {any} value 要插入或修改的数据
   */
  put(key, value) {
    // 1.根据key获取对应的index
    let index = this.hashFunc(key, this.limit);

    // 2.根据index取出对应的bucket
    let bucket = this.storage[index];

    // 3.判断该bucket是否为存在
    if (!bucket) {
      bucket = [];
      this.storage[index] = bucket;
    }

    // 4.判断是否是修改数据
    for (let i = 0; i < bucket.length; i++) {
      let tuple = bucket[i];
      if (tuple[0] === key) {
        tuple[1] = value;
        return;
      }
    }

    // 5.进行添加操作
    bucket.push([key, value]);
    this.count += 1;

    // 6.判断是否需要扩容操作
    if (this.count > this.limit * 0.75) {
      let size = this.limit * 2;
      let limit = this.getPrime(size);
      this.resize(limit);
    }
  }

  /**
   * get获取元素
   * @param {string} key 要查找元素的key
   */

  get(key) {
    // 1.根据key获取对应的index
    let index = this.hashFunc(key, this.limit);
    // 2.根据index获取对应的bucket
    let bucket = this.storage[index];

    // 3.判断bucket是否存在
    if (!bucket) return null;

    // 4.有bucket 那么进行线性查找
    for (let item of bucket) {
      if (item[0] === key) return item[1];
    }

    // 5.依然没有找到 返回null
    return null;
  }

  /**
   * remove删除操作
   * @param {string} key 要删除数据的key
   */

  remove(key) {
    // 1.根据key获取对应的index
    let index = this.hashFunc(key, this.limit);
    // 2.根据index取出对应的bucket
    let bucket = this.storage[index];

    // 3.判断bucket是否为null
    if (!bucket) return null;

    // 4.有bucket 那么进行线性查找
    for (let i = 0; i < bucket.length; i++) {
      let tuple = bucket[i];
      if (tuple[0] === key) {
        bucket.splice(i, 1);
        this.count--;

        // 缩小容量
        if (this.limit > 7 && this.count < this.limit * 0.25) {
          let size = Math.floor(this.limit / 2);
          let limit = this.getPrime(size);
          this.resize(limit);
        }
        return tuple[1];
      }
    }

    // 5.依然没有找到 那么返回null
    return null;
  }

  /**
   * 判断哈希表是否为空
   */
  isEmpty() {
    return this.count === 0;
  }

  /**
   * 判断哈希表中元素的个数
   */
  size() {
    return this.count;
  }

  /**
   * 对哈希表进行扩容
   * @param {number} newLimit
   */
  resize(newLimit) {
    // 1.保存旧的的数组内容
    let oldStorage = this.storage;

    // 2.重置所有属性
    this.storage = [];
    this.count = 0;
    this.limit = newLimit;

    // 遍历oldStorage中的所有bucket
    for (let bucket of oldStorage) {
      if (!bucket) continue;

      for (let item of bucket) {
        this.put(item[0], item[1]);
      }
    }
  }
}

// 测试代码
// console.log(hashFunc("abc", 7));
// console.log(hashFunc("cba", 7));
// console.log(hashFunc("nba", 7));
// console.log(hashFunc("mba", 7));

let h = new HashTable();
h.put('aa1', '值1');
h.put('aa5', '值5');
h.put('aa2', '值2');
h.put('aa3', '值3');
h.put('aa4', '值4');
h.put('aa4', '值404');
console.log(h);

console.log(h.get('aaa'));

// console.log(h.remove("aaa"));

console.log(h.isEmpty());
console.log(h.size());
console.log(h.isPrime(101));
console.log(h.isPrime(10));
```

- 树结构

```ts
/**
 * 树结构
 * 1.树结构的非线性 可以表示一对多的关系
 * 2.例如文件的目录结构
 *
 * 树
 * 1.n个节点构成的有限集合
 * 2.n=0 称为空树
 * 3.非空树具有以下特质
 *   根(root)节点用r表示
 *   子节点称为子树
 *
 * 树的术语
 * 1.节点的度 :节点的子树个数
 * 2.树的度: 树的所有节点中最大的度数
 * 3.叶节点: 度为0 的节点 也称为叶子节点
 * 4.父节点: 有子树的节点是其子树的根节点的父节点
 * 5.子节点: 若A节点是B节点的父节点 则称B节点是A节点的子节点
 * 6.兄弟节点: 具有同一父节点的节点彼此是兄弟节点
 * 7.路径和路径长度:从节点n1 到nk的路径为一个节点序列n1,n2...nk,ni+1的父节点 路径所包含边的个数为路径的长度
 * 8.节点的层次: 规定根节点在1层 其他任意节点的层树是其父节点的层数加1
 * 9.树的深度: 树中所有节点中的最大层次是这颗树的深度
 *
 * 二叉树
 * 1.其实所有树的本质上都可以使用二叉树模拟出来
 * 2.所有学习树的过程中 二叉树非常重要
 * 3.二叉树可以为空也就是没有节点
 * 4.若不为空 则它是有根节点和称为其左子树TL和右子树TR的两个不相交的二叉树组成
 *
 * 二叉树有几个比较重要的特性
 * 1.一个二叉树第i层的最大节点数为 2的(i-1)次方 , i>=1;
 * 2.深度为k的二叉数有最大节点总数为 2的k次方-1 k>=1;
 * 3.对任何非空二叉数T 若n0表示叶节点的个数 n2是度为2的非节点个数 那么两者满足关系n0 = n2 + 1;
 * 4.例如叶节点数是4 分别是d,j,k,h 度为2的节点分别是a,b,e 公式 4 = 3+1
 *
 * 完美二叉数 也称为满二叉数
 * 1.在二叉树中 除了最下一层的叶节点外 每一层都有2个子节点 就构成两满二叉树
 *
 * 完全二叉树
 * 1.除二叉树最后一层外 其他各层的节点数都达到最大个数
 * 2.且最后一层从左向右的叶节点连续存在 只缺右侧若干节点
 * 3.完美二叉树是特殊的完全二叉树
 *
 *
 * 二叉树的存储常见方式是数组和链表
 *
 * 使用数组
 * 1.完全二叉树:按从上到下 从左到右的顺序存储
 * 2.非完全二叉树
 *   要先转换为完全二叉树再按照上面的方案存储
 *   会造成很大的空间浪费
 *
 * 二叉树最常见的方式还是使用链表存储
 * 1.每个节点封装成一个node node中存储的数据 左节点的引用 右节点的引用
 *
 * 二叉搜索树(BST Binary Search Tree) 也称为二叉排序树或二叉查找树
 * 1.二叉搜索树是一颗二叉树 可以为空
 * 2.如果不为空需要满足如下性质
 *   非空左子树的所有键值小于其根点的键值
 *   非空右子树的所有键值大于其根节点的键值
 *   左,右子树本身也是二叉搜索树
 * 3.二叉搜索树的特点
 *   相对较小的值总是保存在左节点上 相对较大的值总是保存在右节点上
 *   查找效率非常高 这也是二叉搜索树中 搜索的来源
 *
 *
 * 二叉搜索树常见的操作
 * 1.insert(key) 向树中插入一个新的键
 * 2.search(key) 在树中查找一个键 如果节点存在 则返回true 如果不存在则返回false
 * 3.inOrderTraverse 通过中序遍历方式遍历所有的节点
 * 4.preOrderTraverse 通过先序遍历的方式遍历所有节点
 * 5.postOrderTraverse 通过后序遍历方式遍历所有节点
 * // 层序遍历
 * 6.min 返回树中最小的值/键
 * 7.max 返回树中最大的值/键
 * 8.remove(key) 从树中移除某个键
 *
 *
 * 先序遍历
 * 1.访问根节点
 * 2.先序遍历其左子树
 * 3.先序遍历其右子树
 *
 * 中序遍历
 * 1.中序遍历其左子树
 * 2.访问根节点
 * 3.中序遍历其右子树
 *
 *
 * 后序遍历
 * 1.后序遍历其左子树
 * 2.后序遍历其右子树
 * 3.访问根节点
 *
 *
 *                   11
 *
 *           7                  15
 *     5         9         13         20
 * 3      6   8    10   12   14   18    25
 *
 * 先序遍历 // 11 7 5 3 6 9 8 10 15 13 12 14 20 18 25
 * 中序遍历 // 3 5 6 7 8 9 10 11 12 13 14 15 18 20 25
 * 后续遍历 // 3 6 5 8 10 9 7 12 14 13 18 25 20 15 11
 *
 * 二叉搜索树的删除操作
 * 1.找到要删除的节点
 * 2.如果该节点是叶子节点则直接删除
 * 3.如果该节点有一个子节点
 * 4.该节点有两个子节点(这种情况就比较复杂了)
 *
 * 如果删除的节点有两个子节点
 * 1.找比current小一点点的节点 一定是current左子树的最大值 称为current节点的前驱
 * 2.找比current大一点点的节点 一定是current右子树的最小值 称为current节点的后继
 *
 * 二叉搜索树的缺陷
 * 1.比较好的二叉搜索树的数据结构是左右分布均匀的
 * 2.但是插入连续数据后 分布的变的不均匀了 我们称这种树为非平衡树
 * 3.对于一颗平衡二叉树来说 插入/查找等操作的效率是O(logN)
 * 4.对于一个非平衡二叉树 相当于编写来一个链表 查找效率变成了O(N)
 */
/** 封装二叉搜索树  */
class BinarySearchTree {
  // 根节点
  root = null;
  /**
   * 创建插入的节点
   * @param {string | number} key key值
   * @param {any} value
   */
  createNode(key, value) {
    return {
      key,
      value,
      left: null,
      right: null,
    };
  }

  /**
   * 插入数据
   * @param {string | number} key key值
   * @param {any} value
   */

  insert(key, value) {
    // 1.根据key和value创建节点
    let newNode = this.createNode(key, value);

    // 2.判断根节点是否有值
    if (this.root === null) {
      this.root = newNode;
    } else {
      this.insertNode(this.root, newNode);
    }
  }

  /**
   * 查找合适位置并插入节点的方法
   * @param node 当前对比的节点
   * @param newNode 要插入的新节点
   */

  insertNode(node, newNode) {
    if (newNode.key < node.key) {
      // 向左查找
      if (node.left === null) {
        node.left = newNode;
      } else {
        this.insertNode(node.left, newNode);
      }
    } else {
      // 向右边查找
      if (node.right === null) {
        node.right = newNode;
      } else {
        this.insertNode(node.right, newNode);
      }
    }
  }

  /**
   * 树的遍历
   * 先序遍历
   * @param {function} handler 遍历到节点后的回调函数
   */
  preOrderTraversal(handler) {
    this.preOrderTraversalNode(this.root, handler);
  }

  /**
   * 先序遍历节点的方法
   * @param {any} node 要遍历的节点
   * @param handler 遍历到节点后的回调函数
   */
  preOrderTraversalNode(node, handler) {
    // 如果节点是存在的
    if (node !== null) {
      // 1.处理经过的节点
      handler(node);

      // 2.处理经过节点的左子节点
      this.preOrderTraversalNode(node.left, handler);

      // 3.处理经过节点的右子节点
      this.preOrderTraversalNode(node.right, handler);
    }
  }

  /**
   * 树的遍历
   * 中序遍历
   * @param {function} handler 遍历到节点后的回调函数
   */
  midOrderTraversal(handler) {
    this.midOrderTraversalNode(this.root, handler);
  }

  /**
   * 先序遍历节点的方法
   * @param {any} node 要遍历的节点
   * @param handler 遍历到节点后的回调函数
   */
  midOrderTraversalNode(node, handler) {
    // 如果节点是存在的
    if (node !== null) {
      // 1.处理经过节点的左子节点
      this.midOrderTraversalNode(node.left, handler);

      // 2.处理经过的节点
      handler(node);

      // 3.处理经过节点的右子节点
      this.midOrderTraversalNode(node.right, handler);
    }
  }

  /**
   * 树的遍历
   * 后序遍历
   * @param {function} handler 遍历到节点后的回调函数
   */
  postOrderTraversal(handler) {
    this.postOrderTraversalNode(this.root, handler);
  }

  /**
   * 先序遍历节点的方法
   * @param {any} node 要遍历的节点
   * @param handler 遍历到节点后的回调函数
   */
  postOrderTraversalNode(node, handler) {
    // 如果节点是存在的
    if (node !== null) {
      // 1.处理经过节点的左子节点
      this.postOrderTraversalNode(node.left, handler);
      // 3.处理经过节点的右子节点
      this.postOrderTraversalNode(node.right, handler);
      // 3.处理经过的节点
      handler(node);
    }
  }

  /**
   * 获取最大值
   */
  max() {
    // 1.获取根节点
    let node = this.root;

    // 2.依次向右不断查找
    while (node !== null && node.right) {
      node = node.right;
    }

    return node;
  }

  /**
   * 获取最小值
   */
  min() {
    // 1.获取根节点
    let node = this.root;

    // 2.依次向右不断查找
    while (node !== null && node.left) {
      node = node.left;
    }

    return node;
  }

  /**
   * 搜索某个key值
   * @param {number} key
   */

  search(key) {
    // 1.获取根节点
    let node = this.root;

    // 循环搜索key
    while (node !== null) {
      if (key < node.key) {
        node = node.left;
      } else if (key > node.key) {
        node = node.right;
      } else {
        return node;
      }
    }

    return null;
  }

  /**
   * 使用递归的方法来实现搜索功能
   * @param {number} key 查找的key
   */
  reSearch(key) {
    let node = this.root;
    return this.reSearchNode(key, node);
  }

  /**
   * 使用递归的方法来实现搜索功能
   * @param {number} key 查找的key
   * @param {any} node 查找的节点
   */
  reSearchNode(key, node) {
    if (node === null) return null;

    if (key === node.key) return node;

    if (key < node.key) {
      return this.reSearchNode(key, node.left);
    } else {
      return this.reSearchNode(key, node.right);
    }
  }

  /**
   * 删除节点
   * @param {number} key 要删除节点的key
   */
  remove(key) {
    // 1.寻找要删除的节点
    let current = this.root; // 开始查询的节点
    let parent = null; // 查询节点的父节点
    let isLeftChild = true; // 是否为左节点

    // 开始查找要删除的节点
    while (current.key !== key) {
      parent = current;

      if (key < current.key) {
        isLeftChild = true;
        current = current.left;
      } else {
        isLeftChild = false;
        current = current.right;
      }

      // 某种情况下 已经找到最后的节点 依然没有找到相等的key
      if (current === null) return false;
    }

    // 2 根据对应的情况删除节点
    // 如果删除的节点是叶子节点(没有子节点)
    if (current.left === null && current.right === null) {
      if (current === this.root) {
        // 如果要删除的是父节点
        this.root = null;
      } else if (isLeftChild) {
        parent.left = null;
      } else {
        parent.right = null;
      }
    } else if (current.right === null) {
      // 有一个左节点
      if (current === this.root) {
        // 如果删除的是根节点
        this.root = current.left;
      } else if (isLeftChild) {
        parent.left = current.left;
      } else {
        parent.right = current.left;
      }
    } else if (current.left === null) {
      // 有一个右节点
      if (current === this.root) {
        this.root = current.right;
      } else if (isLeftChild) {
        parent.left = current.right;
      } else {
        parent.right = current.right;
      }
    } else {
      // 删除的节点有两个子节点
      // 1.获取后继节点
      let successor = this.getSuccessor(current);

      // 2.判断是否是根节点
      if (current === this.root) {
        this.root = successor;
      } else if (isLeftChild) {
        parent.left = successor;
      } else {
        parent.right = successor;
      }

      // 将删除节点的左子树 = current.left
      successor.left = current.left;
    }
  }

  /**
   * 寻找后继的方法
   * @param delNode 要删除的节点
   */
  getSuccessor(delNode) {
    // 1.定义变量 保存找到的后继
    let successor = delNode;
    let current = delNode.right; // 从删除节点的右子树找后继
    let successorParent = delNode;

    // 2.循环查找
    while (current !== null) {
      successorParent = successor;
      successor = current;
      current = current.left;
    }

    // 3.判断找寻的后继节点是否直接就是delNode的right节点
    if (successor !== delNode.right) {
      successorParent.left = successor.right;
      successor.right = delNode.right;
    }

    return successor;
  }
}

let b = new BinarySearchTree();

b.insert(11, '值11');
b.insert(7, '值7');
b.insert(15, '值15');
b.insert(5, '值5');
b.insert(3, '值3');
b.insert(9, '值9');
b.insert(8, '值8');
b.insert(10, '值10');
b.insert(13, '值13');
b.insert(12, '值12');
b.insert(14, '值14');
b.insert(20, '值20');
b.insert(18, '值18');
b.insert(25, '值25');
b.insert(6, '值6');

// 删除测试
// 3 6 5 10 8 12 14 13 25 20 18 11
// b.remove(7);
// b.remove(9);
// b.remove(15);

console.log(b);

// 先序遍历测试代码
let prestr = '';
b.preOrderTraversal((node) => {
  prestr += node.key + ' ';
});

// 11 7 5 3 6 9 8 10 15 13 12 14 20 18 25
console.log('prestr', prestr);

// 中序遍历测试代码
let midstr = '';
b.midOrderTraversal((node) => {
  midstr += node.key + ' ';
});

// 3 5 6 7 8 9 10 11 12 13 14 15 18 20 25
console.log('midstr', midstr);

// 后序遍历测试代码
let poststr = '';
b.postOrderTraversal((node) => {
  poststr += node.key + ' ';
});

// 3 6 5 8 10 9 7 12 14 13 18 25 20 15 11
console.log('poststr', poststr);

console.log('max', b.max());
console.log('min', b.min());

console.log('search', b.search(11));
console.log('reSearch', b.reSearch(11));
```

- 树的平衡(红黑树)

```ts
/**
 * 平衡树
 * 树中的每个节点左边的子孙节点的个数 应该尽可能等于右边的子孙节点的个树
 *
 * 常见的平衡树
 * 1.AVL树(用得少)
 * 2.红黑树(用得多)
 *   插入和删除等操作 红黑树的性能要优于AVL树 所以现在的平衡树的应用基本都是红黑树
 *
 * 红黑树的基本规则:
 * 1.节点是红色或黑色
 * 2.根节点是黑色
 * 3.每个叶子节点都是黑色的空节点(null节点)
 * 4.每个红色节点的两个子节点都是黑色
 * 5.从每个叶子节点到根的所有路径上不能有两个连续的红色节点
 * 6.从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点
 *
 *
 * 红黑树的关键特性
 * 1.从根到叶子的最长可能路径 不会超过最短可能路径的两倍
 *   路径不能有两个相连的红色节点
 *   最短的可能路径都是黑色节点
 *   最长的可能路径是红色和黑色交替
 *   所有路径都有相同数目的黑色节点
 *   这些表明两没有路径能多于任何其他路径的两倍长
 *
 *
 * 1.插入一个新节点的时候 通过换色- 左旋转 - 右旋转来保存树的平衡
 *
 * 变色
 * 1.插入的新节点通常都是红色节点
 *
 * 左旋转
 * 1.逆时针旋转红黑树的两个节点 使得父节点被自己的右孩子取代 自己成为原来子节点的左孩子
 * 身为右孩子的Y取代了X的位置 而X变成了Y的左孩子 此为左旋转
 *
 * 右旋转
 * 1.顺时钟旋转红黑树的两个节点 使得父节点被自己的左孩子取代 而自己成了原来子节点的右孩子
 * 身为左孩子的Y取代了X的位置 而X变成了Y的右孩子 此为右旋转
 *
 * 插入操作
 * 1.假定要插入的节点为N 其父节点为P
 * 2.其祖父节点为G 父节点的兄弟节点为U
 *         G
 *    P        U
 *
 *  N
 *
 * 情况三 P为红色 U也为红色
 * 1.将P和U变为黑色 将G变为红色 保证满足每条路径上黑色节点数目是一致的
 * 2.可能出现的问题:
 *   N的祖父节点G的父节点也可能是红色的 违法规则需要递归调整颜色
 *   如果递归调整颜色到根节点 就需要进行旋转
 *
 * 情况四 N的叔叔节点U是黑节点 且N是左孩子
 * 1.对祖父节点G进行依次右旋转
 * 2.在旋转查收的树中 以前的父节点P现在是新节点以前祖父节点G的父节点
 * 3.交互以前的父节点P和祖父节点G的颜色 P为黑色 G变成红色
 * 4.B节点向右平移 称为G节点的左子节点
 *
 * 情况五
 * N的叔叔U是黑色节点 且N是右孩子
 * 父红叔黑祖黑 N是右儿子
 * 以P为根 左旋转
 * 自己变称黑色 祖父变成红色
 * 以组为根进行右旋转
 *
 * 1.对P节点进行依次左旋转
 * 2.对祖父节点G进行一次右旋转 并且改变颜色即可
 *
 */
```

- 图论

```ts
/**
 * 什么是图
 * 1.图结构是一种与树结构有些相类似的数据结构
 * 2.图论是数学的一个分支 并且 在数学的概念上树是图的一种
 * 3.它以图为研究对象 研究顶点和边组成的图形的数学理论和方法
 * 4.主要研究的目的是事物之间的关系 顶点代表事物 边代表两个事物间的关系
 *
 *
 * 图的特点
 * 1.一组顶点 通常用V(vertex)表示定点集合
 * 2.一组边 通常用E(edge)表示边的集合
 *   边是顶点和顶点之间的连线
 *   边可以是有向的 也可以是无向的
 *   比如A --- B 通常表示无向 A --> B 通常表示有向的
 *
 * 度
 * 一个顶点的度就是与它相邻顶点的数量
 *
 * 路径
 * 1.路径是顶点v1...vn的一个连续序列
 * 2.简单路径 不包含重复顶点
 * 3.回路：第一个顶点和最后一个顶点相同的路径称为回路
 *
 * 无向图 所有边都没有方向
 *
 * 有向图； 边是有方向的
 *
 * 无权图 边没有携带权重
 *
 * 有权图 边携带一定的权重
 *
 * 邻接矩阵
 * 1.让每个节点和一个整树相关联 该整数作为数组的下标值
 * 2.用一个二维数组来表示顶点之间的连接
 * 3.二维数组[0][2] -> A -> C
 * 4.在二维数组中 0表示没有连线 1表示有连线
 * 5.通过二维数组 我们可以很快找到一个顶点和哪些顶点有连线(比如A顶点 只需要遍历第一行即可)
 * 6.另外 A-A B-B也就是顶点到自己的连线 通常是使用0表示
 *
 * 邻接矩阵的问题:
 * 1.邻接矩阵还有一个比较严重的问题，就是如果图是一个稀疏图
 * 2.那么矩阵中将存在大量的0,这意味着我们浪费了计算机存储空间来表示根本不存在的边.
 *
 * 另外一种常用的表示图的方式:邻接表
 * 1.邻接表由图中每个顶点以及和顶点相邻的顶点列表组成
 * 2.这个列表有很多中方式来存储:数组/链表/字典(哈希表)都可以.
 *
 * 图片解析:
 * 其实图片比较容易理解.
 * 1.比如我们要表示和A顶点有关联的顶点(边)，A和B/C/D有边，
 * 2.那么我们可以通过A找到对应的数组/链表/字典再取出其中的内容就可以啦
 *
 * 邻接表的问题:
 * 1.邻接表计算"出度"是比较简单的(出度:指向别人的数量，入度:指向自己的数量)
 * 2.邻接表如果需要计算有向图的"入度"，那么是一件非常麻烦的事情.
 * 3.它必须构造一一个"逆邻接表”，才能有效的计算"入度”.但是开发中” 出度"相对用的比较少.
 *
 * 代码解析
 * 创建Graph的构造函数这个我们在封装其他数据结构的时候已经非常熟悉了.
 * 定义了两个属性:
 * 1.vertexes: 用于存储所有的顶点，我们说过使用一个数组来保存
 * 2.adjList: adj是adjoin的缩写，邻接的意思. adjList用于存储所有的边，我们这里采用邻接表的形式
 *
 *
 * 图的遍历
 * 图的遍历思想
 * 1.图的遍历思想和树的遍历思想是一样的.
 * 2.图的遍历意味着需要将图中每个顶点访问一遍,并且不能有重复的访问
 *
 * 有两种算法可以对图进行遍历
 * 1.广度优先搜索(Breadth- First Search,简称BFS)
 * 2.深度优先搜索(Depth- First Search,简称DFS)
 * 3.两种遍历算法，都需要明确指定第一个被访问的顶点.
 *
 * 两种算法的思想:
 * 1.BFS: 基于队列，入队列的顶点先被探索.
 * 2.DFS: 基于栈或使用递归，通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问.
 *
 * 为了记录顶点是否被访问过，我们使用三种颜色来反应它们的状态
 * 1.白色:表示该顶点还没有被访问.
 * 2.灰色:表示该顶点被访问过，但并末被探索过.
 * 3.黑色:表示该顶点被访问过且被完全探索过.
 *
 *
 * 广度优先搜索算法的思路:
 * 1.广度优先算法会从指定的第一个顶点开始遍历图， 先访问其所有的相邻点，就像一次访问图的-层.
 * 2.换句话说，就是先宽后深的访问顶点
 *
 * 广度优先搜索的实现
 * 1.创建一个队列Q
 * 2.将v标注为被发现的(灰色)，并将v加入队列Q
 *
 * 如果Q非空，执行下面的步骤:
 * 1.将v从Q中取出队列.
 * 2.将v标注为被发现的灰色.
 * 3.将v所有的未被访问过的邻接点(白色)，加入到队列中，
 * 4.将v标志为黑色.
 *
 *
 * 深度优先搜索的思路:
 * 1.深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径知道这条路径最后被访问了.
 * 2.接着原路回退并探索G条路径.
 *
 * 深度优先搜索算法的实现:
 * 1.广度优先搜索算法我们使用的是队列，这里
 * 2.可以使用栈完成，也可以使用递归.
 * 3.方便代码书写，我们还是使用递归(递归本质上就是函数栈的调用)
 */
class Queue {
  items = [];

  /** 1.向队列里添加元素  */
  enqueue(element) {
    this.items.push(element);
  }
  /** 2.从队列中删除前端元素  */
  dequeue() {
    return this.items.shift();
  }
  /** 3.查看前端的元素  */
  front() {
    return this.items[0];
  }
  /** 4.查看队列是否为空  */
  isEmpty() {
    return this.items.length === 0;
  }
  /** 5.查看队列中元素的个数  */
  size() {
    return this.items.length;
  }
  /** 6.toString方法  */
  toString() {
    return JSON.stringify(this.items);
  }
}

/**
 * 封装图结构
 */

class Graph {
  vertexes = []; // 存放顶点
  edges = {}; // 边

  /**
   * 添加方法
   * 添加顶点的方法
   * @param {any} v 要添加的顶点
   */
  addVertex(v) {
    this.vertexes.push(v);
    this.edges[v] = [];
  }

  /**
   * 添加边的方法
   * @param v1 顶点1
   * @param v2 定点2
   */
  addEdge(v1, v2) {
    this.edges[v1].push(v2);
    this.edges[v2].push(v1);
  }

  /**
   * 实现toString方法
   */
  toString() {
    let resultString = ``;
    Object.keys(this.edges).forEach((vertex) => {
      resultString += `${vertex} -> ${this.edges[vertex].join(',')}\n`;
    });

    return resultString;
  }

  /**
   * 初始化状态颜色
   */
  initiallzeColor() {
    let colors = {};
    Object.keys(this.edges).forEach((vertex) => {
      colors[vertex] = 'white';
    });

    return colors;
  }

  /**
   * 实现广度优先搜索(BFS)
   * @param initV 初始访问的顶点
   * @param handler 找到顶点后的回调函数
   */
  bfSearch(initV, handler) {
    // 1.初始化颜色
    let colors = this.initiallzeColor();

    // 2.创建队列
    let queue = new Queue();

    // 3.将顶点加入到队列中
    queue.enqueue(initV);

    // 4.循环从队列中取出元素
    while (!queue.isEmpty()) {
      // 1.从队列取出一个顶点
      let v = queue.dequeue();
      // 2.获取和顶点相邻的另外顶点
      let vList = this.edges[v];

      // 3.将v的颜色设置为灰色
      colors[v] = 'gray';

      // 4.遍历所有的顶点 并且加入到队列中
      vList.forEach((vertex) => {
        if (colors[vertex] === 'white') {
          colors[vertex] = 'gray';
          queue.enqueue(vertex);
        }
      });

      // 5.访问顶点
      handler(v);

      // 6.将顶点设置为黑色
      colors[v] = 'black';
    }
  }

  /**
   * 深度优先搜索(DFS)
   * @param initV 初始访问的定点
   * @param handler 访问到定点后的回调函数
   */
  dfSearch(initV, handler) {
    // 1.初始化颜色
    let colors = this.initiallzeColor();

    // 2.从某个定点开始依次递归访问
    this.dfsVisit(initV, colors, handler);
  }

  /**
   * 深度优先算法的递归节点访问
   * @param v 初始访问的定点
   * @param colors 定点颜色标记
   * @param handler 访问到定点后的回调函数
   */
  dfsVisit(v, colors, handler) {
    // 1.将颜色设置为灰色
    colors[v] = 'gray';
    // 2.处理v顶点
    handler(v);

    // 访问v相连的顶点
    let vList = this.edges[v];
    vList.forEach((vertex) => {
      if (colors[vertex] === 'white') {
        this.dfsVisit(vertex, colors, handler);
      }
    });
    // 4.将v设置为黑色
    colors[v] = 'black';
  }
}

let g = new Graph();

// 要添加的顶点
let myVertexes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];

for (let i = 0; i < myVertexes.length; i++) {
  g.addVertex(myVertexes[i]);
}

/// 添加边
g.addEdge('A', 'B');
g.addEdge('A', 'C');
g.addEdge('A', 'D');
g.addEdge('C', 'D');
g.addEdge('C', 'G');
g.addEdge('D', 'G');
g.addEdge('D', 'H');
g.addEdge('B', 'E');
g.addEdge('B', 'F');
g.addEdge('E', 'I');

console.log(g.toString());

let result = ``;
g.bfSearch(g.vertexes[0], (v) => {
  result += v + ' ';
});

console.log('bfSearch', result);

let resultd = ``;
g.dfSearch(g.vertexes[0], (v) => {
  resultd += v + ' ';
});

console.log('dfSearch', resultd);
```

## 排序算法

- 大 O 表示法的推导过程

```ts
/**
 *
 * 大 O 表示法
 * 1.在算法的描述中，我们也可以通过类似的快捷方式来描述计算机算法的效率.
 * 2.在计算机中，这种粗略的度量被称作大O"表示法，
 * 3.在算法比较的过程中，我们可能更喜欢说:算法A比算法B快两倍.但是这样的比较有时候没有意义.
 * 4.在数据项个数发生变化时，算法的效率会跟着发生改变.
 * 5.所以我们通常使用一种算法的速度会如何跟随着数据量的变化的.
 *
 *
 * 大O表示形式
 * O(1)  常数的
 * O(log(n))对数的
 * O(n)  线性的
 * O(nlog(n))  线性和对数乘积
 * O(n2) 平方
 * O(2n ) 指数的
 *
 * 推导大O表示法的方式:
 * ①用常量1取代运行时间中所有的加法常量
 * ②在修改后的运行次数函数中，只保留最高阶项
 * ③如果最高存在且不为1,则去除与这个项相乘的常数
 *
 *
 * 冒泡排序
 * 冒泡排序算法相对其他排序运行效率较低，但是在概念上它是排序算法中最简单的
 *
 * 冒泡排序的思路:
 * 对未排序的各元素从头到尾依次比较相邻的两个元素大小关系
 * 如果左边的队员高，则两队员交换位置
 * 向右移动一个位置，比较下面两个队员
 * 当走到最右端时，最高的队员一定被放在了最右边
 * 按照这个思路，从最左端重新开始，这次走到倒数第二个位置的队员即可.
 * 依次类推，就可以将数据排序完成
 *
 *
 *
 * 冒泡排序的比较次数:
 * 1.如果按照上面的例子来说一共有7个数字，那么每次循环时进行了几次的比较呢?
 * 2.第一次循环6次比较，第二次5次比较，第三次4次比较..直到最后一 趟进行了一次比较.
 * 3.对于7个数据项比较次数:6+5+4+3+2 + 1
 * 对于N个数据项呢? (N- 1) + (N-2) + (N-3) + .. + 1 =N*(N- 1)/ 2
 * 通过大0表示法推到过程，我们来推到
 * N*(N- 1)/ 2 = N2/2 - N/2,根据规则2,只保留最高阶项变成N2 / 2
 * N2 / 2,根据规则3,去除最高项的常量，变成N2
 * 因此冒泡排序的比较次数的大0表示法为O(N2)
 *
 *
 * 冒泡排序的交换次数:
 * 1.真实的次数:N★(N-1)/4
 * 2.冒泡排序的交换次数是多少呢?
 * 3.如果有两次比较才需要交换-次(不可能每次比较都交换一次)，那么交换次数为N2 / 4
 * 4.由于常量不算在大0表示法中，因此，我们可以认为交换次数的大0表示也是O(N2)
 *
 *
 * 选择排序改进了冒泡排序
 * 1.将交换的次数由O(N2)减少到O(N)
 * 2.但是比较的次数依然是O(N2)
 *
 * 选择排序的思路:
 * 1.选定第一个索引位置，然后和后面元素依次比较
 * 2.如果后面的队员，小于第一个索引位置的队员，则交换位置
 * 3.经过一轮的比较后，可以确定第一个位置是最小的
 * 4.然后使用同样的方法把剩下的元素逐个比较即可
 * 5.可以看出选择排序，第一轮会选出最小值，第二轮会选出第二小的值，直到最后
 *
 * 选择排序的比较次数:
 * 1.选择排序和冒泡排序的比较次数真实次数:N*(N-1)/2
 * 2.而大0表示法: O(N2).
 *
 * 选择排序的交换次数:
 * 1.选择排序每次进行选择的时候最多需要交换1次，一共遍历多少次呢? N - 1次
 * 2.选择排序的交换次数只有N-1次，用大0表示法就是O(N).
 * 3.所以选择排序通常认为在执行效率上是高于冒泡排序的.
 *
 * 区别
 * 1.冒泡排序是比较相邻位置的两个数，而选择排序是按顺序比较，找最大值或者最小值；
 * 2.冒泡排序每一轮比较后，位置不对都需要换位置，选择排序每一轮比较都只需要换一次位置；
 * 3.冒泡排序是通过数去找位置，选择排序是给定位置去找数；
 *
 * 插入排序
 * 1.插入排序是简单排序中效率最好的一一种.
 * 2.插入排序也是学习其他高级排序的基础，比如希尔排序/快速排序，所以也非常重要
 * 插入排序的思路
 * 1.局部有序:
 * 插入排序思想的核心是局部有序.什么是局部有序呢?
 * 比如在一个队列中的人，我们选择其中一个作为标记的队员.
 * 这个被标记的队员左边的所有队员已经是局部有序的.
 * 这意味着，有一部分人是按顺序排列好的.有一部分还没有顺序.
 *
 * 插入排序的思路:
 * 1.从第一个元素开始，该元素可以认为已经被排序
 * 2.取出下一个元素,在已经排序的元素序列中从后向前扫描
 * 3.如果该元素(已排序)大于新元素，将该元素移到下一位置
 * 4.重复上一个步骤,直到找到已排序的元素小于或者等于新元素的位置
 * 5.将新元素插入到该位置后， 重复上面的步骤.
 *
 * 插入排序的比较次数:
 * 1.第一趟时，需要的最多次数是1,第二趟最多次数是2,依次类推，最后趟是N-1次.
 * 2.因此是插入排序的最多次数:1+2+3+..+N-1=N*(N-1)/2.
 * 3.然而每趟发现插入点之前，平均只有全体数据项的一半需要进行比较，
 * 4.我们可以除以2得到N★(N- 1) / 4.所以相对于选择排序，其他比较次数是少了一半的.
 *
 * 插入排序的复制次数:
 * 1.第一趟时，需要的最多复制次数是1,第二趟最多次数是2, 依次类推，最后一趟是N-1次
 * 2.因此复制次数最多是1 + 2+ 3 + ..+.N.1 = N* (N-1)/ 2.
 * 3.平均次数N * (N- 1)/4.
 *
 * 对于基本有序的情况
 * 1.对于已经有序或基本有序的数据来说，插入排序要好很多.
 * 2.当数据有序的时候，while循环的条件总是为假所以它变成了外层循环中的一个简单语句，执行N-1次
 * 3.在这种情况下，算法运行至需要N(N)的时间，效率相对来说会更高，
 * 4.另外别忘了，我们的比较次数是选择排序的一半，所以这个算法的效率是高于选择排序的.
 *
 * 希尔排序的历史
 * 希尔排序是插入排序的一种高效的改进版，并且效率比插入排序要更快.
 * 希尔排序的历史背景:
 * 希尔排序按其设计者希尔( Donald Shell )的名字命名,该算法由1959年公布。
 * 我们知道，优秀的排序算法首要条件就是速度，
 * 在简单排序出现后的很多一段时间内， 人们发明了各种各样的算法.
 * 但是最终发现算法的时间复杂度都是O(N2),似乎没法超越了.
 * 此时，计算机学术界充斥着排序算法不可能突破O(N2)"的声音.
 * 就像之前普遍认为人类100米短跑不可能突破10秒大关一样.
 * 终于有一天，一位科学家发布超越了O(N2)的新排序算法(后来为了纪念这个里程碑，用Shell来命名了该算法).
 * 紧接着出现了好几种可以超越O(N2)的排序算法，我们后面讲的快速排序也是其中之一.
 *
 * 回顾插入排序:
 * 由于希尔排序基于插入排序所以有必须回顾下前面的插入排序.
 * 我们设想一下， 在插入排序执行到一半的时候，标记符左边这部分数据项都是排好序的， 而标记符右边的数据项是没有排序的.
 * 这个时候，取出指向的那个数据项，把它存储在一个临时变量中， 接着，从刚刚移除的位置左边第一个单元开始， 每次把
 * 有序的数据项向右移动一个单元，直到存储在临时变量中的数据项可以成功插入.
 * 插入排序的问题:
 * 假设一个很小的数据项在很靠近右端的位置上，这里本来应该是较大的数据项的位置.
 * 把这个小数据项移动到左边的正确位置，所有的中间数据项都必须向右移动一位.
 * 如果每个步骤对数据项都进行N次复制，平均下来是移动N/2, N个元素就是N*N/2 = N2/2.
 * 所以我们通常认为插入排序的效率是O(N2)
 * 如果有某种方式，不需要一个个移动所有中间的数据项， 就能把较小的数据项移动到左边，那么这个算法的执行效率就有很大的改进.
 *
 * 希尔排序的思路
 * 1.比如下面的数字，81, 94, 11, 96, 12, 35, 17, 95, 28, 58, 41, 75, 15.
 * 2.我们先让间隔为5,进行排序(35, 81), (94, 17)，(11, 95), (96, 28), (12, 58), (35, 41), (17, 75), (95, 15)
 * 3.排序后的新序列，-定可以让数字离自己的正确位置更近一步.
 * 4.我们再让间隔位3,进行排序. (35, 28, 75, 58, 95), (17,12, 15, 81), (11, 41, 96, 94)
 * 5.排序后的新序列，一定可以让数字离自己的正确位置又近了一步
 * 6.最后，我们让间隔为1,也就是正确的插入排序
 * 7.这个时候数字都离自己的位置更近，那么需要复制的次数一定会减少很多.
 *
 *
 * 增量的选择
 * 选择合适的增量:
 * 在希尔排序的原稿中，他建议的初始间距是N / 2,简单的把每趟排序分成两半.
 * 也就是说，对于N = 100的数组，增量间隔序列为: 50, 25, 12, 6, 3, 1.
 * 这个方法的好处是不需要在开始排序前为找合适的增量而进行任何的计算.
 *
 *
 * Hibbard增量序列
 * 增量的算法为2^k - 1.也就是为1 3 57..等等.
 * 这种增量的最坏复杂度为O(N^3/2),猜想的平均复杂度为O(N^ 5/4),目前尚未被证明.
 *
 * Sedgewick增量序列
 * {1,5, 19, 41, 109, .. },该序列中的项或者是94^j- 9*2^i + 1或者是4^i- 32^i+ 1
 * 这种增量的最坏复杂度为O(N^ 4/3),平均复杂度为O(N ^7/6),但是均未被证明.
 *
 *
 * 希尔排序的效率
 * 希尔排序的效率很增量是有关系的.
 * 但是，它的效率证明非常困难，甚至某些增量的效率到目前依然没有被证明出来.
 * 但是经过统计，希尔排序使用原始增量，最坏的情况下时间复杂度为O(N2),通常情况下都要好于O(N2)
 * 总之，我们使用希尔排序大多数情况下效率都高于简单排序
 * 这个可以通过统计排序算法的时间来证明.
 * 甚至在合适的增量和某些数量N的情况下，还好好于快速排序.
 *
 * 快速排序
 * 快速排序几乎可以说是目前所有排序算法中，最快的一种排序算法.
 * 当然没有任何一种算法是在任意情况下都是最优的
 * 比如希尔排序确实在某些情况下可能好于快速排序.
 * 但是大多数情况下，快速排序还是比较好的选择.
 *
 * 快速排序的重要性:
 * 如果有一天你面试的时候，让你写一 个排序算法
 * 你可以洋洋洒洒的写出多个排序算法，但是如果其中没有快速排序
 * 那么证明你对排序算法也只是浅尝辄止，并没有深入的研究过.
 * 因为快速排序可以说是排序算法中最常见的，无论是C+ +的STL中，还是Java的SDK中其实都能找到它的影子.
 * 快速排序也被列为20世纪十大算法之一.
 *
 *
 * 快速排序的思想
 * 希尔排序相当于插入排序的升级版，快速排序其实是我们学习过的最慢的冒泡排序的升级版
 * 我们知道冒泡排序需要经过很多次交换，才能在一次循环中， 将最大值放在正确的位置.
 * 而快速排序可以在一次循环中(其实是递归调用)， 找出某个元素的正确位置，并且该元素之后不需要任何移动
 *
 * 快速排序最重要的思想是分而治之.
 * 比如我们下面有这样一顿数字需要排序:
 * 第一步:从其中选出了65. (其实可以是选出任意的数字，我们以65举个栗子)
 * 第二步:我们通过算法:将所有小于65的数字放在65的左边，将所有大于65的数字放在65的右边
 * 第三步:递归的处理左边的数据.(比如你选择31来处理左侧)，递归的处理右边的数据.(比如选择75来处理右侧，当然选择81可能更合适)
 *
 * 和冒泡排序不同的是什么呢?
 * 我们选择的65可以次性将它放在最正确的位置，之后不需要任何移动.
 * 需要从开始位置两个两个比较，如果第一个就是最大值它需要一直向后移动， 直到走到最后.
 * 也就是即使已经找到了最大值也需要不断继续移动最大值.而插入排序对数字的定位是一次性的.
 *
 *
 * 选取枢纽
 * 在快速排序中有一个很重要的步骤就是选取枢纽(pivot也有人称为主元).
 * 如何选择才是最合适的枢纽呢?
 * 种方案是直接选择第一个元素作为枢纽.
 * 但第一个作为枢纽在某些情况下，效率并不是特别高.
 * 另一种方案是使用随机数:
 * 随机取pivot ?但是随即函数本身就是个耗性能的操作.
 *
 * 选取枢纽(推荐)
 * 另一种比较优秀的解决方案:取头、中、尾的中位数
 * 例如8、12、3的中位数就是8
 *
 *
 * 快速排序的最坏情况效率
 * 什么情况下会有最坏的效率呢?就是每次选择的枢纽都是最左边或者最后边的.
 * 那么效率等同于冒泡排序
 * 而我们的例子可能有最坏的情况吗?是不可能的.因为我们是选择三个值的中位值.
 *
 * 快速排序的平均效率:
 * 快速排序的平均效率是O(N * logN).
 * 虽然其他某些算法的效率也可以达到O(N *logN),但是快速排序是最好的.
 */

/**
 * 具备各种排序算法的列表类
 */

class ArrayList {
  array = [];

  /**
   * 将数据插入到数组中的方法
   * @param {any} item 要插入到数组的数据
   */
  insert(item) {
    this.array.push(item);
  }

  /**
   * toString方法
   */
  toString() {
    return this.array.join('-');
  }

  /**
   * 交换数组中两个元素的值
   */
  swap(n, m) {
    let temp = this.array[n];
    this.array[n] = this.array[m];
    this.array[m] = temp;
  }

  /**
   * 冒泡排序算法
   */
  bubblesort() {
    // 1.获取数组的长度
    let length = this.array.length;
    for (let j = length - 1; j >= 0; j--) {
      for (let i = 0; i < j; i++) {
        if (this.array[i] > this.array[i + 1]) {
          this.swap(i, i + 1);
        }
      }
    }
  }

  /**
   * 选择排序
   */
  selectionSort() {
    // 1.获取数组的长度
    let length = this.array.length;

    // 2.外层循环 从 0 的位置开始取数据
    for (let j = 0; j < length - 1; j++) {
      // 内层循环 从i+1的位置开始 和后面的数据进行比较
      let min = j;
      for (let i = min + 1; i < length; i++) {
        if (this.array[min] > this.array[i]) {
          min = i;
        }
      }
      this.swap(min, j);
    }
  }

  /**
   * 插入排序
   */
  insertionSort() {
    // 1.获取数组的长度
    let length = this.array.length;

    // 2.外层循环 从第1个位置开始获取数据 向前面局部有序进行插入
    for (let i = 1; i < length; i++) {
      // 3.内层循环 获取i位置的元素 和前面的数据依次进行比较
      let temp = this.array[i];
      let j = i;
      while (this.array[j - 1] > temp && j > 0) {
        this.array[j] = this.array[j - 1];
        j--;
      }
      // 4.将j位置的数据 放置temp就可以了(注意此时的j可能已经被减过了)
      this.array[j] = temp;
    }
  }

  /**
   * 希尔排序
   */
  shellSort() {
    // 1.获取数组的长度
    let length = this.array.length;

    // 2.初始化增量
    let gap = Math.floor(length / 2);

    // 3.while循环(grp不断减小)
    while (gap >= 1) {
      // 4.以gap为间隔 进行分组 对分组进行插入排序
      for (let i = gap; i < length; i++) {
        let temp = this.array[i];
        let j = i;

        while (this.array[j - gap] > temp && j > gap - 1) {
          this.array[j] = this.array[j - gap];
          j -= gap;
        }
        // 将j位置的元素赋值temp
        this.array[j] = temp;
      }
      gap = Math.floor(gap / 2);
    }
  }

  // 快速排序
  /**
   * 选择枢纽
   * @param left 左边的索引
   * @param right 右边的索引
   */

  median(left, right) {
    // 1. 取出中间的位置
    let center = Math.floor((left + right) / 2);

    // 2.判断大小并进行交换 66  76  6
    console.log('001', this.array[left], this.array[center], this.array[right]);
    if (this.array[left] > this.array[center]) {
      this.swap(left, center); // 66 76 6
    }

    if (this.array[left] > this.array[right]) {
      this.swap(left, right); // 6 76 66
    }

    if (this.array[center] > this.array[right]) {
      this.swap(center, right); // 6 66 76
    }

    console.log('002', this.array[left], this.array[center], this.array[right]);

    // 3.将center换到right -1 的位置
    this.swap(center, right - 1);

    console.log('this.array', this.array);
    return this.array[right - 1];
  }

  /**
   * 快速排序
   */
  quickSort() {
    this.quick(0, this.array.length - 1);
  }

  /**
   * 快速排序的递归方法
   * @param left 左边的索引
   * @param right 右边的索引
   */
  quick(left, right) {
    // 1.结束条件
    if (left >= right) return;

    // 获取枢纽
    let pivot = this.median(left, right);
    // 定义变量用于记录当前查找的位置
    let i = left;
    let j = right - 1;

    // 开始进行交换
    while (true) {
      while (this.array[++i] < pivot) {}
      while (this.array[--j] > pivot) {}

      if (i < j) {
        this.swap(i, j);
      } else {
        break;
      }
    }

    // 6.将枢纽放置在正确的位置 i的位置
    this.swap(i, right - 1);

    // 1. 分而治之
    this.quick(left, i - 1);
    this.quick(i + 1, right);
  }
}

let list = new ArrayList();

list.insert(66);
list.insert(16);
list.insert(76);
list.insert(6);
list.insert(9);
list.insert(6);

console.log(list, list.toString());

// list.bubblesort();

// list.selectionSort();
// list.insertionSort();

// list.shellSort();

list.quickSort();
console.log(list.toString());
```

## 参考资源

```js
// https://leetcode.cn/
// https://leetcode.wang/
// https://github.com/wind-liang/leetcode
```

- 单词

```pug
algorithm 算法
priority 优先级
tail 尾部 跟踪
constant 常数
bucket 水桶
prime 质数 主要的
binary 二进制数;双子星
traverse 横过;横越;穿过;横渡 导线
vertex 定点
edge 边缘
graph 图表
breadth 广泛 宽度
depth 深度
bubble 气泡
swap 交换
pivot 支点;枢轴
```
