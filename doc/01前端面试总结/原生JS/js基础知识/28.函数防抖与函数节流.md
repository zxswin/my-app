# 函数防抖与函数节流

- 函数防抖

```ts
// 1.对于在事件被触发n秒后再执行的回调 -> 延迟执行
// 2.如果在这n秒内再触发事件,则重新开始计时
// 3.多用于ajax请求数据 提交数据 输入验证

let test = function () {
  console.log(1);
};

let debouncefn = debounce(test, 1000, true);

document.body.addEventListener('mouseover', debouncefn);

/**
 * 防抖函数封装
 * @param fn 回到函数
 * @param time 延迟时间
 * @param triggleNew 是否立即执行
 */
function debounce(fn, time, triggleNew) {
  let t = null; // 定时器
  let res; // 函数返回值

  let debounced = function () {
    let _self = this; // 保存this指向
    let args = arguments;

    if (t) {
      clearTimeout(t); // 清除定时器
    }

    if (triggleNew) {
      // 函数触发的时候要立即执行
      let exec = !t; // 是否立即执行标记

      t = setTimeout(() => {
        t = null;
      }, time);

      if (exec) {
        res = fn.apply(_self, args);
      }
    } else {
      // 函数触发后不立即执行
      t = setTimeout(() => {
        res = fn.apply(_self, args);
      }, time);
    }

    return res;
  };

  // 强制清除方法
  debounced.remove = function () {
    clearTimeout(t);
    t = null;
  };

  return debounced;
}
```

- 函数节流

```ts
/**
 * 函数节流：事件被触发,n秒之内只执行一次事件处理函数
 */
let oInput = document.querySelector('input');

oInput.onkeyup = throttle(check, 1000);

function check() {
  let val = this.value;

  if (val.length < 6) {
    console.log('Invalid length');
  } else {
    console.log('success');
  }
}

function throttle(fn, delay) {
  let t = null;
  let begin = new Date().getTime();

  return function () {
    let _self = this;
    let args = arguments;
    let cur = new Date().getTime();

    clearTimeout(t);

    if (cur - begin >= delay) {
      fn.apply(_self, args);
      begin = cur;
    } else {
      t = setTimeout(function () {
        fn.apply(_self, args);
      }, delay);
    }
  };
}
```

- 截流函数修正后版本

```ts
let oInput = document.querySelector('input');

oInput.onkeyup = throttle(check, 1000);

function check() {
  let val = this.value;
  console.log('val', val);
}

function throttle(fn, delay) {
  let t = null;

  return function () {
    let _self = this;
    let args = arguments;

    if (!t) {
      t = setTimeout(function () {
        fn.apply(_self, args);
        clearTimeout(t);
        t = null;
      }, delay);
    }
  };
}
```
