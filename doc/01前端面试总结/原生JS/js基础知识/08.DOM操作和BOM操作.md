## 08.DOM 操作.md

- 什么是 DOM

```ts
/**
 * DOM document object model 文档对象模型
 */
```

- 文档渲染与整理

```ts
/**
 * 当DOM结构写得不规范的时候
 * 浏览器在渲染的时候会自动把不规范的代码整理并转换为规范的代码
 */
```

- 解析顺序与技巧

```ts
/**
 * 浏览器会从上到下解析dom
 * 通过脚本获取dom节点对象必须要等到dom节点渲染完成才能获取到
 */
```

- 节点对象与原型链

```ts
/**
 * 节点类型-有12种节点类型
 * 属性也是一种节点
 * 注释也是一种节点
 */
console.log(document.nodeType); // 9 文档类型
console.log(document.body.nodeType); // 1 标签的节点类型
console.log(document.body.attributes[0].nodeType); // 2 属性的节点类型
console.log(document.body.childNodes[0].nodeType); // 3 文本节点类型
console.log(document.body.childNodes[1].nodeType); // 8 注释节点类型

/**  获取dom继承链哪些原型链  */
function prototype(el) {
  let p = Object.getPrototypeOf(el);

  console.log(p);

  Object.getPrototypeOf(p) ? prototype(p) : '';
}

/**
 * getElementById 是document下面的方法不是原型链上面的方法
 */
let hd = document.getElementById('hd');
prototype(hd);
```

- DOM 对象特征

```ts
/**
 * dom也是对象所以它下面可以绑定属性和方法
 */

let hd = document.getElementById('hd');

hd.name = 'abcd';

hd.show = function () {
  console.log(this.name);
};

hd.show();

/**
 * 通过属性覆盖来操作dom
 */
let hd = document.getElementById('hd');

Object.assign(hd, {
  innerHTML: 'abcd',
  color: 'red',
  change() {
    this.innerHTML = '改变内容';
    this.style.color = this.color;
  },
  onclick() {
    this.change();
  },
});
```

- nodeType 属性说明

```ts
console.log(document.nodeType); // 9 文档类型
console.log(document.body.nodeType); // 1 标签的节点类型
console.log(document.body.attributes[0].nodeType); // 2 属性的节点类型
console.log(document.body.childNodes[0].nodeType); // 3 文本节点类型
console.log(document.body.childNodes[1].nodeType); // 8 注释节点类型

let hd = document.getElementById('hd');

console.log(hd instanceof HTMLDivElement); // true
console.log(hd instanceof Element); // true
```

- 多层标签获取

```ts
let hd = document.getElementById('hd');

function all(el) {
  const items = [];
  [...el.childNodes].map((node) => {
    if (node.nodeType === 1) {
      items.push(node, ...all(node));
    }
  });

  return items;
}

const nodes = all(hd);
console.log(nodes);
```

## DOM 常用的 api

- getElementById 通过 id 获取元素

```ts
// 返回一个元素对象 如果找不到则返回null
let hd = document.getElementById('hd');
console.log(hd);
console.log(typeof hd);
console.dir(hd);
```

- getElementsByTagName 通过标签名获取元素

```ts
// 返回的是获取过来的元素对象集合 以伪数组的形式存储的
// 如果页面中没有这个元素 则返回的是空的伪数组的形式
let hd = document.getElementsByTagName('div');
```

- getElementsByClassName 通过类名获取元素

```ts
// 根据类名获取到某些元素的集合 如果找不到则返回一个空的伪数组
let hd = document.getElementsByClassName('hd');
console.log(hd);
```

- querySelector 通过指定选择器获取元素

```ts
// 返回指定选择器的第一个元素 如果没有找到则返回null
let hd = document.querySelector('.hd');
console.log(hd);
```

- querySelectorAll 返回指定选择器的所有对象集合

```ts
// 返回指定选择器的所以对象集合 如果没有找到则会返回一个空数组
let hd = document.querySelectorAll('.hd');
console.log(hd);
```

- 特殊元素的获取方法

```ts
// 1.获取body元素
let bodyEle = document.body;
console.log(bodyEle);

// 2.获取html元素
let htmlEle = document.documentElement;
console.log(htmlEle);
```

- 给元素添加事件

```ts
let btn = document.querySelector('.btn');

btn.onclick = () => {
  console.log('按钮被点击了');
};
```

- 操作元素 修改元素内容

```ts
let btn = document.querySelector('.btn');
// 修改元素的内容
// innerHTML能识别html标签 W3C标准 保留空格和换行
btn.innerHTML = '<strong>aaa</strong>';
// innerText不能识别html标签 非标准 去除空格和换行
btn.innerText = '<strong>aaa</strong>';

// 这两个属性都是可读的 可以获取元素里面的内容
console.log(btn.innerHTML);
console.log(btn.innerText);
```

- 常用的元素属性操作

```ts
let img = document.querySelector('.img');
// 修改元素的属性
img.src = 'abc.png';
img.title = '图片的标题';
img.alt = '图片的描述';
```

- 表单元素的属性操作

```ts
/**
 * 利用DOM可以操作如下表单的属性
 * type,value,checked,selected,disabled
 */

let input = document.querySelector('input');
input.type = 'text';
input.type = 'password';
```

- 样式属性的操作

```ts
// 可以通过JS来改变元素的大小,颜色,位置等样式
let img = document.querySelector('.img');
img.className = 'newclass'; // 改变类名
img.style.border = '1px solid'; // 改变行内样式
img.style.borderColor = 'red';
```

- 常用事件

```ts
// 获取焦点onfocus 失去焦点onblur
// 鼠标经过onmouseover 鼠标离开onmouseout
```

- 获取自定义属性的操作

```ts
let img = document.querySelector('.img');
// 1.通过element.属性获取 主要用于获取元素自带属性
console.log(img.className);
console.log(img['data-index']); // undefined 获取不到自定义属性
// 2.通过element.getAttribute('属性') 获取 可以获取自定义属性 和元素自带属性
console.log(img.getAttribute('data-index'));
```

- 设置及删除属性值

```ts
let img = document.querySelector('.img');

// 1.element.属性 = ‘值’ 用于设置自带的属性值
img.id = 'img1';

// 2.element.setAttribute('属性','值') 可以设置自带的属性值和自定义属性值
img.setAttribute('class', 'class1');

// 3.移除属性值
img.removeAttribute('class');
```

- 获取 H5 自定义属性

```ts
let img = document.querySelector('.img');
// 获取H5的自定义属性
console.log(img.dataset.index);
console.log(img.dataset['index']);
```

- 获取父节点

```ts
let img = document.querySelector('.img');
// 得到的是离元素最近的父节点 如果找不到父节点则返回null
console.log(img.parentNode);
```

- 获取子节点

```ts
let ul = document.querySelector('.ul');
// 1.子节点 childNodes 所有的子节点 包含 元素节点 文本节点等等
console.log(ul.childNodes);
// 2.返回所有子元素节点的集合 parentNode.children(非标准) 但各大浏览器都支持可以放心使用
console.log(ul.children);
```

- 获取第一个子节点和最后一个子节点

```ts
let ul = document.querySelector('.ul');
// 1.firstChild 第一个子节点 不管是文本节点还是元素节点
console.log(ul.firstChild);
console.log(ul.lastChild);
// 2.firstElementChild 返回第一个子元素节点
console.log(ul.firstElementChild);
console.log(ul.lastElementChild);
```

- 获取兄弟元素的节点

```ts
let ul = document.querySelector('.ul');
// 1.nextSibling 下一个兄弟节点 包含元素节点或文本节点等等
console.log(ul.nextSibling);
console.log(ul.previousSibling);

// 2.nextElementSibling 得到下一个兄弟元素的节点
console.log(ul.nextElementSibling);
console.log(ul.previousElementSibling);
```

- 创建节点

```ts
let ul = document.querySelector('.ul');

// 1.创建节点元素节点
let li1 = document.createElement('li');
// 2.添加节点 node.appendChild(child) node 父级 child 子级 后面追加元素类似与数组的push
ul.appendChild(li1);
let li2 = document.createElement('li');
// 3.添加节点 node.insertBefore(child,指定元素)
ul.insertBefore(li2, ul.children[1]);
```

- 删除节点

```ts
let ul = document.querySelector('.ul');
// 删除元素 node.removeChild(child)
ul.removeChild(ul.children[0]);
```

- 复制节点

```ts
let ul = document.querySelector('.ul');
// 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容
// 2. node.cloneNode(true); 括号为true 深拷贝 复制标签同时复制里面的内容
let li1 = ul.children[0].cloneNode();
let li2 = ul.children[0].cloneNode(true);

ul.appendChild(li1);
ul.appendChild(li2);
```

- document.write 创建元素

```ts
// document.write是直接将内容写入页面的内容流 但是文档流执行完毕 它会导致整格页面全部重新绘制
```

- innerHTML 和 createElement 效率对比

```ts
/**
 * innerHTML 创建多个元素效率更高(不要拼接字符串,采取数组形式拼接),结构稍微复杂
 * createElement 创建多个元素效率稍微低一点点,但是结构更加清晰
 */
```

## 事件高级

- 注册事件的两种方式

```ts
/**
 * 传统注册方式
 * 以on开头的事件onclick
 * 特点
 * 注册事件的唯一性
 * 同一个元素同一个事件只能设置一个处理函数
 * 最后注册的处理函数将会覆盖前面注册的处理函数
 */
btns = document.querySelectorAll('button');
btns[0].onclick = function () {
  console.log('hi');
};
/**
 * 方法监听注册方式
 * w3c标准推荐方式
 * addEventListener() 它是一个方法
 * 特点；
 * 同一个元素同一个事件可以注册多个监听器
 */
btns = document.querySelectorAll('button');
btns[0].addEventListener('click', function () {
  console.log('1');
});

btns[0].addEventListener('click', function () {
  console.log('2');
});
```

- 删除事件

```ts
/**
 * 传统方式的解绑事件
 */
let ul = document.querySelector('.ul');

ul.onclick = function () {
  console.log('1');
  // 传统方式的解绑事件
  ul.onclick = null;
};

/**
 * removeEventListener 解绑事件
 */
let ul = document.querySelector('.ul');

ul.addEventListener('click', fn);

function fn() {
  console.log('1');
  ul.removeEventListener('click', fn);
}
```

- DOM 事件流理论

```ts
/**
 * 事件流就是事件传播的过程
 * 捕获阶段 -> 当前目标阶段 ->冒泡阶段
 *
 * js代码只能执行捕获或者冒泡其中的一个阶段
 * onclick 和attachEvent只能得到冒泡阶段
 *
 * addEventListener(type,listener[,useCapture]);
 * 第三个参数如果是true 表示在事件捕获阶段调用事件处理程序
 * 如果是false(不写默认为false),表示在事件冒泡阶段调用事件处理程序
 *
 * 有些事件是没有冒泡的
 * onblur,onfocus,onmouseenter,onmouseleave
 */

// 捕获阶段代码实例
let son = document.querySelector('.son');
let father = document.querySelector('.father');

son.addEventListener(
  'click',
  function () {
    console.log('点击了son');
  },
  true
);

father.addEventListener(
  'click',
  function () {
    console.log('点击了father 在捕获阶段先执行');
  },
  true
);
```

- 什么是事件对象

```ts
div.onclick = function (event) {
  // 1.event 就是一个事件对象
  // 2.事件对象只有有了事件才会存在,它是系统给我们自动创建的 不需要我们传递参数
  // 3.事件对象是我们事件一系列相关数据的集合跟事件相关 例如鼠标坐标 键盘按下信息等
  // 4.这个事件对象我们可以自己命名 例如event,evt,e
  // 5.事件对象也有兼容性问题 ie678通过window.event兼容性的写法 e = e || window.event
};
```

- 常见的事件对象的属性和方法

```ts
/**
 * 1.e.target 返回的是触发事件的对象(元素)
 * this返回的是绑定事件的对象(元素)
 */
let ul = document.querySelector('ul');

ul.addEventListener('click', (e) => {
  // 我们给ul绑定了事件 那么this就指向ul
  console.log(ul);
  // e.target 指向的是我们点击的那个对象
  console.log(e.target);

  /**
   * 2.了解跟this有非常相似的属性currentTargtet 当前事件是绑定在那个元素上面的
   */
  console.log(e.currentTarget);
});
```

- 阻止默认行为

```ts
/**
 * e.type 返回事件的类型 例如click 不带on
 */

// 阻止默认行为(事件) 让链接不跳转 或者让提交按钮不提交
let a = document.querySelector('a');
a.addEventListener('click', (e) => {
  e.preventDefault(); // 阻止默认事件dom的标准写法
});

a.onclick = (e) => {
  // 低版本浏览器ie678
  e.returnValue;
  // 我们可以利用return false 也能阻止默认行为 仅限与传统的注册方式
  return false;
};
```

- 阻止事件冒泡

```ts
/**
 * 阻止事件冒泡 标准
 * e.stopPropagation()
 */
let a = document.querySelector('a');
a.addEventListener('click', (e) => {
  e.stopPropagation();
});
```

- 事件委托(代理,委派)

```ts
/**
 * 事件委托的原理
 * 不是每个子节点单独设置事件监听器,而是事件监听器设置在其父节点上
 * 然后利用冒泡原理影响每一个子节点
 * 提高了程序性能
 */
let ul = document.querySelector('ul');
ul.addEventListener('click', (e) => {
  e.target.style.backgroundColor = 'pink';
});
```

- 禁止选中文字和禁止右键菜单

```ts
// 阻止右键菜单的弹出
document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
});

// 禁止选中文字
document.addEventListener('selectstart', (e) => {
  e.preventDefault();
});
```

- 鼠标事件对象

```ts
/**
 * 1.e.clientX 返回鼠标相对应浏览器窗口可视区的X坐标
 * 2.e.clientY 返回鼠标相对应浏览器窗口可视区的Y坐标
 * 3.e.pageX 返回鼠标相当与文档页面的X坐标
 * 4.e.pageY 返回鼠标相当与文档页面的Y坐标
 * 5.e.screenX 返回鼠标相对与电脑屏幕的X坐标
 * 6.e.screenY 返回鼠标相对与电脑屏幕的Y坐标
 */
```

- 常用的键盘事件

```ts
/**
 * onkeyup 某个键盘按键被松开的时候触发
 * onkeydown 某个键盘键被按下的时候触发
 * onkeypress 某个键盘按键被按下的时候触发 但是它不识别功能键 例如 ctrl shift 箭头等
 *
 * 三个事件的执行顺序
 * keydown -- keypress -- keyup
 *
 * keydown 和keypress在文本框里面的特点:他们两个事件触发的时候,文字还没有落入文本框中
 */

// 键盘事件对象中的keyCode属性可以得到对应键的ASCII码值
document.addEventListener('keyup', (e) => {
  console.log(e);
});
// keypress 事件是区分字母大小写的
document.addEventListener('keypress', (e) => {
  console.log(e);
});
```

## BOM 浏览器对象模型

- BOM 的基本概念

```ts
/**
 * BOM即浏览器对象模型 它提供了独立与内容和与浏览器窗口进行交互的对象
 * 其核心的对象是window
 * DOM是W3C标准规范
 * BOM缺乏标准
 * BOM比DOM更大 它包含DOM
 *
 * window下的一个特殊属性window.name
 */
```

- window 常见事件

```ts
/**
 * 1.window.onload是窗口(页面)加载事件,当文档内容完全加载完成会触发该事件
 * 包括图像,脚本文件,CSS文件等
 */
window.onload = () => {
  console.log('页面加载完毕了...');
};

/**
 * 2.DOMContentLoaded 事件触发时 仅当DOM加载完成 不包括样式表 图片 flash等待
 */
window.addEventListener('DOMContentLoaded', () => {
  console.log('DOM加载完毕');
});

/**
 * 3.调整窗口大小事件
 * window.onresize是调整窗口大小加载事件
 * 只要窗口大小发生像素变化就会触发这个事件
 * window.innerWidth当前屏幕的宽度
 */
window.onresize = () => {
  console.log('窗口发生调整了');
};

/**
 * 4.定时器之setTimeout
 * setTimeout() 方法用于设置一个定时器 该定时器在定时器到期后执行调用函数
 * 这个调用函数可以直接写函数,或者写函数名或者采取字符串'函数名()'三种形式 第三种不推荐
 * 延迟的毫秒数省略默认是0 如果写 必须是毫秒
 * 经常会给定时器赋予一个标识符
 *
 * 停止setTimeout()定时器
 * window.clearTimeout(timeoutID)
 *
 */
let timer = setTimeout(() => {
  console.log('定时器执行了');
  clearTimeout(timer); // 停止定时器
}, 10);

/**
 * 5.setInterval() 方法重复调用一个函数 每隔这个事件 就去调用一次回调函数
 */
let timer = setInterval(() => {
  console.log('定时器执行了');
  clearInterval(timer);
}, 10);

/**
 * this指向的问题
 * this的指向在函数定义的时候是确定不了的 只有函数指向的时候才能确定this到底指向谁
 * 一般情况下this最终指向的是调用它的对象
 *
 * 全局作用域或者普通函数中的this指向全局对象window(注意定时器里面的this指向window)
 */
```

- js 执行队列(同步和异步)

```ts
/**
 * 利用多核cpu的计算能力 HTML5提出web Worker标准 允许js脚本创建多个线程
 */

/**
 * 同步任务
 * 同步任务都是在主线程上执行 形成一个执行栈
 *
 * 异步任务
 * JS的异步是通过回调函数实现的
 * 一般来说异步任务有以下三种类型
 *
 * 1.普通事件 如click resize等
 * 2.资源的加载 如load error等
 * 3.定时器 包括setInterval setTimeout等
 * 异步任务相关回调函数添加到任务队列中(任务队列也称之为消息队列)
 *
 *
 * 注意：
 * 1.点击事件只有在被点击的情况下才会被提交给对应的异步进程进行处理->加入到任务队列中等待被执行
 * 2.定时器里面的回调函数也是要等到时间到了才会被提交给对应的异步进程进行处理->加入到任务队列中等待被执行
 */

/**
 * JS的执行机制
 * 1.先执行执行栈中的同步任务
 * 2.异步任务(回调函数)放入任务队列中
 * 3.一旦执行栈中的同步任务都执行完毕,系统就回按次序读取任务队列中的异步任务
 * 于是被读取的异步任务结束等待状态 进入执行栈 开始执行
 *
 *
 * 事件循环(eventloop)
 * 由于主线程不断的重复获取任务->执行任务->在执行,所以这种机制被称为事件循环(eventloop)
 */
```

- location 对象

```ts
/**
 * window对象给我们提供了一个location属性用于获取或设置窗体的url,并且可以用于解析URL
 *
 * url
 * 统一资源定位符是互联网上的标准资源地址
 * 互联网上每一个文件都有一个唯一的URL 它包含的信息指出了文件的位置以及浏览器应该怎么处理它
 *
 * location对象的属性
 * 1.location.href  获取或设置整个url
 * 2.location.host  返回主机(域名)
 * 3.location.port  返回端口号 如没写返回空字符串
 * 4.location.pathname 返回路径
 * 5.location.search 返回参数
 * 6.location.hash 返回片段 #后面的内容常见于链接 锚点
 */
console.log(location.href);
console.log(location.host);
console.log(location.port);
console.log(location.pathname);
console.log(location.search);
console.log(location.hash);

// 实现页面跳转
location.href = 'http://www.itcast.cn';

/**
 * location对象的方法
 * 1.location.assign() 跟href一样 可以跳转页面(也称为重定向页面)
 * 2.location.replace() 替换当前页面 因为不记录历史 所以不能后退页面
 * 3.location.reload() 重新加载页面 相当于刷新按钮或f5 如果参数为true则是强制刷新ctrl + f5
 */
```

- navigator 对象

```ts
/**
 * navigator 对象包含有关浏览器的信息
 * 它有很多属性 比较常用的是userAgent 该属性可以返回由客户机发送服务器的user-agent头部的值
 *
 * 用于判断用户是那个终端打开的页面实现跳转
 */
```

- history 对象

```ts
/**
 * history 对象包含用户(在浏览器窗口中)访问过的url
 * 1.back() 可以后退的功能
 * 2.forward() 前进功能
 * 3.go(参数) 前进后退功能 参数如果是1前进1个页面 如果是-1后退一个页面
 */
```

## PC 端常见的页面特效

- 元素偏移量 offset 系列

```ts
/**
 * 可以动态得到该元素的位置(偏移),大小等
 * 返回的数值是不带单位的
 *
 * 1.element.offsetParent 返回作为该元素带定位的父级元素 如果父级都没有定位则返回body
 * 2.element.offsetTop 返回元素相对带有定位父元素上方的偏移量
 * 3.element.offsetLeft 返回元素相对带有定位父元素左边框的偏移量
 * 4.element.offsetWidth 返回自身包括padding 边框 内容区的宽度 返回的数值不带单位
 * 5.element.offsetHeight 返回自身包括padding 边框 内容区的高度 返回数值不带单位
 *
 *
 * offset可以得到任意样式表中的样式值
 * offset系列获得的数值是没有单位的
 * offsetWidth包含padding + border + width
 * offsetWidth等属性是只读的 只能获取不能赋值
 */

/** 拖动效果的基本实现原理  */
let title = document.querySelector('.title');
let login = document.querySelector('.login');

// 当鼠标按下的时候
title.addEventListener('mousedown', function (e) {
  let x = e.pageX - login.offsetLeft;
  let y = e.pageY - login.offsetTop;

  // 当鼠标移动的时候
  document.addEventListener('mousemove', move);

  function move(e) {
    login.style.left = e.pageX - x + 'px';
    login.style.top = e.pageY - y + 'px';
  }

  // 当鼠标弹起的时候
  document.addEventListener('mouseup', function () {
    document.removeEventListener('mousemove', move);
  });
});
```

- 元素的可视区 client 系列

```ts
/**
 * 通过client系列的相关属性可以动态得到该元素的边框大小,元素大小等
 *
 * 1.element.clientTop 返回元素上边框的大小
 * 2.element.clientLeft 返回元素左边框的大小
 * 3.element.clientWidth 返回自身包括padding 内容区宽度 不包含边框 返回数值不带单位
 * 4.element.clientHeight 返回自身包含padding 内容区的高度 不含边框 返回数值不带单位
 *
 */

// 获取浏览器的物理像素比
window.devicePixelRatio;

/**
 * 能触发页面刷新的事件
 * 1.a标签的超链接
 * 2.F5或者刷新按钮(强制刷新)
 * 3.前进后退按钮
 *
 * 火狐浏览器中点击前进和后退按钮是不会刷新页面的
 * 因为它有一个往返缓存会把整个页面保存在内存中
 *
 * 4.使用pageshows事件来触发
 * 这个事件会在页面显示的时候触发,无论页面是否来自缓存
 * 在更新加载页面中,pageshow会在load事件触发后触发
 * 这个事件是给window添加的
 * 根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件
 */
```

- 元素滚动 scroll 系列

```ts
/**
 * 动态获取到该元素的大小,滚动距离等
 * 1.element.scrollTop 返回被卷去的上侧距离 返回的数值不带单位
 * 2.element.scrollLeft 返回被卷去的左侧距离 返回数值不带单位
 * 3.element.scrollWidth 返回自身的实际的宽度 不含边框 返回的数值不带单位(包含内容溢出的部分,clientWidth是不包含的)
 * 4.element.scrollHeight 返回自身实际高度 不包含边框 返回的数值不带单位(包含内容溢出的部分,clientHeight是不包含的)
 *
 */

let div = document.querySelector('div');

console.log(div.scrollHeight);
console.log(div.clientHeight);

// scroll滚动事件当我们滚动条发生变化的时候会触发的事件
div.addEventListener('scroll', () => {
  console.log(div.scrollTop);
});

/**
 * window.pageYOffset 页面被卷去的头部
 *
 * 兼容性问题处理
 * 声明来DTD document.documentElement.scrollTop
 * 未声明DTD document.body.scrollTop
 * 新方法window.pageYoffset IE9开始支持
 */
function getScroll() {
  return {
    left:
      window.pageXOffset ||
      document.documentElement.scrollLeft ||
      document.body.scrollLeft ||
      0,
    top:
      window.pageYOffset ||
      document.documentElement.scrollTop ||
      document.body.scrollTop ||
      0,
  };
}
```

- 三大获取高度和宽度系列总结

```ts
/**
 * element.offsetWidth 返回自身包括padding 边框 内容区的宽度 返回的数值不带单位
 * element.clientWidth 返回自身包括padding 内容区的宽度 不包含边框 返回的数值不带单位
 * element.scrollWidth 返回自身实际的宽度 不包含边框 返回的数值不带单位
 *
 * 其他的主要用法
 * 1.offset系列经常用于获取元素的位置 offsetLeft offsetTop
 * 2.client经常用于获取元素的大小 clientWidth clientHeight
 * 3.scroll经常用于获取滚动距离 scrollTop scrollLeft
 * 4.注意页面滚动的距离通过window.pageXOffset获取
 *
 */
```

- mouseenter 和 mouseover 的区别

```ts
/**
 * mouseenter 和 mouseover 的区别
 * mouseover 鼠标经过自身盒子会触发 经过子盒子还是会触发
 * mouseenter 只有经过自身盒子才会触发
 * 子所以会这样是因为mouseenter不会冒泡
 */
```

- 动画函数的封装

```ts
/**
 * 核心原理:通过定时器setInterval()不停移动盒子的位置
 *
 * 缓动效果原理
 * 1.让盒子每次移动的距离慢慢变小 速度就会慢慢慢下了
 * 2.核心算法:(目标值-现在的位置)/10 作为每次移动的距离步长
 * 3.停止的条件是:让当前盒子的位置等于目标位置就停止定时器
 * 4.判断步长是正值还是负值
 *   如果是正值,则步长往大取整
 *   如果是负值 则步长往小的取整
 *
 */
```

- 网页轮播图

```ts
/**
 * 滚动图片的核心算法: 点击某个小圆圈的索引号乘以图片的宽度作为ul移动距离
 *
 * 图片无缝滚动的原理
 * 把ul第一个li复制一份 放到ul的最后面
 * 当图片滚动到克隆的最后一张图片的时候 让ul快速的 不做动画的跳到最左测left为0
 *
 * 节流阀以及逻辑中断运用
 * 核心实现思路:利用回调函数 添加一个变量来控制 锁住函数和解锁函数
 */
```

- 返回顶部

```ts
/**
 * 滚动窗口到文档中的特定位置
 */
window.scroll(x, y);
```

## 移动端网页特效

- 触屏事件

```ts
/**
 * 触屏事件touch(也称触摸事件)
 * 1.touchstart 手指触摸到一个DOM元素时触发
 * 2.touchmove 手指在一个DOM元素上滑动时触发
 * 3.touchend 手指从一个DOM元素上移开时触发
 *
 * 触摸事件对象(TouchEvent)
 * TouchEvent是一类描述手指在触摸平面的状态变化的事件
 * 用于描述一个或多个触点 使开发者可以检测到触点的移动 触点的增加和减少
 * touchstart touchmove touchend 三个事件都会有各自的事件对象
 *
 * 触摸事件对象重点看三个常用的对象列表:
 * 1.touches 正在触摸屏幕的所有手指的一个列表
 * 2.targetTouches 正在触摸当前DOM元素上的手指的一个列表
 * 3.changedTouches 手指状态发生来改变的列表 从无到有 从有到无变化
 *
 * 重点记住targetTouches
 */

let ul = document.querySelector('ul');
ul.addEventListener('touchend', (e) => {
  // 当我们手指离开屏幕的时候就没有来touches 和 targetTouches列表
  // 但是会有changedTouches
  console.log(e);
});

/**
 * 移动端拖动元素
 * touchstart touchmoove touchend可以实现拖动元素
 * 移动端拖动的原理
 * 手指移动中： 计算出手指移动的距离 然后用盒子原来的位置 + 手指移动的距离
 * 手指移动的距离： 手指滑动中的位置减去手指刚开始触摸的位置
 *
 * 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault()
 */
let ul = document.querySelector('ul');
let startX = 0; // 获取手指的初始坐标
let startY = 0;
let x = 0; // 获取盒子原来的位置
let y = 0;

ul.addEventListener('touchstart', (e) => {
  // 获取手指初始坐标
  startX = e.targetTouches[0].pageX;
  startY = e.targetTouches[0].pageY;
  x = ul.offsetLeft;
  y = ul.offsetTop;
});

ul.addEventListener('touchmove', (e) => {
  // 计算手指的移动距离 手指移动之后的坐标减去手指的初始坐标
  let moveX = e.targetTouches[0].pageX - startX;
  let moveY = e.targetTouches[0].pageY - startY;

  // 移动我们的盒子 盒子原来的位置 + 手指移动的距离
  ul.style.left = x + moveX + 'px';
  ul.style.top = y + moveY + 'px';
  // 阻止屏幕滚动的默认行为
  e.preventDefault();
});
```

- 移动端常见特效

```ts
/**
 * 移动端轮播图的制作
 * 使用translateX实现移动效果
 * 克隆第一张图片放在最后
 * 克隆最后一张图片放在最前
 * pc端要实现完美无缝滚动也是要如此
 */

// 等待过渡完成后再去判断监听过渡完成的事件 transitionend
ul.addEventListener('transitionend', function () {
  console.log('过渡效果完成了');
});

/**
 * classList类名操作
 */
let div = document.querySelector('div');
console.log(div.classList[1]); // 获取第一个类名
// 1.添加类名 是在后面追加类名不会覆盖以前的类名 注意前面的不需要加
div.classList.add('three');
// 2.删除类名
div.classList.remove('one');
// 3.切换类名
div.classList.toggle('bg');

/**
 * 移动端click点击事件300毫秒延迟解决方案
 * 原因是移动端屏幕双击会缩放页面
 *
 * 1.禁用缩放 浏览器禁用默认的双击缩放行为并且去掉300ms的点击延迟
 * <meta name="viewport" content="user-scalable= no">
 *
 * 2.利用touch事件自己封装这个事件解决300ms延迟
 * 原理:
 * 1.当我们的手指触摸屏幕 记录当前触摸时间
 * 2.当我们手指离开屏幕 用离开的事件减去触摸的事件
 * 3.如果事件小于150ms 并且没有滑动过屏幕 那么我们定义为点击
 */
```

- 移动端常用开发插件

```ts
/**
 * 1.fastclick插件解决300ms延迟问题
 *
 * 2.swiper滑动效果插件
 *
 * 3.移动端视频插件 zy.media.js
 *
 */
```

## 本地储存

- 本地储存

```ts
/**
 * 本地存储的特性
 * 1.数据存储在用户的浏览器中
 * 2.设置 读取方便 甚至页面刷新不丢失数据
 * 3.容量较大 sessionStorage 约5M localStorage约20M
 * 4.只能储存字符串 可以将对象JSON.stringify()编码后存储
 */

/**
 * window.sessionStorage
 * 1.生命周期为关闭浏览器窗口
 * 2.在同一个窗口(页面)下数据可以共享
 * 3.以键值对的形式存储使用
 * sessionStorage.setItem(key,value)
 */

// 存储数据
sessionStorage.setItem('key1', 'value1');
// 获取数据
console.log(sessionStorage.getItem('key1'));
// 删除数据
sessionStorage.removeItem('key1');
// 清除所以缓存数据
sessionStorage.clear();

/**
 * localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除
 */

// 保存数据语法：
localStorage.setItem('key', 'value');
// 读取数据语法
var lastname = localStorage.getItem('key');
// 删除数据语法
localStorage.removeItem('key');
// 移除所有
localStorage.clear();
```

- 单词

```pug
persisted 保存 坚持
```
