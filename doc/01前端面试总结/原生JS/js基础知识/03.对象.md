## 对象

- 对象的打开语法

```ts
let user = { name: 'abc', age: 22 };
let hd = { ...user, lang: 'zh' };

console.log(hd);
```

- 解构赋值新增特新

```ts
/* 基本用法 */
let user = { name: '后盾人', age: 18 };
let { name, age } = user;
console.log(age); // 18

/* 参数传递的时候也可以使用解构特性 */
function user({ name, age }) {
  console.log(name, age);
}

user({ name: '后盾人', age: 22 });
```

- 多层对象的解构操作

```ts
let hd = {
  name: 'abc',
  lesson: {
    title: 'js',
  },
};

let {
  name,
  lesson: { title },
} = hd;

console.log(name, title); // 只能获取到name 和title
```

- 解构默认值实现配置项合并

```ts
let user = { name: '后盾人', url: 'abc.com' };
let { url, name, title = 'hdcms' } = user;
console.log(url, name, title);
```

- 函数参数的解构特性使用技巧

```ts
// 如果变量名和对象的key值一致
function hd(name, { sex, age }) {
  console.log(name, sex, age);
}

hd('jun', { sex: '男', age: 18 });

// 如果变量名和对象的key值不一致
function hd(name, { sex: a, age: b }) {
  console.log(name, a, b);
}

hd('jun', { sex: '男', age: 18 });
```

- 对象属性的添加删除操作

```ts
let hd = {};
hd.name = '后盾人';
hd['age'] = 18;
console.log(hd);
delete hd.name;
console.log(hd);

console.log(hd.hasOwnProperty('age'));
```

- 对象与原型链属性检测实例

```ts
let arr = ['a', 'b'];

console.log(arr.hasOwnProperty('length')); // true
console.log(arr.hasOwnProperty('concat')); // false 不能检测到原型链上的属性

console.log('concat' in arr); // true in 语法可以检测到原型链上的属性

//  给对象设置原型
let a = {
  name: '后盾人',
};

let b = {
  url: 'houdunren.com',
};

Object.setPrototypeOf(a, b); // 给a对象设置原型
console.log(a);

console.log(a.hasOwnProperty('url')); // false
console.log('url' in a); // ture

function oss(options) {
  if (!options.hasOwnProperty('host')) {
    throw new Error('必须设置主机地址');
  }
}

oss({ user: 'admin' });
```

- 计算属性与 assign 的使用

```ts
function upload(params) {
  let options = {
    size: 999,
  };
  // object.assign()主要用于对象合并，将源对象中的属性复制到目标对象中，他将返回目标对象。
  options = Object.assign(options, params); // 对对象进行合并(浅拷贝)
  console.log(JSON.stringify(options, null, 2)); // 这样可以展开并打印出对象
}

upload({ size: 99, type: 'jpeg' });

// for of 是不可以迭代对象的

for (const [key, value] of Object.entries(hd)) {
  console.log(key, value);
}
```

- 对象浅拷贝的多种操作方法

```ts
let hd = { name: 'abc', age: 18 };
let obj = { ...hd }; // 使用对象扩展符进行拷贝

let obj = Object.assign({}, hd); // assign方法进行拷贝

// 遍历对象的方式进行拷贝
for (const key in hd) {
  obj[key] = hd[key];
}
```

- 深拷贝多层次分析

```ts
let data = {
  name: 'q',
  user: {
    age: 18,
  },
};
function copy(obj) {
  let res = obj instanceof Array ? [] : {};

  for (const [k, v] of Object.entries(obj)) {
    res[k] = typeof v === 'object' ? copy(v) : v;
  }

  return res;
}

let hd = copy(data);
hd.user.age = 22;

console.log(JSON.stringify(hd, null, 2));
console.log(JSON.stringify(data, null, 2));
```

- 使用工厂函数创建对象

```ts
// 创建一个工厂函数
function user(name, age) {
  return {
    name,
    age: age,
    show: function () {
      console.log(this.name + `-abc.com`);
    },
  };
}

let xj = user('向军', 18);
xj.show();
```

- 通过构造函数来创建对象的方式

```ts
function User(name) {
  this.name = name;
  this.show = function () {
    console.log(this.name);
  };
}

let xj = new User('abc');
xj.show();
```

- 面向对象的封装与抽象

```ts
function User(name, age) {
  // 外部不能直接访问到name和age
  let data = { name, age };
  // 外部不能直接访问到info
  let info = function () {
    return data.age > 50 ? '老年' : '青年';
  };
  this.show = function () {
    // 利用闭包的特性可以直接访问都外部的变量
    console.log(data.name + info());
  };
}

let xj = new User('abc');
xj.show();
```

- 什么是对象的属性特征

```ts
let user = {
  name: "abc",
  age: 18,
};

// 获取单个对象的属性特征
console.log(
  JSON.stringify(Object.getOwnPropertyDescriptor(user, "name"), null, 2)
);

// 会打印出如下内容
{
  "value": "abc", // 属性的名称
  "writable": true, // 是否可写
  "enumerable": true, // 是否可枚举
  "configurable": true // 是否可删除
}

// 获取多个对象的属性特征
console.log(
  JSON.stringify(Object.getOwnPropertyDescriptors(user), null, 2)
);
```

- 灵活控制属性的特征

```ts
let user = {
  name: 'abc',
  age: 18,
};

// 设置属性
Object.defineProperty(user, 'name', {
  value: '后盾人', // 设置属性的值
  writable: false, // 设置属性不可以被修改
  enumerable: false, // 设置属性不可以被遍历
  configurable: false, // 设置属性是否可以被删除
});

// 也可以批量对属性进行设置
Object.defineProperties(user, {
  name: {
    value: '后盾人', // 设置属性的值
    writable: false, // 设置属性不可以被修改
    enumerable: false, // 设置属性不可以被遍历
    configurable: false, // 设置属性是否可以被删除
  },
  age: {
    value: '后盾人', // 设置属性的值
    writable: false, // 设置属性不可以被修改
    enumerable: false, // 设置属性不可以被遍历
    configurable: false, // 设置属性是否可以被删除
  },
});

console.log(user);
delete user.name; // 属性不可以被删除
console.log(Object.keys(user));
```

- 不允许向对象中添加属性 API

```ts
let user = {
  name: 'abc',
  age: 18,
};

// 禁止向对象中添加属性
Object.preventExtensions(user);

// 判断对象中是否可以添加属性
if (Object.isExtensible(user)) {
  user.site = 'houdunren.com';
}

delete user.name; // 可以对对象的属性进行删除
console.log(user);
```

- 封闭对象的 API 操作

```ts
let user = {
  name: 'abc',
  age: 18,
};

// 对对象进行封闭
Object.seal(user);

// 判断对象是否处于封闭状态
// 如果处于封闭状态则不能进行添加和删除属性的操作
if (!Object.isSealed(user)) {
  user.site = 'abc.com';
  delete user.name;
}
console.log(user);
```

- 冻结对象 API 特性

```ts
let user = {
  name: 'abc',
  age: 18,
};

// 对对象进行冻结操作
Object.freeze(user);

// 判断对象是否处于冻结状态
// 如果处于冻结状态则不能对属性进行添加|修改|删除
// 但可以对属性进行遍历操作
if (Object.isFrozen(user)) {
  user.site = 'abc.com';
  delete user.name;
  user.name = 'abc';
}
```

- 使用访问器来保护数据

```ts
// 访问器的基本使用案例
let user = {
  data: { name: '后盾人', age: 10 },
  set age(value) {
    if (typeof value !== 'number') {
      throw new Error('年龄格式错误');
    }

    this.data.age = value;
  },
  get age() {
    return this.data.age;
  },
};

user.age = 99;
console.log(user.age);
```

- token 的读写处理

```ts
let Request = {
  set token(content) {
    localStorage.setItem('token', content);
  },

  get token() {
    let token = localStorage.getItem('token');

    if (!token) {
      console.log('请登录');
    }

    return token;
  },
};
Request.token = 'abcdefgaaa';
console.log(Request.token);
```

- 访问器的优先级

```ts
// 访问器的优先级高于普通的属性操作
```

- 构造函数与语法糖中使用访问器

```ts
// 在构造函数中使用访问器
function User(name, age) {
  let data = { name, age };

  Object.defineProperties(this, {
    name: {
      get() {
        return data.name;
      },
      set(value) {
        if (value.trim() === '' || value.length > 20) {
          throw new Error('用户名不合法');
        }
        data.name = value;
      },
    },
  });
}
let xj = new User('向军', 19);
xj.name = '后盾人';
console.log(xj);

// 在类中使用访问器
class User {
  DATA = Symbol();
  constructor(name, age) {
    this[this.DATA] = { name, age };
  }

  get name() {
    return this[this.DATA].name;
  }

  set name(value) {
    if (value.trim() === '' || value.length > 20) {
      throw new Error('用户名不合法');
    }
    this[this.DATA].name = value;
  }
}

let xj = new User('向军', 19);
xj.name = '后盾人';
console.log(xj);
```

- 什么是 proxy 代理拦截

```ts
/* 代理模式简单的写法 */
const hd = { name: '后盾人' };
const proxy = new Proxy(hd, {
  get(obj, property) {
    return obj[property];
  },

  set(obj, property, value) {
    obj[property] = value;
    return true;
  },
});

console.log(proxy.name); // 后盾人
proxy.name = 'abcd';
console.log(proxy.name); // abcd
console.log(proxy);
```

- 使用 Proxy 对函数进行控制

```ts
function factorial(num) {
  return num === 1 ? 1 : num * factorial(num - 1);
}

let proxy = new Proxy(factorial, {
  apply(func, obj, args) {
    console.log(func); // 代理的方法
    console.log(obj); // 外部调用传进来的第一个参数
    console.log(args); // 外部调用传递进来的第二个参数
    console.log(this);

    console.time('run');
    return func.apply(this, args);
    console.timeEnd('run');
  },
});

let result = proxy.apply({}, [5]);
console.log('result', result);
```

- 数组使用代理拦截操作

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>代码实例</title>
  </head>
  <body>
    <input type="text" v-model="title" />
    <input type="text" v-model="title" />
    <h4 v-bind="title">这里也会发生跟新</h4>
  </body>
  <script src="index.js"></script>
</html>
```

```ts
let lessons = [
  {
    title: 'mysql课程标题',
    price: 188,
  },
];

let proxy = new Proxy(lessons, {
  get(array, key) {
    const title = array[key].title;
    const len = 5;
    array[key].title =
      title.length > len ? title.substr(0, len) + '.'.repeat(3) : title;
    return array[key];
  },
});

console.log(JSON.stringify(proxy[0], null, 2));
```

- vuejs 数据绑定的容器更新原理

```ts
function View() {
  let proxy = new Proxy(
    {},
    {
      get(obj, property) {},
      set(obj, property, value) {
        console.log('设置的值', value);
        document.querySelectorAll(`[v-model="${property}"]`).forEach((item) => {
          item.value = value;
        });

        document.querySelectorAll(`[v-bind="${property}" ]`).forEach((item) => {
          item.innerHTML = value;
        });
      },
    }
  );

  this.init = function () {
    const els = document.querySelectorAll('[v-model]');
    els.forEach((item) => {
      item.addEventListener('keyup', function () {
        proxy[this.getAttribute('v-model')] = this.value;
      });
    });
  };
}

let view = new View();
view.init();
```

- 表单验证组件的代理工厂

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>代码实例</title>
    <style>
      .error {
        border: 5px solid #f00;
      }
    </style>
  </head>
  <body>
    <input type="text" validate rule="max:12,min:3" />
    <input type="text" validate rule="max:3,isNumber" />
  </body>
  <script src="index.js"></script>
</html>
```

```ts
// 创建一个验证类
class Validate {
  max(value, len) {
    return value.length <= len;
  }
  min(value, len) {
    return value.length >= len;
  }
  isNumber(value) {
    return /^\d+$/.test(value);
  }
}

let validate = new Validate();
console.log(validate.max('abc', 2));

// 创建一个代理工厂
function ProxyFactory(target) {
  return new Proxy(target, {
    get(target, key) {
      return target[key];
    },
    set(target, key, el) {
      const rule = el.getAttribute('rule');
      const validate = new Validate();
      let state = rule.split(',').every((rule) => {
        const info = rule.split(':');
        return validate[info[0]](el.value, info[1]);
      });

      el.classList[state ? 'remove' : 'add']('error');
      return true;
    },
  });
}

const validateDoms = document.querySelectorAll('[validate]');
const proxy = ProxyFactory(validateDoms);

proxy.forEach((item, i) => {
  item.addEventListener('keyup', function () {
    proxy[i] = this;
  });
});
```

- JSON 数据解决了什么问题

```ts
/**
 * JSON的键值是使用双引号进行包裹的
 */

let data = {
  name: '后盾人',
  data: {
    title: 'php',
  },
};

// 对象转JSON字符串
// 第二个参数表示要保留哪些字段['title','price'] ,null表示全部字段
// 第三个参数表示空格的间距大小
// 可以是数组或对象
let json = JSON.stringify(data, null, 2);
console.log(json);

// JSON字符串转对象
let obj = JSON.parse(json);
console.log(obj);
```

- JSON 序列化与自定义 toJSON

```ts
let data = {
  name: '后盾人',
  data: {
    title: 'php',
  },
  toJSON: function () {
    // 把JSON变为字符串称为JSON序列化
    // 自定义JSON序列化的返回数据
    return {
      name: this.name + 'abc',
    };
  },
};

let json = JSON.stringify(data, null, 2);
console.log(json);
// 打印出来的数据
// {
//   "name": "后盾人abc"
// }

// JSON.parse 可以传递第二个参数进行进一步处理
let obj = JSON.parse(json, (key, value) => {
  if (key === 'name') {
    value = '[www-]' + value;
  }
  return value;
});

console.log(obj);
```
