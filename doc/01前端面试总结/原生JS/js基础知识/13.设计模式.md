## 设计模式

- UML 类图

```ts

```

- SOLID 五大设计原则

```ts
/**
 * S 单一职责原则
 * ◆一个程序只做好一-件事
 * ◆如果功能过于复杂就拆分开,每个部分保持独立
 *
 * O 开闭原则
 * ◆对扩展开放,对修改封闭
 * ◆增加需求时,扩展新代码,而非修改已有代码
 *
 * L 里式替换原则
 * ◆子类能覆盖父类
 * ◆父类能出现的地方子类就能出现
 * ◆JS中使用较少(弱类型&继承使用较少)
 * 里式替换原则的目的就是要保证程序继承关系的正确性，所有⼦类的⾏为功能必须和使⽤者对其⽗类的期望保持⼀致，如果⼦类达不到这⼀点，那么必然违反⾥⽒替换原则。
 *
 * I 接口隔离原则
 * ◆保持接口的单-独立,避免出现“胖接口"
 * ◆JS中没有接口( typescript例外) ,使用较少
 * ◆类似于单一-职责原则,这里更关注接口
 * 接口的隔离原则主要功能就是控制粒度的大小，防止暴露给客户不相关的代码和方法，保证接口的内聚，低耦合。
 *
 * D 依赖倒置原则
 * ◆面向接口编程,依赖于抽象而不依赖于具体
 * ◆使用方只关注接口而不关注具体类的实现
 * ◆JS中使用较少(没有接口&弱类型)
 * 依赖倒置原则，可以减少类之间的耦合性，提高系统的稳定性。提高代码的可读性维护性。同时依赖倒置原则也是设计框架的核心思想。
 */
```

- 设计模式

```ts
/**
 * 创建型
 * ◆工厂模式(工厂方法模式,抽象工厂模式,建造者模式)
 * ◆单例模式
 * ◆原型模式
 *
 *
 * 组合型
 * ◆适配器模式
 * ◆装饰器模式
 * ◆代理模式
 * ◆外观模式
 * ◆桥接模式
 * ◆组合模式
 * ◆享元模式
 *
 * 行为型
 * ◆策略模式
 * ◆迭代器模式
 * ◆模板方法模式
 * ◆职责连模式
 * ◆观察者模式
 * ◆命令模式
 * ◆备忘录模式
 * ◆中介者模式
 * ◆状态模式
 * ◆解释器模式
 * ◆访问者模式
 */
```

- 快车与专车问题

```ts
// 车类
class Car {
  constructor(number, name) {
    this.number = number; // 车牌号
    this.name = name; // 车辆名称
  }
}

// 快车
class Kuaiche extends Car {
  constructor(number, name) {
    super(number, name);
    this.price = 1;
  }
}

// 专车
class Zhuanche extends Car {
  constructor(number, name) {
    super(number, name);
    this.price = 2;
  }
}

// 计程器
class Trip {
  constructor(car) {
    this.car = car;
  }

  // 输出开始行程
  start() {
    console.log(`行程开始，名称${this.car.name},车牌号码${this.car.number}`);
  }

  // 输出结束行程
  end() {
    console.log(`行程结束，价格：${this.car.price * 5}`);
  }
}

let car = new Kuaiche(100, '大众');
let trip = new Trip(car);
trip.start();
trip.end();
```

- 停车位问题

```ts
/**
 * ◆某停车场,分3层，每层100车位
 * ◆每个车位都能监控到车辆的驶入和离开
 * ◆车辆进入前,显示每层的空余车位数量
 * ◆车辆进入时,摄像头可识别车牌号和时间
 * ◆车辆出来时,出口显示器显示车牌号和停车时长
 */
// 车辆
class Car {
  constructor(num) {
    this.num = num;
  }
}

// 摄像头
class Camera {
  shot(car) {
    return {
      num: car.num,
      inTime: Date.now(),
    };
  }
}

// 出口显示屏
class Screen {
  show(car, inTime) {
    console.log('车牌号', car.num);
    console.log('停车时间', Date.now() - inTime);
  }
}

// 停车场
class Park {
  constructor(floors) {
    this.floors = floors || [];
    this.camera = new Camera();
    this.screen = new Screen();
    this.carList = {}; // 储存摄像头拍摄的返回车辆信息
  }

  // 车辆进入
  in(car) {
    // 通过摄像头获取信息
    const info = this.camera.shot(car);
    // 停到某个停车位
    const i = parseInt((Math.random() * 100) % 100);
    const place = this.floors[0].places[i];
    place.in();
    info.place = place;
    // 记录信息
    this.carList[car.num] = info;
  }

  // 车辆离开
  out(car) {
    // 获取信息
    const info = this.carList[car.num];
    // 将停车位清空
    const place = info.place;
    place.out();
    // 显示时间
    this.screen.show(car, info.inTime);
    // 清空记录
    delete this.carList[car.num];
  }

  // 空停车位的数量
  emptyNum() {
    return this.floors
      .map((floor) => {
        return `${floor.index} 层还有 ${floor.emptyPlaceNum()} 个车位`;
      })
      .join('\n');
  }
}

// 层
class Floor {
  constructor(index, places) {
    this.index = index;
    this.places = places || [];
  }
  // 空停车位的数量
  emptyPlaceNum() {
    let num = 0;
    this.places.forEach((p) => {
      if (p.empty) {
        num = num + 1;
      }
    });
    return num;
  }
}

// 车位
class Place {
  constructor() {
    this.empty = true;
  }

  // 车辆进入
  in() {
    this.empty = false;
  }

  // 车辆离开
  out() {
    this.empty = true;
  }
}

// 测试代码
const floors = [];
for (let i = 0; i < 3; i++) {
  const places = [];
  for (let j = 0; j < 100; j++) {
    places[j] = new Place();
  }
  floors[i] = new Floor(i + 1, places);
}

const park = new Park(floors);

// 初始化车辆
const car1 = new Car(100);
const car2 = new Car(200);
const car3 = new Car(300);

console.log('第一辆车进入');
console.log(park.emptyNum());
park.in(car1);

console.log('第二辆车进入');
console.log(park.emptyNum());
park.in(car2);

console.log('第一辆车离开');
park.out(car1);

console.log('第二辆车离开');
park.out(car2);
```

- 工厂模式

```ts
/**
 * ◆将new操作单独封装
 * ◆遇到new时,就要考虑是否该使用工厂模式
 *
 * ◆你去购买汉堡，直接点餐、取餐,不会自己亲手做
 * ◆商店要“封装”做汉堡的工作,做好直接给买者
 *
 * 使用场景
 * jQuery-$( 'div' )
 * React.createElement
 * vue异步组件
 *
 * 设计原则验证
 * ◆构造函数和创建者分离
 * ◆符合开放封闭原则
 */

// 产品
class Product {
  constructor(name) {
    this.name = name;
  }
  init() {
    console.log('init');
  }

  fun1() {
    console.log('fun1');
  }

  fun2() {
    console.log('fun2');
  }
}

// 工厂
class Creator {
  create(name) {
    return new Product(name);
  }
}

// 测试代码
let creator = new Creator();

let p = creator.create('p1');

p.init();
p.fun1();

/**
 * jQuery-$( 'div' )
 */
class jQuery {
  constructor(selector) {
    let slice = Array.prototype.slice;
    let dom = slice.call(document.querySelectorAll(selector));
    let len = dom ? dom.length : 0;

    for (let i = 0; i < len; i++) {
      this[i] = dom[i];
    }
    this.length = len;
    this.selector = selector || '';
  }

  // 其他api方法

  append(node) {}
  addClass(name) {}
  html(data) {}
}

window.$ = function (selector) {
  return new jQuery(selector);
};

console.log($('.red'));

/**
 * React.createElement
  */
class Vnode(tag,attrs,chilren){}

React.createElement = function(tag,attrs,children){
  return new Vnode(tag,attrs,chilren);
}
```

- 单例模式

```ts
/**
 * 单例模式
 * ◆系统中被唯一使用
 * ◆一个类只有一个实例
 *
 * 例子
 * ◆登录框
 * ◆购物车
 *
 * 说明
 * ◆单例模式需要用到java的特性( private )
 * ◆ES6中没有( typescript除外)
 * ◆只能用java代码来演示UML图的内容
 *
 * 场景
 * jQuery只有一一个$
 * 模拟登录框
 * 其他
 *
 * 其他使用场景
 * 购物车(和登录框类似)
 * vuex 和 redux 的 store
 *
 * 原则校验
 * ◆符合单一职责原则,只实例化唯一的对象
 * ◆没法具体开放封闭原则,但是绝对不违反开放封闭原则
 */

// 单例模式示例
class SingleObject {
  login() {
    console.log('login...');
  }
}

SingleObject.getInstance = (function () {
  let instance;
  return function () {
    if (!instance) {
      instance = new SingleObject();
    }
    return instance;
  };
})();

let obj1 = SingleObject.getInstance();

obj1.login();

let obj2 = SingleObject.getInstance();
obj2.login();

console.log('obj1 === obj2', obj1 === obj2);

// jQuery 只有一个'$'
if (window.jQuery !== null) {
  return window.jQuery;
} else {
  // 初始化...
}
```

- 设配器模式

```ts
/**
 * 适配器的使用场景
 * 1.封装旧接口
 * 2.vue computed
 *
 * 设计原则验证
 * ◆将旧接口和使用者进行分离
 * ◆符合开放封闭原则
 */
class Adaptee {
  specificRequest() {
    return '德国标准插头';
  }
}

class Target {
  constructor() {
    this.adaptee = new Adaptee();
  }
  request() {
    let info = this.adaptee.specificRequest();

    return `${info} - 转换器 - 中国标准插头`;
  }
}

// 测试代码
let target = new Target();

let res = target.request();

console.log('设配器模式', res);
```

- 装饰器模式

```ts
/**
 * 介绍.
 * ◆为对象添加新功能
 * ◆不改变其原有的结构和功能
 *
 * 场景
 * ES7装饰器
 * core-decorators
 */

class Circle {
  draw() {
    console.log('画一个圆形');
  }
}

/** 装饰器类  */
class Decorator {
  constructor(circle) {
    this.circle = circle;
  }

  draw() {
    this.circle.draw();
    this.setRedBorder(this.cirlce);
  }
  setRedBorder(circle) {
    console.log('设置红色边框');
  }
}

// 测试代码
let circle = new Circle();
circle.draw();

console.log('--- 分割线 ---');

let dec = new Decorator(circle);
dec.draw();

/**  实现一个简单的装饰类 */
@testDec
class Demo {}

function testDec(target) {
  target.isDec = true;
}

console.log(Deom.isDec);

/** 一个可以传入参数的简单装饰器 */

@testDec(false)
class Demo {}

function testDec(isDec) {
  return function (target) {
    target.isDec = isDec;
  };
}
console.log(Deom.isDec);

/** 实现一个mixins的装饰器  */
function mixins(obj) {
  return function (target) {
    Object.assign(target.prototype, obj);
  };
}

const Foo = {
  foo() {
    console.log('foo');
  },
};
@mixins(Foo)
class MyClass {}

let obj = new MyClass();
obj.foo();

/**
 * 方法装饰器
 */

// 示例代码1
function readonly(target, name, descriptor) {
  /**
   * descriptor 属性描述对象(Object.defindProperty中会用到) 
   {
     value:sepcifiedFunction,
     enumerable:false,
     configurable:true,
     writable:true
   }
   */
  descriptor.writable = false;
  return descriptor;
}

class Person {
  constructor() {
    this.first = 'A';
    this.last = 'B';
  }

  @readonly
  name() {
    return `${this.first} ${this.last}`;
  }
}

// 测试代码
let p = new Person();
console.log(p.name());

// 实例代码2
function log(target, name, descriptor) {
  let oldValue = descriptor.value;
  descriptor.value = function () {
    console.log(`calling ${name} width`, arguments);

    return oldValue.apply(this, arguments);
  };

  return descriptor;
}

class Math {
  @log
  add(a, b) {
    return a + b;
  }
}

// 测试代码
let math = new Math();
const result = math.add(2, 4);

console.log('result', result);

/**
 * core-decorators库的使用
 * ◆第三方开源lib
 * ◆提供常用的装饰器
 * ◆查阅文档: github.com/jayphelps/core decorators
 *
 * 设计原则校验
 * ◆将现有对象和装饰器进行分离,两者独立存在
 * ◆符合开放封闭原则
 */
```

- 代理模式

```ts
/**
 * 代理模式介绍
 * ◆使用者无权访问目标对象
 * ◆中间加代理,通过代理做授权和控制
 *
 * 设计原则验证
 * ◆代理类和目标类分离,隔离开目标类和使用者
 * ◆符合开放封闭原则
 */
class ReadImg {
  constructor(fileName) {
    this.fileName = fileName;
    this.loadFromDisk(); // 初始化从硬盘中加载 模拟
  }
  display() {
    console.log('display...', this.fileName);
  }
  loadFromDisk() {
    console.log('loading...' + this.fileName);
  }
}

// 代理类
class ProxyImg {
  constructor(fileName) {
    this.realImg = new ReadImg(fileName);
  }

  display() {
    this.realImg.display();
  }
}

// 测试代码
let img = new ProxyImg();
img.display();

/**
 * 代理模式的使用场景
 * Jquery的$.proxy
 */
$('#div1').click(function () {
  setTimeout(
    $.proxy(function () {
      // this 符合期望
      $(this).addClass('red');
    }, this),
    1000
  );
});

/**
 * ES6的代理模式
 */
let star = {
  name: '张**',
  age: 25,
  phone: '13900001111',
};

// 经纪人
let agent = new Proxy(star, {
  get: function (target, key) {
    if (key === 'phone') {
      // 返回经纪人自己的电话
      return 'agent_16899997777';
    }
    if (key === 'price') {
      // 明星不报价 经纪人报价
      return 12000;
    }
    return target[key];
  },
  set: function (target, key, value) {
    if (key === 'customPrice') {
      if (value < 1000000) {
        // 最低10w
        throw new Error('价格太低');
      } else {
        target[key] = value;
        return true;
      }
    }
  },
});

// 测试代码
console.log(agent.name);
console.log(agent.age);
console.log(agent.phone);
console.log(agent.price);

agent.customPrice = 15000;
console.log(agent.customPrice);

agent.customPrice = 1500;
console.log(agent.customPrice);
```

- 代理模式和设配器模式

```ts
/**
 * ◆适配器模式:提供一个不同的接口(如不同版本的插头)
 * ◆代理模式:提供一模一-样的接口
 */
```

- 代理模式和装饰器模式

```ts
/**
 * ◆装饰器模式:扩展功能,原有功能不变且可直接使用
 * ◆代理模式:显示原有功能,但是经过限制或者阉割之后的
 */
```

- 外观模式

```ts
/**
 * ◆为子系统中的一组接口提供了一个高层接口
 * ◆使用者使用这个高层接口
 *
 * 设计原则验证
 * ◆不符合单一职责原则和开放封闭原则,因此谨慎使用,不可滥用
 */
function bindEvent(elem, type, selector, fn) {
  if (fn === null) {
    fn = selector;
    selector = null;
  }

  // 其他逻辑
}

// 调用
bindEvent(elem, 'click', '#div1', fn);
bindEvent(elem, 'click', fn);
```

- 观察者模式(重要)

```ts
/**
 * ◆发布&订阅
 * ◆--对多
 *
 * 示例
 * ◆点咖啡,点好之后坐等被叫
 */
// 主题 保存状态 状态变化之后触发所有观察者对象
class Subject {
  constructor() {
    this.state = 0;
    this.observers = [];
  }
  getState() {
    return this.state;
  }
  setState(state) {
    this.state = state;
    // 状态改变后去通知所有的观察者
    this.notifyAllObservers();
  }

  // 通知所有观察者
  notifyAllObservers() {
    this.observers.forEach((observer) => {
      observer.update();
    });
  }

  // 添加观察者
  attach(observer) {
    this.observers.push(observer);
  }
}

// 观察者
class Observer {
  constructor(name, subject) {
    this.name = name;
    this.subject = subject;
    this.subject.attach(this);
  }

  update() {
    console.log(`${this.name} update , state: ${this.subject.getState()}`);
  }
}

// 测试代码
let s = new Subject();

let o1 = new Observer('01', s);
s.setState(1);
let o2 = new Observer('02', s);
s.setState(2);

/**
 * 运用场景
 * 网页事件绑定
 * Promise
 * jQuery callbacks
 * nodejs自定义事件
 */

let callbacks = $.Callbacks(); // 注意大小写
callbacks.add(function (info) {
  console.log('fn1', info);
});
callbacks.add(function (info) {
  console.log('fn2', info);
});

callbacks.fire('gogogo');
callbacks.fire('fire');

/**
 * nodejs自定义事件
 */
const EventEmitter = require('events').EventEmitter;

const emitter1 = new EventEmitter();
// 监听 some 事件
emitter1.on('some', (info) => {
  console.log('fn1', info);
});

emitter1.on('some', (info) => {
  console.log('fn2', info);
});

// 触发 some 事件
emitter1.emit('some', 'xxxxx');

/**
 * 继承自定义事件
 */
const EventEmitter = require('events').EventEmitter;

// 继承
class Dog extends EventEmitter {
  constructor(name) {
    super();
    this.name = name;
  }
}

let simon = new Dog('simon');

simon.on('bark', function () {
  console.log(this.name, ' barked-1');
});

simon.on('bark', function () {
  console.log(this.name, ' barked-2');
});

setInterval(() => {
  simon.emit('bark');
}, 1000);

/**
 * 文件系统中用到的自定义事件
 * 文件读取流的自定义事件
 */
// stream 用到自定义事件
const fs = require('fs');
const readStream = fs.createReadStream('./index.html');

let length = 0;
// 监听文件流的读取事件
readStream.on('data', function (chunk) {
  let len = chunk.toString().length;
  console.log('读取长度', len);
  length += len;
});
// 监听文件流结束事件
readStream.on('end', function () {
  console.log('length', length);
});

/**
 * 读取文件的行数
 */

const fs = require('fs');

const readline = require('readline');

// 获取输入
let rl = readline.createInterface({
  input: fs.createReadStream('./index.html'),
});

let lineNum = 0;
rl.on('line', function (line) {
  console.log(line);
  lineNum++;
});
rl.on('close', function () {
  console.log('lineNum', lineNum);
});

/**
 * 其他场景
 * ◆nodejs中:处理http请求;多进程通讯
 * ◆vue和React组件生命周期触发
 * ◆vue watch
 *
 * 设计原则验证
 * ◆主题和观察者分离,不是主动触发而是被动监听,两者解耦
 * ◆符合开放封闭原则
 */
```

- 迭代器模式

```ts
/**
 * 介绍
 * ◆顺序访问一个集合
 * ◆使用者无需知道集合的内部结构( 封装)
 */

function each(data) {
  let $data = $(data);
  $data.each(function (key, val) {
    console.log(key, val);
  });
}

/**
 * 封装一个迭代器
 */
// 迭代器类
class Iterator {
  constructor(container) {
    this.container = container;
    this.list = container.list;
    this.index = 0;
  }

  next() {
    if (this.hasNext()) {
      return this.list[this.index++];
    }
    return null;
  }
  hasNext() {
    if (this.index >= this.list.length) {
      return false;
    }
    return true;
  }
}

class Container {
  constructor(list) {
    this.list = list;
  }

  // 生成迭代器
  getIterator() {
    return new Iterator(this);
  }
}

let arr = [1, 2, 3, 4, 5, 6];

let container = new Container(arr);
let iterator = container.getIterator();

while (iterator.hasNext()) {
  console.log(iterator.next());
}

/**
 * ES6 Iterator为何存在
 * ◆ES6语法中,有序集合的数据类型已经有很多
 * ◆Array Map Set String TypedArray arguments NodeList
 * ◆需要有一个统一的遍历接口来遍历所有数据类型
 * ◆(注意, object不是有序集合,可以用Map代替)
 *
 *
 * ES6 Iterator是什么?
 * ◆以上数据类型,都有[Symbol.iterator] 属性
 * ◆属性值是函数,执行函数返回一个迭代器
 * ◆这个迭代器就有next方法可顺序迭代子元素
 *
 * 可运行Array.prototype[Symbol.iterator] 来测试
 */

function each(data) {
  // 生产遍历器
  let iterator = data[Symbol.iterator]();

  let item = { done: false };

  while (!item.done) {
    item = iterator.next();
    if (!item.done) {
      console.log(item.value);
    }
  }
}

// 测试代码
let arr = [1, 2, 3, 4];

each(arr);

/**
 * 通过for ... of 实现迭代器
 */
function each(data) {
  // 带有遍历器特性的对象： data[Symbol.iterator] 有值
  for (let item of data) {
    console.log(item);
  }
}

// 测试代码
let arr = [1, 2, 3, 4, 5];

each(arr);

/**
 * ES6 Iterator与Generator
 * ◆Iterator的价值不限于上述几个类型的遍历
 * ◆还有Generator函数的使用
 * ◆即只要返回的数据符合Iterator接口的要求
 * ◆即可使用Iterator语法,这就是迭代器模式
 */

/**
 * 设计原则验证
 * ◆迭代器对象和目标对象分离
 * ◆迭代器将使用者与目标对象隔离开
 * ◆符合开放封闭原则
 */
```

- 状态模式

```ts
/**
 * 介绍
 * ◆一个对象有状态变化
 * ◆每次状态变化都会触发-个逻辑
 * ◆不能总是用if..else来控制
 *
 * 示例
 * ◆交通信号灯不同颜色的变化
 */
// 状态 (红灯 绿灯 黄灯)
class State {
  constructor(color) {
    this.color = color;
  }
  handle(context) {
    console.log(`turn to ${this.color} light`);
    // 设置状态
    context.setState(this.color);
  }
}

// 主体
class Context {
  constructor() {
    this.state = null;
  }
  // 获取状态
  getState() {
    return this.state;
  }
  setState(state) {
    this.state = state;
  }
}

// 测试代码
let context = new Context();
let green = new State('green');
let yellow = new State('yellow');
let red = new State('red');

// 绿灯亮了
green.handle(context);
console.log(context.getState());
// 黄灯亮了
yellow.handle(context);
console.log(context.getState());
// 红灯亮了
red.handle(context);
console.log(context.getState());

/**
 * 场景
 * 有限状态机
 * ◆有限个状态、以及在这些状态之间的变化
 * ◆如交通信号灯
 * ◆使用开源lib : javascript-state-machine
 *
 * 写一个简单的Promise
 * Promise就是有限状态机
 * Promise EFфe : pending fullfilled rejected
 * pending -> fullfilled EX# pending -> rejected
 * 不能逆向变化
 *
 * 设计原则验证
 * ◆将状态对象和主题对象分离,状态的变化逻辑单独处理
 * ◆符合开放封闭原则
 */
```

- 原型模式

```ts
/**
 * 概念
 * ◆clone自己,生成一个新对象
 * ◆java默认有clone接口,不用自己实现
 * JS - Object.create
 */
const prototype = {
  getName: function () {
    return this.first + ' ' + this.last;
  },
  say: function () {
    console.log('hello');
  },
};

// 基于原型创建
let x = Object.create(prototype);
x.first = 'A';
x.last = 'B';
console.log(x.getName());
x.say();
```

- 桥接模式

```ts
/**
 * 概念
 * ◆用于把抽象化与实现化解耦
 * ◆使得二者可以独立变化
 * ◆(未找到JS中的经典应用)
 *
 * 设计原则验证
 * ◆抽象和实现分离,解耦
 * ◆符合开放封闭原则
 */
class Color {
  constructor(name) {
    this.name = name;
  }
}

class Shape {
  constructor(name, color) {
    this.name = name;
    this.color = color;
  }
  draw() {
    console.log(`${this.color.name} ${this.name}`);
  }
}

// 测试代码
let red = new Color('red');
let yellow = new Color('yello');
let circle = new Shape('circle', red);
circle.draw();

let triangle = new Shape('triangle', yellow);
triangle.draw();
```

- 组合模式

```ts
/**
 * 概念
 * ◆生成树形结构,表示“整体-部分”关系
 * ◆让整体和部分都具有一致的操作方式


 * 演示
 * ◆JS经典应用中,未找到这么复杂的数据类型
 * ◆虚拟DOM中的vnode是这种形式,但数据类型简单
 * ◆(用JS实现一个菜单,不算经典应用,与业务相关)
 * 
 * 演示
 * ◆整体和单个节点的操作是一致的
 * ◆整体和单个节点的数据结构也保持一致
 * 
 * 设计原则验证
 * ◆讲整体和单个节点的操作抽象出来
 * ◆符合开放封闭原则
 */
```

- 享元模式

```ts
/**
 * 概念
 * ◆共享内存(主要考虑内存,而非效率)
 * ◆相同的数据,共享使用
 * ◆( JS中未找到经典应用场景)
 *
 * 设计原则验证
 * ◆将相同的部分抽象出来
 * ◆符合开放封闭原则
 */
```

- 策略模式

```ts
/**
 * 概念
 * ◆不同策略分开处理
 * ◆避免出现大量if..else或者switch..case
 *
 * ◆不同策略,分开处理,而不是混合在一起
 * ◆符合开放封闭原则
 */
class OrdinaryUser {
  buy() {
    console.log('普通用户购买');
  }
}

class MemberUser {
  buy() {
    console.log('会员用户购买');
  }
}

class VipUser {
  buy() {
    console.log('vip 用户购买');
  }
}

// 测试代码
let u1 = new OrdinaryUser();
u1.buy();
let u2 = new MemberUser();
u2.buy();
let u3 = new VipUser();
u3.buy();
```

- 模版方法模式

```ts
/**
 * 模版方法模式
 */
class Action {
  handle() {
    this.handle1();
    this.handle2();
    this.handle3();
  }

  handle1() {
    console.log('1');
  }

  handle2() {
    console.log('2');
  }

  handle3() {
    console.log('3');
  }
}

// 测试代码
let h = new Action();
h.handle();
```

- 责职链模式

```ts
/**
 * 概念
 * ◆-步操作可能分位多个职责角色来完成
 * ◆把这些角色都分开,然后用一-个链串起来
 * ◆将发起者和各个处理者进行隔离
 */
// 请假审批 需要组长审批 经理审批 最后总监审批
class Action {
  constructor(name) {
    this.name = name;
    this.nextAction = null;
  }

  setNextAction(action) {
    this.nextAction = action;
  }

  handle() {
    console.log(`${this.name} 审批`);
    if (this.nextAction !== null) {
      this.nextAction.handle();
    }
  }
}

// 代码测试
let a1 = new Action('组长');
let a2 = new Action('经理');
let a3 = new Action('总监');

a1.setNextAction(a2);
a2.setNextAction(a3);

a1.handle();

/**
 * JS中的链式操作
 * ◆职责链模式和业务结合较多, JS中能联想到链式操作
 * ◆jQuery的链式操作Promise.then 的链式操作
 *
 * 设计原则验证
 * ◆发起者于各个处理者进行隔离
 * ◆符合开放封闭原则
 */
```

- 命令模式

```ts
/**
 * 概念
 * 执行命令时,发布者和执行者分开
 * ●中间加入命令对象,作为中转站
 */

class Receiver {
  exec() {
    console.log('执行');
  }
}

class Command {
  constructor(receiver) {
    this.receiver = receiver;
  }

  cmd() {
    console.log('触发命令');
    this.receiver.exec();
  }
}

class Invoker {
  constructor(command) {
    this.command = command;
  }
  invoke() {
    console.log('开始');
    this.command.cmd();
  }
}

// 测试代码
// 士兵
let soldier = new Receiver();
// 小号手
let trumpeter = new Command(soldier);
// 将军
let general = new Invoker(trumpeter);

general.invoke();

/**
 * JS中的应用
 * ◆网页富文本编辑器操作,浏览器封装了一一个命令对象
 * ◆document.execCommand('bold')
 * ◆document.execCommand(undo')
 *
 * 设计原则验证
 * ◆命令对象于执行对象分开,解耦
 * ◆符合开放封闭原则
 */
```

- 备忘录模式

```ts
/**
 * 概念
 * ◆随时记录-个对象的状态变化
 * ◆随时可以恢复之前的某个状态(如撤销功能)
 * ◆未找到JS中经典应用,除了一些工具(如编辑器)
 */
// 状态备忘
class Memento {
  constructor(content) {
    this.content = content;
  }
  getContent() {
    return this.content;
  }
}

// 备忘列表
class CareTaker {
  constructor() {
    this.list = [];
  }
  add(memento) {
    this.list.push(memento);
  }
  get(index) {
    return this.list[index];
  }
}

// 编辑器
class Editor {
  constructor() {
    this.content = null;
  }
  setContent(content) {
    this.content = content;
  }
  getContent() {
    return this.content;
  }
  saveContentToMemento() {
    return new Memento(this.content);
  }
  getContentFromMemento(memento) {
    this.content = memento.getContent();
  }
}

// 测试代码
let editor = new Editor();
let careTaker = new CareTaker();

editor.setContent('111');
editor.setContent('222');

careTaker.add(editor.saveContentToMemento()); // 存入备完录
editor.setContent('333');
careTaker.add(editor.saveContentToMemento()); // 存入备忘录
editor.setContent('444');

console.log(editor.getContent()); // 444
editor.getContentFromMemento(careTaker.get(1)); // 撤销
console.log(editor.getContent()); // 333
editor.getContentFromMemento(careTaker.get(0)); // 撤销
console.log(editor.getContent()); // 222

/**
 * 设计原则验证
 * ◆状态对象于使用者分开,解耦
 * ◆符合开放封闭原则
 */
```

- 中介者模式

```ts
/**
 * 设计原则验证
 * ◆讲各关联对象通过中者隔离
 * ◆符合开放封闭原则
 */
class A {
  constructor() {
    this.number = 0;
  }
  setNumber(num, m) {
    this.number = num;
    if (m) {
      // 如果存在中介者
      m.setB();
    }
  }
}

class B {
  constructor() {
    this.number = 0;
  }
  setNumber(num, m) {
    this.number = num;
    if (m) {
      // 如果存在中介者
      m.setA();
    }
  }
}

// 中介者
class Mediator {
  constructor(a, b) {
    this.a = a;
    this.b = b;
  }

  setB() {
    let number = this.a.number;
    this.b.setNumber(number * 100);
  }

  setA() {
    let number = this.b.number;
    this.a.setNumber(number / 100);
  }
}

// 测试代码
let a = new A();
let b = new B();
let m = new Mediator(a, b);

a.setNumber(100, m);
console.log(a.number, b.number);

b.setNumber(100, m);
console.log(a.number, b.number);
```

- 访问者模式

```ts
/**
 * 访问者模式
 * ◆将数据操作和数据结构进行分离
 * ◆使用场景不多
 */
```

- 解释器模式

```ts
/**
 * 解释器模式
 * ◆描述语言语法如何定义,如何解释和编译
 * ◆用于专业场景
 */
```

- 综合运用

```ts
/**
 * 介绍.
 * ◆使用jQuery做一个模拟购物车的示例
 * ◆包括:显示购物列表、加入购物车、从购物车删除
 *
 * 总结用到的设计模式
 * ◆工厂模式:$('xxx'),创建商品
 * ◆单例模式:购物车
 * ◆装饰器模式:打点统计
 *
 * ◆观察者模式:网页事件, Promise
 * ◆状态模式:添加到购物车&从购物车删除
 * ◆模板方法模式:渲染有统一的方法，内部包含了各模块渲染
 * ◆代理模式:打折商品信息处理
 */
```

- 单词

```pug
adapted 使适应
specific 特性 细节
attach 贴上
yield 产量
```

- 资源
  免费在线画图工具[https://www.processon.com/]
