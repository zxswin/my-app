## history 路由 与 hash 路由

```ts
/**
 * 解决浏览器不会重新刷新
 * hash模式的特点：
 * hash模式在浏览器地址栏中url有#号这样的，比如(http://localhost:3001/#/a).
 * # 后面的内容不会传给服务端，也就是说不会重新刷新页面。并且路由切换的时候也不会重新加载页面。
 *
 * history模式的特点：
 * 浏览器地址没有#， 比如(http://localhost:3001/a); 它也一样不会刷新页面的。但是url地址会改变。
 */
```

## history

- 1.history.length：

```ts
/**
 * 返回当前页面所产生的历史记录个数，即在同一个浏览器tab下产生的历史记录；
 */
```

- 2.history.pushState(state,title,URL)

```ts
/**
 * 向浏览器新增一条历史记录，但是不会刷新当前页面（不会重载），
 * 其中state为对象，可以用作携带信息用，title：目前来看没啥用一般为空或null，
 * URL：即要更改页面的URL，且必须同源，不能跨域
 */
```

- 3.history.replaceState(state,title,URL):

```ts
/**
 * 更改当前浏览器的历史记录，即把当前执行此代码页面的记录给替换掉，参数与第二条相同
 */
```

- 4.history.back()、history.forward()、history.go()：

```ts
/**
 * 分别为前进一个历史，后退一个，history.go(Number)，其中Number可正可负，即向前或向后若干个记录
 * 如果参数为0、undefined、null、false 将刷新页面，相当于执行window.location.reload()方法
 */
```

- history.state：

```ts
/**
 * 返回当前页面状态参数，此参数一般由history.pushState(state,title,URL);
 * 以及history.replaceState(state,title,URL);附带的state值，例子如下：
 */
history.pushState({ a: 1 }, null, 'test1'); //http://example.com/test1
history.state; //{a:1}

history.pushState({ b: 2 }, null, 'test2'); //http://example.com/test2
history.state; //{b:2}

history.back(); //http://example.com/test1
history.state; //{a:1}

history.back(); //http://example.com
history.state; //null
```

- history 事件 onpopstate

```ts
/**
 * 在history.back(),history.forward(),history.go()时触发此事件，
 * 但是在history.pushState();history.replaceState();时并不会触发此事件，
 * 事件内可以获取到state状态值
 */
window.onpopstate = function (e) {
  console.log(e.state);
};

window.addEventListener('popstate', function (e) {
  console.log(e);
});
```

- history 的路由实现

```ts
class HistoryRoutes {
  constructor() {
    // 保存对应键和函数
    this.routes = {};

    // 监听popstate事件
    window.addEventListener('popstate', (e) => {
      const path = this.getState();
      this.routes[path] && this.routes[path]();
    });
  }
  // 获取路由路径
  getState() {
    const path = window.location.pathname;
    return path ? path : '/';
  }
  route(path, callback) {
    this.routes[path] = callback || function () {};
  }
  init(path) {
    history.replaceState(null, null, path);
    this.routes[path] && this.routes[path]();
  }
  go(path) {
    history.pushState(null, null, path);
    this.routes[path] && this.routes[path]();
  }
}

window.Router = new HistoryRoutes();
console.log(location.pathname);
Router.init(location.pathname);

const body = document.querySelector('body');

const changeColor = function (color) {
  body.style.backgroundColor = color;
};
// 注册函数
Router.route('/', () => {
  changeColor('red');
});
Router.route('/a', () => {
  changeColor('green');
});
Router.route('/b', () => {
  changeColor('#CDDC39');
});

const ul = document.querySelector('ul');
ul.addEventListener('click', (e) => {
  console.log(e.target);
  if (e.target.tagName === 'A') {
    e.preventDefault();
    Router.go(e.target.getAttribute('href'));
  }
});
```

## hash 模式

- 关于 hash 模式

```ts
/**
 * hash路由模式是这样的：http://xxx.abc.com/#/xx。
 * 有带#号，后面就是hash值的变化。改变后面的hash值，它不会向服务器发出请求，因此也就不会刷新页面。
 * 并且每次hash值发生改变的时候，会触发hashchange事件。因此我们可以通过监听该事件，来知道hash值发生了哪些变化
 *
 * 改变hash不会触发页面跳转，因为hash链接是当前页面中的某个片段，所以如果hash有变化，那么页面将会滚动到hash所连接的位置。
 * 但是页面中如果不存在hash对应的片段，则没有任何效果。
 */
function hashAndUpdate() {
  // todo 匹配 hash 做 dom 更新操作
}

window.addEventListener('hashchange', hashAndUpdate);
```

- location 的属性

```ts
// 完整的url
location.href;

// 当前URL的协议，包括 :; 比如 https:
location.protocol;

/* 主机名和端口号，如果端口号是80(http)或443(https), 那就会省略端口号，比兔 www.baidu.com:8080 */
location.host;

// 主机名：比如：www.baidu.com
location.hostname;

// 端口号；比如8080
location.port;

// url的路径部分，从 / 开始; 比如 https://www.baidu.com/s?ie=utf-8，那么 pathname = '/s'了
location.pathname;

// 查询参数，从?开始；比如 https://www.baidu.com/s?ie=utf-8 那么 search = '?ie=utf-8'
location.search;

// hash是页面中的一个片段，从 # 开始的，比如 https://www.baidu.com/#/a/b 那么返回值就是："#/a/b"
location.hash;
```

- hash 和 pushState 对比有如下缺点

```ts
/**
 * 1.hash只能修改url的片段标识符的部分。并且必须从#号开始，但是pushState且能修改路径、查询参数和片段标识符。
 * 2.pushState比hash更符合前端路由的访问方式，更加优雅(因为不带#号)。
 * 3. hash必须和原先的值不同，才能新增会话浏览历史的记录，但是pushState可以新增相同的url的记录
 */
```

- 使用 hashchange 事件来监听 url hash 的改变

```ts
/**
 * 不管我们是通过location接口直接改变hash值，还是我们通过history直接前进或后退操作(改变hash变化)，
 * 我们都可以看到都能通过 hashchange该事件进行监听到url hash的改变。并且不会刷新页面
 */
```

- 改变 hash 值

```ts
const hastList = document.querySelector('.hash');

hastList.addEventListener('click', () => {
  const location = window.location;
  location.hash = 'abc';
});
```

- 实现一个简单的哈希路由跳转

```ts
class HashRouter {
  constructor() {
    // 存储hash与callback键值对
    this.routes = {};
    // 保存当前的hash
    this.currentHash = '';

    // 绑定事件
    const hashChangeUrl = this.hashChangeUrl.bind(this);

    // 页面加载事件
    window.addEventListener('load', hashChangeUrl, false);
    // 监听hashchange事件
    window.addEventListener('hashchange', hashChangeUrl, false);
  }
  // path路径和callback函数对应起来，并且使用 上面的this.routes存储起来
  route(path, callback) {
    this.routes[path] = callback || function () {};
  }
  hashChangeUrl() {
    /*
     获取当前的hash值
     location.hash 获取的值为："#/a, 因此 location.hash.slice(1) = '/a' 这样的
    */
    this.currentHash = location.hash.slice(1) || '/';
    // 执行当前hash对应的callback函数
    this.routes[this.currentHash]();
  }
}
// 初始化
const Router = new HashRouter();
const body = document.querySelector('body');
const changeColor = function (color) {
  body.style.backgroundColor = color;
};
// 注册函数
Router.route('/', () => {
  changeColor('red');
});
Router.route('/a', () => {
  changeColor('green');
});
Router.route('/b', () => {
  changeColor('#CDDC39');
});
```

## 单词

```pug
restoration  恢复
manual 手册
```
