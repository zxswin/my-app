## JS 模块化开发

- 开发一个模块管理引擎

```ts
let module = (function () {
  const moduleList = {}; // 缓存所有模块的列表
  /**
   * 定义模块的方法
   * @param name 模块的名称
   * @param {array} modules 需要依赖的模块列表
   * @param {function} action 定义模块的执行函数
   */
  function define(name, modules, action) {
    modules.map((m, i) => {
      modules[i] = moduleList[m];
    });
    moduleList[name] = action.apply(null, modules);
  }

  return {
    define,
  };
})();

// 定义模块实例(导出模块)
module.define('hd', [], function () {
  return {
    first(arr) {
      return arr[0];
    },
    max(arr, key) {
      return arr.sort((a, b) => b[key] - a[key])[0];
    },
  };
});

// 定义实例模块 这个模块会依赖与其他的模块(导入hd模块)
module.define('lesson', ['hd'], function (hd) {
  console.log(hd); // hd导出的模块
  let data = [
    { name: 'js', price: 199 },
    { name: 'mysql', price: 78 },
  ];

  console.log(hd.max(data, 'price'));
});

// 模块用的是引用地址,修改模块会影响其他模块的使用
module.define('a', [], function () {
  return {
    site: 'aaa',
  };
});

module.define('b', ['a'], function (a) {
  a.site = 'bbb';
});

module.define('c', ['a'], function (a) {
  console.log(a);
});
```

- 模块的基本使用

```ts
let title = 'aaa';

let url = 'houdunren.com';

function show() {
  console.log('xiaoming');
}

// 导出模块
export { title, url, show };
```

```html
<script type="module">
  // 模块的引用 script标签中一定要加type="module" 不然会报错
  import { title, url, show } from './hd.js';
  show();
</script>
```

- 模块延迟解析与严格模式

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>代码实例</title>
  </head>
  <script type="module">
    // type="module" 会让所有模块都加载完成后才执行 所有不用加在最后面也可以找到按钮
    // type="module"  默认使用严格模式
    // 严格模式下this是undefined
    // type="module" 下面的代码具有独立作用域 外部是访问不到的
    console.log(document.querySelector('button'));
  </script>
  <body>
    <button>后盾人</button>
  </body>
</html>
```

- 模块预解析的重要性

```ts
// 模块只有在第一次引用的时候被执行
// 之后如果再次被引用则不会再执行
import { title } from './hd.js';
import { show } from './hd.js';
```

- 模块的具名导出与导入

```ts
/* 具名导出 */
let site = 'aaa';
function show() {
  return 'show function';
}

class User {
  static render() {
    return 'user static render';
  }
}

export { site, show, User };

/** 具名导入 */
import { site, show, User } from './a.js';

console.log(site);
console.log(show());
console.log(User.render());
```

- 批量导入与建议

```ts
/*
 * 批量导入的写法
 * 会把所有模块都一次性加载
 * 建议使用具名导出 这样打包工具就只会打包使用到的代码减少文件体积
 */
import * as api from './modules/m8.js';
```

- 别名使用

```ts
/** 导出的时候使用别名 */
export { site as hd, show, User };
/* 导入的时候使用别名 */
import { hd, show as action, User as UserController } from './modules/m9.js';
```

- default 默认导出

```ts
/** 默认导出的写法 只能有一个默认导出模块 */
export default class User {
  static render() {
    return 'user statci render';
  }
}

// 默认导出也可以是这样
export { User as default };
/**
 * 导入
 * 导入默认导出模块的名称可以随便取 不一定要和默认导出的名称一样
 */
import hd from './a.js';

// 也可以是这样导入
import { default as hd } from './a.js';
```

- 混合导入导出的使用

```ts
/* 混合导出的第一种写法 */
let site = 'aaa';
export default class User {
  static render() {
    return 'user static render';
  }
}
export { site };

/** 混合导出的第二种写法 */

let site = 'aaa';
class User {
  static render() {
    return 'user static render';
  }
}
export { User as default, site };

/** 如果是批量导入再导入default模块的时候需要这么写  */
import * as api from './a.js';
console.log(api.default.render());
```

- 按需动态加载模块

```ts
document.querySelector('button').addEventListener('click', () => {
  import('./modules/m14.js').then(({ site, url }) => {
    console.log(site, url);
  });
});
```

- CommomJS AMD ES6 模块化规范

```ts
/**
 * AMD 模块化
 * 1.异步模块定义
 * 2.最佳实践者 RequireJS
 * 3.它采用异步方式加载模块，模块的加载不影响它后面语句的运行
 * 4.所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行
 * 5.模块功能主要的几个命令：define、require、return
 * 6.define是全局函数，用来定义模块,define(id?, dependencies?, factory)
 * 7.require命令用于输入其他模块提供的功能，return命令用于规范模块的对外接口
 * 8.define.amd属性是一个对象，此属性的存在来表明函数遵循AMD规范。
 * 9.define来定义模块，return来输出接口， require来加载模块
 * 10.AMD 推崇依赖前置、提前执行
 *
 */

// model1.js
define(function () {
  console.log('model1 entry');
  return {
    getHello: function () {
      return 'model1';
    },
  };
});
// model2.js
define(function () {
  console.log('model2 entry');
  return {
    getHello: function () {
      return 'model2';
    },
  };
});
// main.js
define(function (require) {
  var model1 = require('./model1');
  console.log(model1.getHello());
  var model2 = require('./model2');
  console.log(model2.getHello());
});

// 使用
requirejs(['main']);

/**
 * CMD 通用模块定义
 * 1.最佳实践者Sea.js
 * 2.主要在浏览器中运行，当然也可以在Node.js中运行
 * 3.CMD推崇依赖就近、延迟执行
 */
// model1.js
define(function (require, exports, module) {
  console.log('model1 entry');
  exports.getHello = function () {
    return 'model1';
  };
});
// model2.js
define(function (require, exports, module) {
  console.log('model2 entry');
  exports.getHello = function () {
    return 'model2';
  };
});
// main.js
define(function (require, exports, module) {
  var model1 = require('./model1'); //在需要时申明
  console.log(model1.getHello());
  var model2 = require('./model2'); //在需要时申明
  console.log(model2.getHello());
});

// 执行
seajs.use('./main.js');

/**
 * UMD 通用模块定义模式
 * 1.解决CommonJS模式和AMD模式代码
 * 2.判断define为函数，并且是否存在define.amd，来判断是否为AMD规范,
 * 3.判断module是否为一个对象，并且是否存在module.exports来判断是否为CommonJS规范
 */

/**
 * CommomJS
 * 1.commonjs 模块输出的是一个值的拷贝
 * 2.commonjs 模块是在运行时加载
 * 3.CommonJS 采用同步加载模块 (只有当模块运行后，才能知道导出的模块是什么)
 * 4.CommonJS 主要运行于服务器端
 * 6.require导入模块:const path = require('path');
 * 7.module.exports 导出模块
 * 8.最佳实践者 Node.js
 * 9.CommonJS 模块重复引入的模块并不会重复执行，再次获取模块只会获得之前获取到的模块的缓存
 *
 *
 * 限循环调用
 * 1.当遇到 require() 语句时，会执行 require 模块中的代码，并缓存执行的结果，
 * 2.当下次再次加载时不会重复执行，而是直接取缓存的结果。
 * 3.正因为此，出现循环依赖时才不会出现无限循环调用的情况
 *
 */
// 模块 a.js
const name = 'qiufeng';

module.exports = {
  name,
  github: 'https://github.com/hua1995116',
};
// 模块 b.js
// 引用核心模块或者第三方包模块，不需要写完整路径
const path = require('path');
// 引用自定义模块可以省略.js
const { name, github } = require('./a');

console.log(name, github, path.basename(github));

/**
 * ES6的模块化
 * 1.ES6模块树池的是值的引用
 * 2.es6模块是在编译时加载(静态编译, 在编译阶段就能知道导出什么模块)
 * 3.浏览器默认加载不能省略.js
 * 4.它同时兼容在node环境下运行。
 * 5.模块的导入导出，通过import和export来确定。 可以和Commonjs模块混合使用
 * 6.import 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行
 * 7.import语句导入同一个模块如果加载多次只执行一次
 */

// import 优先执行
// a.js
console.log('a.js');
import { age } from './b.js';

// b.js
export let age = 1;
console.log('b.js 先执行');

// 运行 index.html 执行结果:
// b.js 先执行
// a.js

// export 变量声明提升

// 动态import()，它主要是为了解决 ES6 模块无法在运行时确定模块的引用关系

/**
 * TypeScript中
 * ES6 import 语法 导入common.js模块
 */

import foo = require('foo');

/**
 * 很多库使用了 CommonJS 的导出方式，如 module.exports=a，
 * 这样会导致使用ES的方式导入时失败，如 import a from 'X'。
 * 因为ES6会默认访问 a 的 default 属性。TypeScript 为了兼容
 * 引入了 esModuleInterop 选项，在编辑时自动添加default属性
 *
 * 当开启 tsconfig.json 中的 esModuleInterop 选项时，可以使用 ES6模块的导入语法
 */

// 不加esModuleInterop时，正确引用fs的方法是下面这样
import * as fs from 'fs';
console.log(fs);

// 或者

import { fsync } from 'fs';
console.log(fsync);

// 加上esModuleInterop，代码
import fs from 'fs';
console.log(fs);
```
