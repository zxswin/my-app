## 性能优化

## 如何在 H5 和小程序项目中计算白屏时间和首屏时间，说说你的思路

```ts
/**
 * 通常认为浏览器开始渲染 <body> 标签或者解析完 <head> 标签的时刻就是页面白屏结束的时间点
 * 首屏时间是指用户打开网站开始，到浏览器首屏内容渲染完成的时间。
 * 利用window.performance.timing进行性能分析
 * window.performance.timing中相关属性语义：
 */

//  .navigationStart 准备加载页面的起始时间
//  .unloadEventStart 如果前一个文档和当前文档同源,返回前一个文档开始unload的时间
//  .unloadEventEnd 如果前一个文档和当前文档同源,返回前一个文档开始unload结束的时间
//  .redirectStart   如果有重定向,这里是重定向开始的时间.
//  .redirectEnd     如果有重定向,这里是重定向结束的时间.
//  .fetchStart        开始检查缓存或开始获取资源的时间
//  .domainLookupStart   开始进行dns查询的时间
//  .domainLookupEnd     dns查询结束的时间
//  .connectStart                  开始建立连接请求资源的时间
//  .connectEnd                     建立连接成功的时间.
//  .secureConnectionStart      如果是https请求.返回ssl握手的时间
//  .requestStart                     开始请求文档时间(包括从服务器,本地缓存请求)
//  .responseStart                   接收到第一个字节的时间
//  .responseEnd                      接收到最后一个字节的时间.
//  .domLoading ‘current document readiness’ 设置为 loading的时间 (这个时候还木有开始解析文档)
//  .domInteractive 文档解析结束的时间
//  .domContentLoadedEventStart    DOMContentLoaded事件开始的时间
//  .domContentLoadedEventEnd      DOMContentLoaded事件结束的时间
//  .domComplete current document readiness被设置 complete的时间
//  .loadEventStart   触发onload事件的时间
//  .loadEventEnd     onload事件结束的时间

// 一般指标：
// DNS查询耗时 = domainLookupEnd - domainLookupStart
// TCP链接耗时 = connectEnd - connectStart
// request请求耗时 = responseEnd - responseStart
// 解析dom树耗时 = domComplete - domInteractive
// 白屏时间 = domloadng - fetchStart
// domready时间 = domContentLoadedEventEnd - fetchStart
// onload时间 = loadEventEnd - fetchStart

// 实际前端更关注的指标（需要在实际中结合自身代码）：
console.log(
  '首屏图片加载完成 : ',
  window.lastImgLoadTime - window.performance.timing.navigationStart
); //在最后一张图出来的时候打时间点
console.log(
  'HTML加载完成 : ',
  window.loadHtmlTime - window.performance.timing.navigationStart
); //在HTML后打时间点
console.log(
  '首屏接口完成加载完成 : ',
  Report.SPEED.MAINCGI - window.performance.timing.navigationStart
); //在首屏的接口打时间点
console.log(
  '接口完成加载完成 : ',
  Report.SPEED.LASTCGI - window.performance.timing.navigationStart
); //在所有接口打时间点
```

## web 的首屏加载优化

```ts
/**
 * 1.白屏时间是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。
 * 2.首屏时间是指浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成
 * 3.白屏时间是首屏时间的一个子集
 */
```

- 计算白屏时间

```ts
/**
 * 利用performance.timing提供的数据
 * 白屏时间：performance.timing.responseStart - performance.timing.navigationStart
 * 通过DOMContentLoad或者performance来衡量首屏时间
 * DOMContentLoad并不可靠浏览器可能在接口内容还没返回前，就触发了window的DOMContentLoaded和load事件
 * FCP（first-contentful-paint）大概意思就是第一屏的内容已经加载完成并且用户可以使用其中的功能
 */
// 方案一：
document.addEventListener('DOMContentLoaded', (event) => {
    console.log('first contentful painting');
});
// 方案二：
performance.getEntriesByName("first-contentful-paint")[0].startTime

// performance.getEntriesByName("first-contentful-paint")[0]会
// 返回一个 PerformancePaintTiming的实例，结构如下：
{
  name: "first-contentful-paint",
  entryType: "paint",
  startTime: 507.80000002123415,
  duration: 0,
};
```

- 优化首屏加载时间

```ts
/**
 * 1.cdn分发减少传输距离
 * 通过在多台服务器部署相同的副本，服务器根据用户跟哪台服务器距离近，来决定哪台服务器去响应这个请求
 *
 * 2.静态文件缓存方案
 * 文件hash+强缓存,比如hash + cache control: max-age=1年
 *
 * 3.前端的资源动态加载
 * 路由动态加载，最常用的做法，以页面为单位，进行动态加载
 * 组件动态加载(offScreen Component)，对于不在当前视窗的组件，先不加载
 * 图片懒加载(offScreen Image)，同上。
 * 越来越多的浏览器支持原生的懒加载，通过给img标签加上loading="lazy来开启懒加载模式
 *
 * 4.减少请求的数量,合并请求如雪碧图的使用
 * 5.页面使用骨架屏
 * 意思是在首屏加载完成之前，通过渲染一些简单元素进行占位。骨架屏的好处在于可以减少用户等待时的急躁情绪
 * 6.使用ssr渲染
 * 7. 引入http2.0。
 * 8.利用好http压缩。即使是最普通的gzip
 * 9.利用好script标签的async和defer这两个属性。加载js不阻塞页面渲染
 * 10.使用 webp 的图片格式来代替现有的jpeg和png
 *
 * lightHouse是chorme devTools的一个功能，经常用来检查首屏加载的情况
 */
```
