## 网络

## 简单讲解一下 http2 的多路复用

- http 传输的数据格式

```ts
/**
 * HTTP请求头和响应头都是以ASCII文本方式传输的，但是传输内容（请求响应体）可能是多种形式的。
 * 接收方处理数据时是根据请求头/响应头中的content-type属性来处理的。
 * Content-Type:image/gif 这说明传输的是一个image对象（二进制数据），该对象为gif格式，
 * Content-length:91 这说明传输的数据大小为91个字节，
 * 响应头若没有Transfer-Encoding这个字段，说明传输的数据没有经过任何形式的编码转换，传输的就是源文件的内容。
 */
```

- HTTP/1.0

```ts
/**
 * 每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。
 * 为了解决这个问题，需要使用 Connection: keep-alive 这个字段
 */
```

- HTTP/1.1 版本

```ts
/**
 * 该版本引入了持久连接（persistent connection），即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。
 * 还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。
 * 但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。
 * 要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）
 */
```

- HTTP/2.1 版本

```ts
/**
 * http2的多路复用
 *
 * http2的传输是基于二进制帧的。
 * 每一个TCP连接中承载了多个双向流通的流，每一个流都有一个独一无二的标识和优先级，而流就是由二进制帧组成的。
 * 二进制帧的头部信息会标识自己属于哪一个流，所以这些帧是可以交错传输，然后在接收端通过帧头的信息组装成完整的数据。
 * 这样就解决了线头阻塞的问题，同时也提高了网络速度的利用率。
 *
 * HTTP/2 复用 TCP 连接，在一个连接里，客户端可以同时发送多个请求或回应，而且不用按照顺序一一对应。
 * 举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，
 * 于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分
 */
```

## TCP 三次握手和四次挥手

```ts
/**
 * 建立TCP连接的前奏
 * 1.标志位:
 * SYN: Synchronize Sequence Numbers 同步序列编号
 * ACK: Acknowledgement 确认字符
 *
 * 报文主要段的意思
 * 序号：表示发送的数据字节流，确保TCP传输有序，对每个字节编号
 * 确认序号：发送方期待接收的下一序列号，接收成功后的数据字节序列号加 1。只有ACK=1时才有效。
 * ACK：确认序号的标志，ACK=1表示确认号有效，ACK=0表示报文不含确认序号信息
 * SYN：连接请求序号标志，用于建立连接，SYN=1表示请求连接
 * FIN：结束标志，用于释放连接，为1表示关闭本方数据流
 *
 * 建立TCP的三次握手总结
 * 第一次握手:客户端向服务器发送SYN标志位序列号seq=x，并进入SYN_ SEND状态(等待服务器确认状态)。
 * 第二次握手:服务器收到来自客户端的SYN包，服务端会确认该数据包已收到并发送ACK标志位(序列号是ack=x+1)和SYN标志位(序列号seq=y)，服务器进入SYN_ RECV (请求接收并等待客户端确认状态)
 * 第三次握手:客户端收到服务器的SYN+ACK包，向服务器发送ACK标志位(序列号ack=y+1) seq=x+1 递增 确认客户端已收到建立连接确认，服务器收到ACK标志位后，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
 *
 * 四次挥手
 * 第一次挥手：客户端发送一个FIN=u，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。
 * 意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。
 *
 * 第二次挥手：服务器端收到FIN后，先发送ack=u+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就 * 进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。
 *
 * 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=v报文，告诉客户端，好了，
 * 我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。
 *
 * 第四次挥手：客户端收到FIN=v报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=v+1后进入
 * TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，立刻进入CLOSE状态。
 * 客户端经过2个最长报文段寿命后，客户端CLOSE；
 *
 *
 *
 * 问题1:为什么连接的时候是三次握手，关闭的时候却是四次握手
 * 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。
 * 其中ACK报文是用来应答的，SYN报文是用来同步的。
 * 但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，
 * 所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。
 * 只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
 *
 * 问题2:如果已经建立了连接，但是客户端突然出现故障了怎么办
 * TCP还设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，
 * 若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。
 * 若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
 */
```

## 介绍 HTTPS 握手过程

```ts
/**
 * 介绍 HTTPS 握手过程
 * 1.客户端使用https的url访问web服务器,要求与服务器建立ssl连接
 * 2.web服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端
 * 3.客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个会话秘钥
 * 4.客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥
 * 5.之后服务器与客户端使用会话秘钥加密传输
 */
```

## HTTPS 握手过程中，客户端如何验证证书的合法性

```ts
/**
 * 权威的证书颁发机构CA来解决；
 * 1.制作证书：作为服务端的A，首先把自己的公钥key1发给证书颁发机构，向证书颁发机构进行申请证书；
 * 证书颁发机构有一套自己的公私钥，CA通过自己的私钥来加密key1,并且通过服务端网址等信息生成一个证书签名，
 * 证书签名同样使用机构的私钥进行加密；制作完成后，机构将证书发给A；
 * 2.校验证书真伪：当B向服务端A发起请求通信的时候，A不再直接返回自己的公钥，而是返回一个证书；
 * 说明：各大浏览器和操作系统已经维护了所有的权威证书机构的名称和公钥。
 * B只需要知道是哪个权威机构发的证书，使用对应的机构公钥，就可以解密出证书签名；
 * 接下来，B使用同样的规则，生成自己的证书签名，如果两个签名是一致的，说明证书是有效的；
 * 签名验证成功后，B就可以再次利用机构的公钥，解密出A的公钥key1;
 * 接下来的操作，就是和之前一样的流程了；
 * 3.中间人是否会拦截发送假证书到B呢？ 因为证书的签名是由服务器端网址等信息生成的，并且通过第三方机构的私钥加密中间人无法篡改； 所以最关键的问题是证书签名的真伪；
 */
```

## 介绍下 HTTPS 中间人攻击

```ts
/**
 * 使用非对称加密的方式；使用公钥/私钥加解密；
 * 通信方A发起通信并携带自己的公钥，接收方B通过公钥来加密对称秘钥；然后发送给发起方A；
 * A通过私钥解密；双发接下来通过对称秘钥来进行加密通信；
 * 但是这种方式还是会存在一种安全性；中间人虽然不知道发起方A的私钥，但是可以做到偷天换日，将拦截发起方的公钥key;
 * 并将自己生成的一对公/私钥的公钥发送给B；
 * 接收方B并不知道公钥已经被偷偷换过；按照之前的流程，B通过公钥加密自己生成的对称加密秘钥key2;发送给A；
 * 这次通信再次被中间人拦截，尽管后面的通信，两者还是用key2通信，但是中间人已经掌握了Key2;
 * 可以进行轻松的加解密；还是存在被中间人攻击风险
 */
```

## 介绍下 http1.0、1.1、2.0 协议的区别

- http1.0

```ts
/**
 * http1.0特性
 * 1.无状态：服务器不跟踪不记录请求过的状态
 * 2.无连接：浏览器每次请求都需要建立tcp连接
 *
 * 无状态
 * 对于无状态的特性可以借助cookie/session机制来做身份认证和状态记录
 *
 * 无连接
 * 无连接导致的性能缺陷有两种：
 * 1. 无法复用连接
 * 每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低
 * 2. 队头阻塞
 * http1.0规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的
 */
```

- http1.1

```ts
/**
 * http1.1特性：
 * 1.长连接：新增Connection字段，可以设置keep-alive值保持连接不断开
 * 2.管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回
 * 3.缓存处理：新增字段cache-control
 * 4.断点传输
 *
 * 长连接
 * http1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据
 *
 * 管道化
 * 基于长连接的基础，我们先看没有管道化请求响应：
 * tcp没有断开，用的同一个通道
 * 请求1 > 响应1 --> 请求2 > 响应2 --> 请求3 > 响应3
 * 管道化的请求响应：
 * 请求1 --> 请求2 --> 请求3 > 响应1 --> 响应2 --> 响应3
 * 即使服务器先准备好响应2,也是按照请求顺序先返回响应1
 * 虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题
 *
 * 缓存处理
 * 当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求
 * 通过设置字段cache-control来控制
 *
 * 断点传输
 * 在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，
 * 如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率
 * 在 Header 里两个参数实现的，客户端发请求时对应的是 Range 服务器端响应时对应的是 Content-Range
 */
```

- http2.0

```ts
/**
 * http2.0特性
 * 二进制分帧
 * 多路复用： 在共享TCP链接的基础上同时发送请求和响应
 * 头部压缩
 * 服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求
 *
 *
 * 二进制分帧
 * 将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码
 *
 * 多路复用
 * 基于二进制分帧，在同一域名下所有访问都是从同一个tcp连接中走，
 * http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来
 *
 * 区别
 * http1.0 到http1.1的主要区别，就是从无连接到长连接
 * http2.0对比1.X版本主要区别就是多路复用
 */
```

## 永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响

```ts
/**
 * 301重定向可促进搜索引擎优化效果
 * 从搜索引擎优化角度出发，301重定向是网址重定向最为可行的一种办法。
 * 当网站的域名发生变更后，搜索引擎只对新网址进行索引，同时又会把旧地址下原有的外部链接如数转移到新地址下，
 * 从而不会让网站的排名因为网址变更而收到丝毫影响。
 * 同样，在使用301永久性重定向命令让多个域名指向网站主域时，亦不会对网站的排名产生任何负面影响。

 * 302重定向可影响搜索引擎优化效果
 * 迄今为止，能够对302重定向具备优异处理能力的只有Google。也就是说，在网站使用302重定向命令将其它域名指向主域时，
 * 只有Google会把其它域名的链接成绩计入主域，而其它搜索引擎只会把链接成绩向多个域名分摊，
 * 从而削弱主站的链接总量。既然作为网站排名关键因素之一的外链数量受到了影响，网站排名降低也是很自然的事情了。
 * 
 * 运用场景
 * 301应用场景: 域名到期不想继续用这个,换了地址
 * 302应用场景: 做活动时候,从首页跳到活动页面,
 */
```

## Http 状态码

```ts
/**
 * 301/302/303都表示重定向，所以放在一起讲解。
 * 301表示永久重定向（301 moved permanently），表示请求的资源分配了新url，以后应使用新url。
 * 302表示临时性重定向（302 found），请求的资源临时分配了新url，本次请求暂且使用新url。
 * 302与301的区别是，302表示临时性重定向，重定向的url还有可能还会改变。
 * 303 表示请求的资源路径发生改变，使用GET方法请求新url。与302的功能一样，但是明确指出使用GET方法请求新url。
 * 新url指的是，第一次请求返回的location。
 *
 * 304 not modified
 * 客户端发送附带条件的请求时（if-matched,if-modified-since,if-none-match,if-range,if-unmodified-since任一个）
 * 服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）
 * 304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3xx类别中，但是和重定向没有关系。
 *
 *
 * 400 bad request
 * 表示请求的报文中存在语法错误，比如url含有非法字符。
 * 提交json时，如果json格式有问题，接收端接收json，也会出现400 bad request
 *
 * 405 method not allowed
 * 问题原因：请求的方式（get、post、delete）方法与后台规定的方式不符合。
 * 比如：后台方法规定的请求方式只接受get，如果用post请求，就会出现 405 method not allowed的提示
 *
 * 415
 * 后台程序不支持提交的content-type，就会返回415，spring mvc错误信息如下
 *
 */
```

## 接口如何防刷

```ts
/**
 * 验证码
 * 短信验证
 * 根据ip限制访问频率
 */
```
