## 编程题

- 下面代码中 a 在什么情况下会打印 1

```ts
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}

// 解法
let a = [1,2,3];
a.toString = a.shift;
if( a == 1 && a == 2 && a == 3 ) {
  console.log(1);
}
```

- 实现一个 sleep 函数

```ts
// 通过同步的方式实现
function sleep(time) {
  var now = +Date.now();
  while (+Date.now() - now <= time) {}
  return;
}

// 通过异步的方式实现
//async
function sleep(time) {
  return new Promise((resolve) => setTimeout(resolve, time));
}
async function output() {
  let out = await sleep(1000);
  console.log(1);
  return out;
}
```

- 实现 (5).add(3).minus(2) 功能

```ts
Number.prototype.add = function (number) {
  if (typeof number !== 'number') {
    throw new Error('请输入数字～');
  }
  return this + number;
};
Number.prototype.minus = function (number) {
  if (typeof number !== 'number') {
    throw new Error('请输入数字～');
  }
  return this - number;
};
console.log((5).add(3).minus(2));
```

- 数组编程题

```ts
// [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，
// 要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]
function creatArr(num, range) {
  let resultArr = [];
  for (i = 0; i < num; i++) {
    let item = Math.floor(Math.random() * range);
    console.log(item);
    resultArr.push(item);
  }

  return resultArr;
}

function creatGroud(arr) {
  console.log(arr);
  let resultArr = [];

  const uniqueArr = [...new Set(arr)].sort(function (a, b) {
    return a - b;
  });
  console.log('uniqueArr', uniqueArr);
  let map = {};

  // 把数组按照十位数分组逻辑
  uniqueArr.forEach((item) => {
    const key = Math.floor(item / 10);

    if (!map[key]) map[key] = [];

    map[key].push(item);
  });

  Object.keys(map)
    .sort((a, b) => a - b)
    .forEach((key) => {
      resultArr.push(map[key]);
    });

  return resultArr;
}

let newArr = creatArr(10, 100);

let groudArr = creatGroud(newArr);

console.log(groudArr);
```

- 把字符串大小写取反

```ts
function transfer(str) {
  return str.replace(/[a-zA-Z]/g, (match) => {
    return /[a-z]/.test(match) ? match.toUpperCase() : match.toLowerCase();
  });
}

// 测试代码
let str = transfer('aBc');
console.log('str', str);
```

- 查找某个字符串的位置

```ts
var find = function (S, T) {
  if (T.length > S.length) return -1;

  let index = S.indexOf(T);
  let count = [];

  while (index != -1) {
    count.push(index);
    index = S.indexOf(T, index + T.length);
  }

  return count;
};
```

- 实现数组的右旋转

```ts
// 输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3
// 输出: [5, 6, 7, 1, 2, 3, 4]

let arr1 = [1, 2, 3, 4, 5, 6, 7];

let k = 3;

function rotate(arr, k) {
  for (let i = 0; i < k; i++) {
    let pop = arr.pop(); // 从尾部弹出来
    arr.unshift(pop); // 从头部加进入
  }

  return arr;
}

let arr2 = rotate(arr1, k);

console.log(arr2);
```

- 打印出 1 - 10000 之间的所有对称数

```ts
// 最简单的方法是循环10000次，反转数字前后比较如果相等
var result = [];
for (let i = 1; i <= 10000; i++) {
  let origin = '' + i;
  let reverse = origin.split('').reverse().join('');
  if (origin === reverse) {
    result.push(i);
  }
}

console.log(result);

// 不用循环10000次的写法
var result = [];
for (let i = 1; i < 10; i++) {
  result.push(i * 11); // 两位数的对称数
  for (let j = 0; j < 10; j++) {
    result.push(i * 101 + j * 10); //  三位数的对称数
    result.push(i * 1001 + j * 110); // 四位数的对称数，当i和j均为9是值为9999
  }
}
console.log(result);
```

- 移动零

```ts
// 输入: [0,1,0,3,12]
// 输出: [1,3,12,0,0]

let arr = [0, 1, 0, 3, 12];

function moveZero(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === 0) {
      arr.splice(i, 1);
      arr.push(0);
    }
  }
}

moveZero(arr);

console.log(arr);
```

- 请实现一个 add 函数，满足以下功能

```ts
// add(1); 			// 1
// add(1)(2);  	// 3
// add(1)(2)(3)；// 6
// add(1)(2, 3); // 6
// add(1, 2)(3); // 6
// add(1, 2, 3); // 6

function add() {
  let args = [...arguments];
  let addfun = function () {
    args.push(...arguments);
    return addfun;
  };
  addfun.toString = function () {
    return args.reduce((a, b) => {
      return a + b;
    });
  };
  return addfun;
}

console.log(add(1)(2)(3) + ''); // 6
console.log(add(1, 2, 3)(4)); // 10
```

- 两数之和

```ts
/**
 * 给定 nums = [2, 7, 11, 15], target = 9
 * 因为 nums[0] + nums[1] = 2 + 7 = 9
 * 所以返回 [0, 1]
 */

let arr = [2, 7, 11, 15];

let target = 9;

let resultArr = [];

for (let i = 0; i < arr.length; i++) {
  let item = arr[i];
  let index = arr.findIndex((x, j) => {
    return x === target - item && j !== i;
  });
  if (index > -1) {
    resultArr = [index, i];
  }
}

console.log('resultArr', resultArr);
```

- 把原始 list 转换成树形结构

```ts
// 原始 list 如下
let list = [
  { id: 1, name: '部门A', parentId: 0 },
  { id: 2, name: '部门B', parentId: 0 },
  { id: 3, name: '部门C', parentId: 1 },
  { id: 4, name: '部门D', parentId: 1 },
  { id: 5, name: '部门E', parentId: 2 },
  { id: 6, name: '部门F', parentId: 3 },
  { id: 7, name: '部门G', parentId: 2 },
  { id: 8, name: '部门H', parentId: 4 },
];
const result = convert(list);

console.log('result', result);

function convert(list) {
  const res = [];
  const map = list.reduce((res, v) => {
    res[v.id] = v;
    return res;
  }, {});

  for (const item of list) {
    if (item.parentId === 0) {
      res.push(item);
      continue;
    }
    if (item.parentId in map) {
      const parent = map[item.parentId];
      parent.children = parent.children || [];
      parent.children.push(item);
    }
  }
  return res;
}

// 使用深度优先算法DFS
function convert(source, parentId = 0) {
  let trees = [];
  for (let item of source) {
    if (item.parentId === parentId) {
      let children = convert(source, item['id']);
      if (children.length) {
        item.children = children;
      }
      trees.push(item);
    }
  }
  return trees;
}

// // 转换后的结果如下
// let result = [
//   {
//     id: 1,
//     name: '部门A',
//     parentId: 0,
//     children: [
//       {
//         id: 3,
//         name: '部门C',
//         parentId: 1,
//         children: [
//           {
//             id: 6,
//             name: '部门F',
//             parentId: 3
//           }, {
//             id: 16,
//             name: '部门L',
//             parentId: 3
//           }
//         ]
//       },
//       {
//         id: 4,
//         name: '部门D',
//         parentId: 1,
//         children: [
//           {
//             id: 8,
//             name: '部门H',
//             parentId: 4
//           }
//         ]
//       }
//     ]
//   },
// ···
// ];
```

- 树状结构数据的优先遍历

```ts
const tree = [
  {
    id: '1',
    name: 'test1',
    children: [
      {
        id: '11',
        name: 'test11',
        children: [
          {
            id: '111',
            name: 'test111',
          },
          {
            id: '112',
            name: 'test112',
          },
        ],
      },
      {
        id: '12',
        name: 'test12',
        children: [
          {
            id: '121',
            name: 'test121',
          },
        ],
      },
    ],
  },
];

let result = [];

function dfs(tree) {
  if (!tree.length) return;

  tree.forEach((item) => {
    result.push(item.id);
    if (Array.isArray(item.children)) {
      dfs(item.children);
    }
  });
}

dfs(tree);

console.log('result', result);
```

- 请找出这两个有序数组的中位数。

```ts
let nums1 = [1, 2];
let nums2 = [3, 4];

let unitonArr = [...nums1, ...nums2].sort((a, b) => a - b);

unitonArr = [...new Set(unitonArr)];

let len = unitonArr.length;
let middle = 0;
index = Math.floor(len / 2);
if (len % 2) {
  middle = unitonArr[index];
} else {
  middle = (unitonArr[index] + unitonArr[index - 1]) / 2;
}

console.log(middle);
```

- 不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串

```ts
/**
 * 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。
 * 如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，
 * 不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。
 */
function fun(int) {
  let intstrArr = typeof int === 'number' ? [...String(int)] : [...int];
  if (!intstrArr.length) return '';
  let resultstr = intstrArr.pop();
  let intstr = intstrArr.join('');
  resultstr += fun(intstr);
  return resultstr;
}

console.log(fun(1234));
```

- 顺序输出 n 的值

```ts
function print(n) {
  setTimeout(
    (() => {
      console.log(n);
    })(),
    Math.floor(Math.random() * 1000)
  );
}

for (var i = 0; i < 100; i++) {
  print(i);
}
```

- 不用加减乘除运算符，求整数的 7 倍

```ts
// 左移3位 相当于乘8 然后再减去自己 不就是7倍了吗 减法的移位运算可以转换加法的移位运算
function getSevenNum(n = 0) {
  return (n << 3) - n;
}

console.log(getSevenNum(), getSevenNum(1), getSevenNum(11));
```

## 获取连接的参数

```ts
new URLSearchParams(
  'https://www.xx.cn/api?keyword=&level1=&local_batch_id=&elective=800,700&local_province_id=33'
).get('elective'); // "800,700"
```

## 随机洗牌算法

```ts
function shuffle(array) {
  return array.sort(function () {
    return Math.random() - 0.5;
  });
}
```

## 如果连续数字的话，就取连续的第一个数和最后一个数，中间用~隔开。如果不连续就用，隔开

```ts
/**
 * 输入 '1, 2, 3, 5, 7, 8, 10' 输出 '1~3, 5, 7~8, 10'
 */
let arr = [1, 2, 3, 5, 7, 8, 10];
let midarr = [];
let resultarr = [];

for (let i = 0; i < arr.length; i++) {
  let curr = arr[i];
  let midlast = midarr[midarr.length - 1];

  if (midlast !== curr - 1 && typeof midlast === 'number') {
    let selize = `${midarr[0]} ~ ${midlast}`;
    resultarr.push(selize, curr);

    midarr = [];
  } else {
    midarr.push(curr);
  }
}

console.log('resultarr', resultarr);
```

- 对象树形结构转换

```ts
var entry = {
  a: {
    b: {
      c: {
        dd: 'abcdd',
      },
    },
    d: {
      xx: 'adxx',
    },
    e: 'ae',
  },
};

// 要求转换成如下对象
// var output = {
//   'a.b.c.dd': 'abcdd',
//   'a.d.xx': 'adxx',
//   'a.e': 'ae',
// };

const result = flatObj(entry);

console.log(result);

function flatObj(obj, parentKey = '', result = {}) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      let keyName = `${parentKey}${key}`;
      if (typeof obj[key] === 'object') {
        flatObj(obj[key], keyName + '.', result);
      } else {
        result[keyName] = obj[key];
      }
    }
  }
  return result;
}
```

- 对象树形结构和上面的题反过来

```ts
var entry = {
  'a.b.c.dd': 'abcdd',
  'a.d.xx': 'adxx',
  'a.e': 'ae',
};

// 要求转换成如下对象
var output = {
  a: {
    b: {
      c: {
        dd: 'abcdd',
      },
    },
    d: {
      xx: 'adxx',
    },
    e: 'ae',
  },
};

/**
 *
 * @param {Object} target 展开的key所插入的目标对象
 * @param {Array} key 剩余需展开的key的数组
 * @param {String} value 最终的值
 */
const transform = (target = {}, key = [], value = 0) => {
  if (!key.length) return; // 终止递归
  const currentKey = key.splice(0, 1); // 截取当前首位key
  if (!target[currentKey]) {
    target[currentKey] = key.length === 0 ? value : {}; // 若当前属性为首次出现，则在对应深度创建该属性并赋值为空对象；若无剩余展开key时赋值
  }
  transform(target[currentKey], key, value); // 进入下一次递归
};

const result = {}; // 结果容器
const keys = Object.keys(entry); // 对象所需展开的字符串key
keys.map((item) => transform(result, item.split('.'), entry[item]));
console.log(result);
```

- 匹配连续的多个字符串

```ts
var str1 = 'AAAm99';
var reg = /(\w)\1*/g;
var res = str1.match(reg); //输出: ["AAA", "m", "99"]
```

- 找出字符串中连续出现最多的字符和个数

```ts
// 'abcaakjbb' => {'a':2,'b':2}
// 'abbkejsbcccwqaa' => {'c':3}
const arr = str.match(/(\w)\1*/g);
const maxLen = Math.max(...arr.map((s) => s.length));
const result = arr.reduce((pre, curr) => {
  if (curr.length === maxLen) {
    pre[curr[0]] = curr.length;
  }
  return pre;
}, {});

console.log(result);
```

- 统计 1 ~ n 整数中出现 1 的次数

```ts
/**
 * 1到11的时候 1、10、11这种 其实就算4次了
 */
function findOne(n) {
  let count = 0;
  for (let i = 0; i <= n; i++) {
    count += String(i)
      .split('')
      .filter((item) => item === '1').length;
  }
  return count;
}
```

- 扑克牌问题

```ts
/**
 * 逆向：即从桌牌到手牌
 * @param {*} 桌牌序列 arr
 */
function recover(arr) {
  const res = [];
  while (arr.length > 0) {
    if (res.length) {
      res.push(res.shift());
    }
    const item = arr.pop();
    res.push(item);
  }
  return res;
}

/**
 * 正向：即从手牌到桌牌（用于检验结果）
 * @param {*} 手牌序列arr
 */
function generate(arr) {
  const res = [];
  while (arr.length > 0) {
    const item = arr.pop();
    res.push(item);
    if (arr.length) {
      arr.unshift(arr.pop());
    }
  }
  return res;
}

recover([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]); // [7, 10, 6, 13, 5, 9, 4, 11, 3, 8, 2, 12, 1]
generate([7, 10, 6, 13, 5, 9, 4, 11, 3, 8, 2, 12, 1]); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
```

- 求两个日期间的有效日期

```ts
function getDays(start, end) {
  let startTime = new Date(start);
  let endTime = new Date(end);
  let days = [];
  while (startTime <= endTime) {
    days.push(
      startTime.getFullYear() +
        '-' +
        (startTime.getMonth() + 1) +
        '-' +
        startTime.getDate()
    );
    startTime.setDate(startTime.getDate() + 1);
  }
  return days;
}

getDays('2015-2-8', '2015-3-3');
```

- 排序问题

```ts
/**
 * 使得排序后数组中球的顺序为:黄、红、蓝。
 * 例如：红蓝蓝黄红黄蓝红红黄红，排序后为：黄黄黄红红红红红蓝蓝蓝。
 */
/**
 * 根据order的顺序对数据排序
 * @param arr 排序数组
 * @param order 排序内容order
 */
function cunstomSort(arr, order) {
  return arr.sort((a, b) => order.indexOf(a) - order.indexOf(b));
}

console.log(
  cunstomSort('红蓝蓝黄红黄蓝红红黄红'.split(''), ['红', '黄', '蓝'])
);
```

- 链表的翻转问题

```ts
/**
 * 翻转整个链表 1->2->3->4->null -> 4->3->2->1->null
 */
function reverseList(head) {
  if (!head || !head.next) return head;

  let cur = head;
  let pre = null;
  while (cur) {
    cur.next = pre;
    pre = cur;
    cur = cur.next;
  }

  return pre;
}
```

- 求多个数组之间的交集

```ts
const arr1 = [1, 2, 3];
const arr2 = [3, 4, 5];
const arr3 = [3, 6, 7];
const handle = (...arr) => {
  return arr.reduce((rst, ele, i) => {
    return rst.filter((item) => ele.includes(item));
  });
};

handle(arr1, arr2, arr3);
```

- 千分位展示法

```ts
// 将 '10000000000' 形式的字符串，以每 3 位进行分隔展示 '10.000.000.000'

/**
 * 第一种解法
 */
var myNum = Number('10000000000'); //字符串转数字后就可以使用toLocaleString()啦
var num2Str = myNum.toLocaleString(); //"10,000,000,000"
var str = num2Str.replace(/,/g, '.'); //"10.000.000.000"

/**
 * 常规解法
 */
var reg = /(\B)(?=(\d{3})+$)/g;
console.log('1000000000'.replace(reg, ',')); // 1.000.000.000
```

- 二分搜索法代码

```ts
var search = function (nums, target) {
  let left = 0;
  let right = nums.length - 1;
  while (left <= right) {
    let mid = Math.floor(left + (right - left) / 2);
    if (nums[mid] === target) {
      return mid;
    } else if (target < nums[mid]) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
};
```
