## 浏览器盒模型

```ts
/**
 * 就是用来装页面上的元素的矩形区域。CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型
 * 包含里content padding border margin
 *
 * W3C盒子模型在标准的盒子模型中，width指content部分的宽度，
 * 在IE盒子模型中，width表示content+padding+border这三个部分的宽度
 *
 * 在CSS3中引入了box-sizing属性，
 * box-sizing：border-box,padding-box,content-box.
 * box-sizing:content-box;表示标准的盒子模型，
 * box-sizing:border-box表示的是IE盒子模型
 */
```

## JS 的数据类型有哪些

```ts
/**
 * JS的数据类型
 * number,string,boolean,undefined,object,null,symbol
 *
 * 其中Object包含的数据类型
 * Date、Function、Array 、Set、Map、WeakSet,WeakMap
 */
```

## 作用域链和闭包

```ts
/**
 * 假设在全局中定义了变量c,函数a,函数a里面还定义了函数b,并且函数b会在a里面执行,在全局中执行a函数;
 *
 * 当a函数被定义的时候,系统生成[[scope]]属性,[[scope]]保存a函数的作用域链
 * 该作用域链的第0位储存当前环境下的全局执行期上下文GO
 * GO里存储全局上下文的所有对象,其中包含函数a和全局变量c
 *
 * a函数被执行的前一刻
 * 会创建a函数的AO即活跃对象函数执行上下文,并把它压入到a函数作用域链的顶端
 * 寻找形参和变量声明,实参赋值给形参,变量初始化为undefined,找函数声明并赋值，也就是变量和函数声明提升的过程
 * 并把它们添加为AO的属性,确定this指向
 *
 * 然后a函数进入执行阶段
 * 此时b函数被定义,会生成b函数[[scope]]属性,保存b函数的作用域链,此时b函数的作用域链和a函数是一样的
 * 在a函数的执行过程中查找变量是到a函数存储的作用域链中从顶端开始依次向下查找即先从a函数的AO找,找不到再去GO里面找
 * 当遇到b函数,在b函数被执行的前一刻,会创建b函数的AO,并把它压入到b函数作用域链的顶端
 * b函数执行过程中的变量查找顺序也是从 作用域的链上从上往下查找
 *
 * a函数执行结束
 * 当a函数被执行结束时,a函数的AO被销毁的同时,b函数的[[scope]]也将不存在
 * a函数回归到被定义时的状态
 *
 * 关于闭包
 * 如果a函数执行完毕后把b函数返回,并被全局变量d接收,此时a函数的AO被不会被销毁,它还连在b函数的作用域链上,b函数被保存在全局作用域上
 * 当b函数在外部执行的时候,会把自己的AO添加到作用域链上,当b执行结束的时候,它的AO会被销毁,但是a函数的AO依然在b函数的作用域链上
 *
 * 总结:
 * 当内部函数被返回到外部并保存时,一定会产生闭包,闭包会产生原来的作用域链不释放，过度的闭包可能会导致内存泄漏,或加载过慢
 *
 */

// 作用域链演示
var c = 1;
function a() {
  function b() {}
  b();
}
a();

// 闭包示例
var c = 1;
function a() {
  return function b() {};
}
let d = a();
```

## 原型链及继承

```ts
/**
 * 创建一个构造函数A
 * 此时A上面会有一个__proto__,即原型链,指向Function.prototype,
 * 而Function.prototype的原型指向Object.prototype,Object.prototype最终指向null
 * 在A的原型对象上定义的属性和方法称为原型属性和原型方法
 * A的实例上定义的属性和方法称为实例属性和实例方法,即A构造函数里this.xx=xx;会隐式返回this
 *
 * 同时A上面还有一个prototype属性,指向它的原型对象
 * 原型对象里面有一个constructor属性指向链它自己，__proto__指向了Object.prototype
 *
 * 当实例化这个构造函数A的时候,例如let a = new A()；会生产a的实例对象
 * a实例对象的__proto__,即原型链指向了构造函数A的原型对象,即A.prototype
 *
 * 如在a实例对象上寻找某个属性的时候,会向从a自身找,找不到就会在a的原型链上找,直到原型链的顶端,找不到就会返回undefined
 * 原型链的顶端是Object.prototype
 *
 * ES5继承
 * 有一个构造函数A,和一个构造函数B,可以使用圣杯模式继承的方式实现B对A的继承
 * 第一步对原型方法和原型属性的继承
 * 通过Object.create以A函数的原型对象即A.prototype为原型,创建一个对象
 * 然后把B函数的prototype即原型对象指向这个对象,并把constructor指向自己,可以实现对A的原型属性和原型方法的继承
 * 第二步对实例属性和实例方法的继承
 * 通过在B里面执行 A.apply(this, args);通过对象替换的方式实现对A实例属性和方法的继承
 *
 *
 */

/**
 * 寄生组合式继承(圣杯模式)
 */
function User(name) {
  this.name = name;
}

function Admin(...args) {
  User.call(this, ...args); // 继承实例属性
}

Admin.prototype = Object.create(User.prototype); // 继承原型方法
let hd = new Admin('后盾人');
console.log(hd);

/**
 * ES6的继承
 * 1.Class之间通过使用extends关键字实现继承
 * 2.子类必须在constructor方法中调用super方法，否则新建实例时会报错
 * 3.这是因为子类没有自己的this对象，而是父类构造函数创建出this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象
 * 4.因此，只有调用super之后，才可以使用this关键字。
 */
class B {}
class A extends B {
  constructor() {
    super();
  }
}
A.__proto__ === B; // 继承实例属性
A.prototype.__proto__ == B.prototype; // 继承原型方法

/**
 * ES5与ES6继承的区别
 * ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。
 * Sub.__proto__ === Function.prototype;
 *
 * ES6的继承
 * 子类必须在constructor方法中调用super方法，否则新建实例时会报错。
 * 这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，
 * 然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。
 *
 * ES6 的继承机制实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法）
 * 然后再用子类的构造函数修改this。
 * Sub.__proto__ === Super;
 */
```

## GET 请求和 POST 请求的区别

```ts
/**
 * 1、GET在浏览器回退时是无害的，而POST会再次提交请求。
 * 2、GET产生的URL地址可以被Bookmark，而POST不可以。
 * 3、GET请求会被浏览器主动cache，而POST不会，除非手动设置。
 * 4、GET请求的参数会完整的被保存在历史记录里，POST不会。
 * 5、GET请求参数放在URL中，POST放在request body中。
 * 6、GET请求只能进行url编码，POST请求支持多种编码方式。
 * 7、对于参数类型，GET只接受ASCII字符，而POST没有限制。
 * 8、GET请求在URL中传递的参数是有长度限制的，而POST没有。
 * 9、GET比POST更不安全，因为参数直接暴露在URL中，所以不能传递敏感信息。
 * 10.GET产生一个TCP数据包；POST产生两个TCP数据包。
 * 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
 * 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
 * 响应码100表示Continue继续。客户端应继续其请求
 */
```

## 在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么

```ts
/**
 *
 * 精简版回答:
 * 1.DNS解析
 * 2.TCP连接
 * 3.发送HTTP请求
 * 4.服务器处理请求并返回HTTP报文
 * 5.浏览器解析渲染页面
 * 6.连接结束
 *
 * 详细回答
 * 输入url后，
 * 1.首先需要找到这个url域名的服务器ip,为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，
 * 缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，
 *
 * 2.得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，
 * 请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，
 * 服务器解析这个请求来作出响应，返回相应的html给浏览器，
 * 3.因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树
 * 来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部样式，内部样式，内联样式
 * 构建一个CSS对象模型树CSSOM树，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除
 * display为none的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，
 * 3.因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，
 * 4.当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。
 * Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器端的绝对时间，因为存在时差问题，
 * 一般采用Cache-Control，在请求这些有设置了缓存的数据时，会先 查看是否过期，如果没有过期则直接使用本地缓存，
 * 过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，
 * 如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304
 */
```

## 浏览器的渲染原理

```ts
/**
 * 浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树
 * 来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部样式，内部样式，内联样式
 * 构建一个CSS对象模型树CSSOM树，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除
 * display为none的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，
 * 因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，
 */
```

## var、let 和 const 区别的实现原理是什么

```ts
/**
 * 区别
 * 1.var与let是可以声明变量，const不能声明变量，只能声明只读的常量。
 * 2.var声明的变量不存在块级作用域，他在全局内有效。let与const的声明只在其所在的代码块中有效。
 * 3.let/const不能在同一个作用域中声明相同变量/常量，var可以多次重复声明。
 * 4.var能先使用在声明，但是let const必须先声明再使用。
 * 5.let/const存在暂时性死区(所谓暂时死区，就是不能在初始化之前，使用变量 不然会报错)
 * Script snippet %236:5 Uncaught ReferenceError: Cannot access 'a' before initialization
 * 6.const声明时必须初始化赋值，一旦声明，其声明赋值的值就不允许改变，更不可以重复声明。
 * 如 const 声明了一个复合类型的常量，其存储的是一个引用地址，不允许改变的是这个地址，而对象本身是可变的。
 *
 *
 * 原理
 * var
 * 会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量
 * 如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针。
 *
 * let
 * 是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错。
 *
 * const
 * 也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。
 * 不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值
 * 对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性
 *
 *
 * 关于变量的提升
 * 1.let 的「创建」过程被提升了，但是初始化没有提升。
 * 2.var 的「创建」和「初始化」都被提升了。
 * 3.function 的「创建」「初始化」和「赋值」都被提升了。
 * 4.const 只有「创建」和「初始化」，没有「赋值」过程。
 *
 */
```

## 箭头函数与普通函数的区别

```ts
// 箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？

/**
 *
 * 普通函数与箭头函数的this指向
 * 1.普通函数的this：指向它的调用者，如果没有调用者则默认指向window.严格模式下指向undefined
 * 2.箭头函数的this: 指向箭头函数定义时所处的对象，而不是箭头函数使用时所在的对象，默认使用父级的this.
 * 箭头函数中的this,首先从它的父级作用域中找，如果父级作用域还是箭头函数，再往上找，如此直至找到this的指向
 *
 * 箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：
 * 1、函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。
 * 2、不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
 * 3、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。
 * 4、不可以使用 new 命令，因为：
 * 没有自己的 this，无法调用 call，apply。
 * 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 __proto__
 */

// new 的过程
function newFunc(father, ...rest) {
  var result = {};
  result.__proto__ = father.prototype;
  var result2 = father.apply(result, rest);
  if (
    (typeof result2 === 'object' || typeof result2 === 'function') &&
    result2 !== null
  ) {
    return result2;
  }
  return result;
}

/** 在全局中这么写this指向Window */

let a = {
  type: 'aaa',
  b: () => {
    console.log('b', this); // this指向Window
  },
};
a.b();

/**  this指向类  */
class B {
  obj = {
    b: () => {
      console.log('bbbb', this); // this指向B
    },
  };
}

let b = new B();

b.obj.b();
```

## 事件循环

```ts
/**
 * 单线程就意味着,同一时间只能处理一个任务,所有任务需要排队,前一个任务结束,才会执行后一个任务
 * 任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。
 * 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
 * 异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务,异步任务可以分为宏任务和微任务
 * 宏任务主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI 交互事件，setImmediate
 * 微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)
 * 宏任务会进入宏任务队列,微任务会进入微任务队列
 *
 * 当主线程空闲的时候,会通过事件循环,先读取的微任务，放入主线程中执行，当微任务队列清空后，
 * 再取宏任务队列里取出宏任务执行,周而复始，直至两个队列的任务都取完。
 *
 *
 * 例如setTimeout的回调函数会先交给对应的事件处理模块处理,等时间到的时候会把对应的事件加入到任务队列中,通过事件循环推入到主线程中去执行。
 *
 */
```

## HTTP/1.0 、HTTP/1.1 、HTTP/2.0

```ts
/**
 * 目前共有三种协议分别是HTTP/1.0 、HTTP/1.1 、HTTP/2.0，其中HTTP/1.1是主流
 *
 * HTTP的基本优化基本思路
 * 1.浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。
 * 浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），
 * 超过浏览器最大连接数限制，后续请求就会被阻塞。
 * 2.DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。
 * 3.建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在
 * 第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，
 *
 * HTTP1.0和HTTP1.1的一些区别
 * HTTP1.0最早在网页中使用是在1996年
 * HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议
 * 1.HTTP1.1引入更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match
 * 等更多可供选择的缓存头来控制缓存策略
 * 2.带宽优化及网络连接的使用
 * HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分
 * 3.错误通知的管理
 * 在HTTP1.1中新增了24个错误状态响应码
 * 4.Host头处理
 * 在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址
 * HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
 * 5.长连接
 * HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，
 * 减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，
 * 一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
 *
 *
 *
 * HTTPS与HTTP的一些区别
 * 1.HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
 * 2.HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
 * 3.HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
 * 4.HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。
 *
 * HTTP2.0
 * 1.HTTP2.0的协议解析决定采用二进制格式
 * 2.多路复用（MultiPlexing），即连接共享
 * 3.header压缩
 * 4.服务端推送,推送js,css等资源而不用每次都要客户端去请求
 *
 *
 * 现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。
 * HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的
 *
 * HTTP2.0的多路复用
 * HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；
 */
```

## 单词

```pug
quality 质量
```
