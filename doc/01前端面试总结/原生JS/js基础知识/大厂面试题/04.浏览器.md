## 浏览器

## 介绍下重绘和回流（Repaint & Reflow），以及如何进行优化

```ts
/**
 * 不可见的节点包括
 * 一些不会渲染输出的节点，比如script、meta、link等。
 * 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。
 *
 * Repaint（重绘）：
 * 如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。
 *
 * 发生Reflow回流的情况
 * 当页面布局和几何信息发生变化的时候，就需要回流
 * 根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，
 * 有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。
 * 1.添加或删除可见的DOM元素
 * 2.元素的位置发生变化
 * 3.元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
 * 4.内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
 * 5.页面一开始渲染的时候（这肯定避免不了）
 * 6.浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
 *
 * 浏览器的优化机制
 * 浏览器通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。
 * 当你获取布局信息的操作的时候，会强制队列刷新
 * offsetTop、offsetLeft、offsetWidth、offsetHeight
 * scrollTop、scrollLeft、scrollWidth、scrollHeight
 * clientTop、clientLeft、clientWidth、clientHeight
 * getComputedStyle()
 * getBoundingClientRect
 */

// 减少回流和重绘
// 合并多次对DOM和样式的修改，然后一次处理掉

const el = document.getElementById('test');
el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;';

// 批量修改DOM
// 使元素脱离文档流
// 对其进行多次修改
// 将元素带回到文档中。
// 隐藏元素，应用修改，重新显示
function appendDataToElement(appendToElement, data) {
  let li;
  for (let i = 0; i < data.length; i++) {
    li = document.createElement('li');
    li.textContent = 'text';
    appendToElement.appendChild(li);
  }
}
const ul = document.getElementById('list');
ul.style.display = 'none';
appendDataToElement(ul, data);
ul.style.display = 'block';

// 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档
const ul = document.getElementById('list');
const fragment = document.createDocumentFragment();
appendDataToElement(fragment, data);
ul.appendChild(fragment);

// 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素
const ul = document.getElementById('list');
const clone = ul.cloneNode(true);
appendDataToElement(clone, data);
ul.parentNode.replaceChild(clone, ul);

// 对于复杂动画效果,使用绝对定位让其脱离文档流
// css3硬件加速（GPU加速）
// 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。
/**使用3d效果来开启硬件加速**/
.speed-up {
   -webkit-transform: translate3d(250px,250px,250px)
   rotate3d(250px,250px,250px,-120deg)
   scale3d(0.5, 0.5, 0.5);
}
```

## 浏览器缓存读取规则

```ts
/**
 * 
 * 缓存的优先级
 * 1.Service Worker
 *   这个缓存是永久性的，即关闭 TAB 或者浏览器，下次打开依然还在
 *   有两种情况会导致这个缓存中的资源被清除：
 *   手动调用 API cache.delete(resource) 或者容量超过限制，被浏览器全部清空。
 * 
 *   如果 Service Worker 没能命中缓存，一般情况会使用 fetch() 方法继续获取资源。
 *   这时候，浏览器就去 memory cache 或者 disk cache 进行下一次找缓存的工作了。
 *   注意：经过 Service Worker 的 fetch() 方法获取的资源，
 *   即便它并没有命中 Service Worker 缓存，甚至实际走了网络请求，也会标注为 from ServiceWorker。

 * 
 * 2.Memory Cache(memory cache 是内存中的缓存)
 *   浏览器的 TAB 关闭后该次浏览的 memory cache 便告失效
 *   <link rel="preload"> 显式指定的预加载资源，也会被放入 memory cache 中
 *   匹配缓存时，除了匹配完全相同的 URL 之外，还会比对他们的类型，CORS 中的域名规则等
 *   浏览器会忽视例如 max-age=0, no-cache 等头部配置
 *   例如页面上存在几个相同 src 的图片，即便它们可能被设置为不缓存，但依然会从 memory cache 中读取。
 *   使用 no-store 不让一个资源进入缓存，就连短期也不行
 * 
 * 3.Disk Cache(disk cache 就是硬盘上的缓存)
 *   会严格根据 HTTP 头信息中的各类字段来判定哪些资源可以缓存
 *   浏览器会根据一段的算法进行定期的清理
 *   也叫 HTTP cache (因为不像 memory cache，它遵守 HTTP 协议头中的字段)。
 *   平时所说的强制缓存，对比缓存，以及 Cache-Control 等，也都归于此类
 * 
 *   强制缓存
 *   可以造成强制缓存的字段是 Cache-control 和 Expires
 *   强制缓存的含义是，当客户端请求后，会先访问缓存数据库看缓存是否存在。
 *   如果存在则直接返回；不存在则请求真的服务器，响应后再写入缓存数据库。
 * 
 *   对比缓存 (也叫协商缓存)
 *   当强制缓存失效(超过规定时间)时，就需要使用对比缓存，由服务器决定缓存内容是否失效。
 *   浏览器先请求缓存数据库，返回一个缓存标识。之后浏览器拿这个标识和服务器通讯
 *   如果缓存未失效，则返回 HTTP 状态码 304 表示继续使用，于是客户端继续使用缓存；
 *   如果失效，则返回新的数据和缓存规则，浏览器响应数据后，再把规则写入到缓存数据库。
 *   如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此 在响应体体积上的节省是它的优化点
 * 
 *   Last-Modified & If-Modified-Since
 *   服务器通过 Last-Modified 字段告知客户端，资源最后一次被修改的时间
 *   浏览器将这个值和内容一起记录在缓存数据库中
 *   下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。
 *   因此在请求头中将上次的 Last-Modified 的值写入到请求头的 If-Modified-Since 字段
 *   服务器会将 If-Modified-Since 的值与 Last-Modified 字段进行对比。
 *   如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。
 * 
 *   Etag & If-None-Match
 *   Etag 存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的 Etag 字段。
 *   因此在请求头中将上次的 Etag 的值写入到请求头的 If-None-Match字段
 *   Etag 的优先级高于 Last-Modified
 * 
 * 4.网络请求
 *   为了提升之后请求的缓存命中率，自然要把这个资源添加到缓存中去
 *   根据 Service Worker 中的 handler 决定是否存入 Cache Storage (额外的缓存位置)
 *   根据 HTTP 头部的相关字段(Cache-control, Pragma 等)决定是否存入 disk cache
 *   memory cache 保存一份资源 的引用，以备下次使用。
 * 
 * 
 * Cache-control 字段常用的值
 * 1.max-age：即最大有效时间，在上面的例子中我们可以看到
 * 2.must-revalidate：如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。
 * 3.no-cache：虽然字面意思是“不要缓存”，但实际上还是要求客户端缓存内容的，只是是否使用这个内容由后续的对比来决定。
 * 4.no-store: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。
 * 5.public：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)
 * 6.private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。

 * 
 * 当浏览器要请求资源时
 * 调用 Service Worker 的 fetch 事件响应
 * 查看 memory cache
 * 查看 disk cache。这里又细分：
 *   1.如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200
 *   2.如果有强制缓存但已失效，使用对比缓存，比较后确定 304 还是 200
 * 发送网络请求，等待网络响应
 * 把响应内容存入 disk cache (如果 HTTP 头信息配置可以存的话)
 * 把响应内容 的引用 存入 memory cache (无视 HTTP 头信息的配置)
 * 把响应内容存入 Service Worker 的 Cache Storage (如果 Service Worker 的脚本调用了 cache.put())
 * 
 * 
 * 浏览器的行为
 * 所谓浏览器的行为，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：
 * 1.打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
 * 2.普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
 * 3.强制刷新 (Ctrl + F5)：浏览器不使用缓存，
 * 因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache)。服务器直接返回 200 和最新内容。

 */
```

- service worker

```ts
/**
 * 一个服务器与浏览器之间的中间人角色，如果网站中注册了service worker那么它可以拦截当前网站所有的请求，
 * 进行判断（需要编写相应的判断程序），如果需要向服务器发起请求的就转给服务器，
 * 如果可以直接使用缓存的就直接返回缓存不再转给服务器。从而大大提高浏览体验
 * 可以访问cache和indexDB
 * 支持推送
 * 并且可以让开发者自己控制管理缓存的内容以及版本
 */

// 注册Service worker 在你的index.html加入以下内容
/* 判断当前浏览器是否支持serviceWorker */
if ('serviceWorker' in navigator) {
  /* 当页面加载完成就创建一个serviceWorker */
  window.addEventListener('load', function () {
    /* 创建并指定对应的执行内容 */
    /* scope 参数是可选的，可以用来指定你想让 service worker 控制的内容的子目录。 在这个例子里，我们指定了 '/'，表示 根网域下的所有内容。这也是默认值。 */
    navigator.serviceWorker
      .register('./serviceWorker.js', { scope: './' })
      .then(function (registration) {
        console.log(
          'ServiceWorker registration successful with scope: ',
          registration.scope
        );
      })
      .catch(function (err) {
        console.log('ServiceWorker registration failed: ', err);
      });
  });
}

// 安装worker：在我们指定的处理程序serviceWorker.js中书写对应的安装及拦截逻辑
/* 监听安装事件，install 事件一般是被用来设置你的浏览器的离线缓存逻辑 */
this.addEventListener('install', function (event) {
  /* 通过这个方法可以防止缓存未完成，就关闭serviceWorker */
  event.waitUntil(
    /* 创建一个名叫V1的缓存版本 */
    caches.open('v1').then(function (cache) {
      /* 指定要缓存的内容，地址为相对于跟域名的访问路径 */
      return cache.addAll(['./index.html']);
    })
  );
});

/* 注册fetch事件，拦截全站的请求 */
this.addEventListener('fetch', function (event) {
  event.respondWith(
    // magic goes here

    /* 在缓存中匹配对应请求资源直接返回 */
    caches.match(event.request)
  );
});
```

## 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片

```ts
/**
 * 能够完成整个 HTTP 请求+响应
 * 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据
 * 跨域友好
 * 执行过程无阻塞
 * 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好
 * GIF的最低合法体积最小（最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节）
 * 不会阻塞页面加载，影响用户的体验，只要new Image对象就好了；（排除JS/CSS文件资源方式上报）
 */
```
