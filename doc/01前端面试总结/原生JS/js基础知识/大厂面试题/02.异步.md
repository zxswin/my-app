## setTimeout、Promise、Async/Await 的区别

```ts
/**
 * 事件循环中的执行顺序
 * 同步 > 异步
 * 微任务 > 宏任务
 *
 * 什么是微任务和宏任务
 * 微任务：Promise，process.nextTick。
 * 宏任务：整体代码script，setTimeout，setInterval
 *
 * settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；
 * promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；
 * async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，
 * 等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。
 *
 * 谈谈对 async/await 的理解，async/await 的实现原理是什么?
 * 1）async/await 就是 Generator 的语法糖，使得异步操作变得更加方便
 * 2）async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成await
 * 3）async 是 Generator 的语法糖
 * 4）async/await 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里
 */
```

## Async/Await 如何通过同步的方式实现异步

- 遍历器（Iterator）

```ts
/**
 * 任何数据结构只要部署 Iterator 接口，就可以完成遍历操作
 * Iterator 的遍历过程是这样的
 * 1.创建一个指针对象，指向当前数据结构的起始位置。
 * 2.第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员
 * 3.第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。
 * 4.不断调用指针对象的next方法，直到它指向数据结构的结束位置。
 *
 * 每一次调用next方法，都会返回数据结构的当前成员的信息
 * 返回一个包含value和done两个属性的对象
 * value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束
 */

/* 模拟next方法返回值 */
var it = makeIterator(['a', 'b']);

it.next(); // { value: "a", done: false }
it.next(); // { value: "b", done: false }
it.next(); // { value: undefined, done: true }

function makeIterator(array) {
  var nextIndex = 0;
  return {
    next: function () {
      return nextIndex < array.length
        ? { value: array[nextIndex++], done: false }
        : { value: undefined, done: true };
    },
  };
}

/**
 * 当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口
 * 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。
 * 默认的 Iterator 接口部署在数据结构的Symbol.iterator属性
 * Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。
 * 执行这个函数，就会返回一个遍历器。
 *
 * 原生具备 Iterator 接口的数据结构如下。
 * Array
 * Map
 * Set
 * String
 * TypedArray
 * 函数的 arguments 对象
 * NodeList 对象
 *
 * 如果Symbol.iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。
 */

// 对象obj是可遍历的（iterable），因为具有Symbol.iterator属性。
const obj = {
  [Symbol.iterator]: function () {
    return {
      next: function () {
        return {
          value: 1,
          done: true,
        };
      },
    };
  },
};

/**
 * 调用 Iterator 接口的场合
 * 1.对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。
 * 2.扩展运算符（...）也会调用默认的 Iterator 接口。
 * 3.只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组
 */

/* yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 */
let generator = function* () {
  yield 1;
  yield* [2, 3, 4];
  yield 5;
};

var iterator = generator();

iterator.next(); // { value: 1, done: false }
iterator.next(); // { value: 2, done: false }
iterator.next(); // { value: 3, done: false }
iterator.next(); // { value: 4, done: false }
iterator.next(); // { value: 5, done: false }
iterator.next(); // { value: undefined, done: true }

/**
 * 遍历器对象除了具有next()方法，还可以具有return()方法和throw()方法
 * return()方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return()方法。
 */
```

```ts
/**
 * ES6 Iterator为何存在
 * ◆ES6语法中,有序集合的数据类型已经有很多
 * ◆Array Map Set String TypedArray arguments NodeList
 * ◆需要有一个统一的遍历接口来遍历所有数据类型
 * ◆(注意, object不是有序集合,可以用Map代替)
 *
 *
 * ES6 Iterator是什么?
 * ◆ 以上数据类型,都有[Symbol.iterator] 属性
 * ◆ 属性值是函数,执行函数返回一个迭代器
 * ◆ 这个迭代器就有next方法可顺序迭代子元素
 *
 * 可运行Array.prototype[Symbol.iterator] 来测试
 */

function each(data) {
  // 生产遍历器
  let iterator = data[Symbol.iterator]();

  let item = { done: false };

  while (!item.done) {
    item = iterator.next();
    if (!item.done) {
      console.log(item.value);
    }
  }
}

// 测试代码
let arr = [1, 2, 3, 4];

each(arr);
```

- Generator 函数

```ts
/**
 * 将return语句后面的表达式的值，作为返回的对象的value属性值
 * 由于next方法的参数表示上一个yield表达式的返回值，
 * 所以在第一次使用next方法时，传递参数是无效的。
 * 如果不带参数则返回值为undefined
 */
function* foo(x) {
  var y = 2 * (yield x + 1);
  var z = yield y / 3;
  return x + y + z;
}

var a = foo(5);
a.next(); // Object{value:6, done:false}
a.next(); // Object{value:NaN, done:false}
a.next(); // Object{value:NaN, done:true}

var b = foo(5);
b.next(); // { value:6, done:false }
b.next(12); // { value:8, done:false }
b.next(13); // { value:42, done:true }  5 + 24 + 13 = 42

/**
 * yield* 表达式
 * yield*表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数
 */
function* bar() {
  yield 'x';
  yield* foo();
  yield 'y';
}

// 等同于
function* bar() {
  yield 'x';
  yield 'a';
  yield 'b';
  yield 'y';
}

/**
 * Generator 函数的this
 * 遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法
 * Generator 函数也不能跟new命令一起用，会报错
 */

// g返回的总是遍历器对象，而不是this对象。
function* g() {
  this.a = 11;
}

let obj = g();
obj.next();
obj.a; // undefined

// 让 Generator 函数返回一个正常的对象实例
function* F() {
  this.a = 1;
  yield (this.b = 2);
  yield (this.c = 3);
}
var obj = {};
var f = F.call(obj);

f.next(); // Object {value: 2, done: false}
f.next(); // Object {value: 3, done: false}
f.next(); // Object {value: undefined, done: true}

obj.a; // 1
obj.b; // 2
obj.c; // 3

/**
 * 由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。
 * 将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用yield表达式交换控制权
 *
 * Generator 与上下文
 * Generator 函数不是这样，它执行产生的上下文环境，一旦遇到yield命令，
 * 就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。
 * 等到对它执行next命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。
 */

// 通过 Generator 函数部署 Ajax 操作
function* main() {
  var result = yield request('http://some.url');
  var resp = JSON.parse(result);
  console.log(resp.value);
}

function request(url) {
  makeAjaxCall(url, function (response) {
    it.next(response); // 返回上一个yield的返回值
  });
}

var it = main();
it.next();
```

- Generator 执行器

```ts
/**
 * Thunk 函数的 Generator 执行器
 */
function run(fn) {
  var gen = fn();

  function next(err, data) {
    var result = gen.next(data);
    if (result.done) return;
    result.value(next); // result.value 接收一个回调函数作为参数
  }

  next();
}

function* g() {
  // ...
}

run(g);

/**
 * co 模块 实现Generator 执行器
 */

// 首先，把fs模块的readFile方法包装成一个 Promise 对象
var fs = require('fs');

var readFile = function (fileName) {
  return new Promise(function (resolve, reject) {
    fs.readFile(fileName, function (error, data) {
      if (error) return reject(error);
      resolve(data);
    });
  });
};

var gen = function* () {
  var f1 = yield readFile('/etc/fstab');
  var f2 = yield readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};

// co 模块 实现Generator 执行器
function run(gen) {
  var g = gen();

  function next(data) {
    var result = g.next(data);
    if (result.done) return result.value;
    result.value.then(function (data) {
      next(data);
    });
  }

  next();
}

run(gen);
```

- async 函数

```ts
/**
 * async 函数是 Generator 函数的语法糖。
 * async函数对 Generator 函数的改进，体现在以下四点。
 * 1.内置执行器。
 * 2.更好的语义
 * 3.更广的适用性。
 * 4.返回值是 Promise。
 * async函数完全可以看作多个异步操作，包装成的一个 Promise 对象
 * 而await命令就是内部then命令的语法糖。
 */

/**
 * async 函数的实现原理
 */
async function fn(args) {
  // ...
}

// 等同于

function fn(args) {
  return spawn(function* () {
    // ...
  });
}

// 下面给出spawn函数的实现，基本就是前文自动执行器的翻版
function spawn(genF) {
  return new Promise(function (resolve, reject) {
    const gen = genF();
    function step(nextF) {
      let next;
      try {
        next = nextF();
      } catch (e) {
        return reject(e);
      }
      if (next.done) {
        return resolve(next.value);
      }
      Promise.resolve(next.value).then(
        function (v) {
          step(function () {
            return gen.next(v);
          });
        },
        function (e) {
          step(function () {
            return gen.throw(e);
          });
        }
      );
    }
    step(function () {
      return gen.next(undefined);
    });
  });
}
```

## async/await 的执行顺序

```ts
// Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作
// async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，
// 等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。
async function async1() {
  console.log('async1 start');
  await async2();
  // await后面相当于执行了then
  console.log('async1 end');
}
async function async2() {
  console.log('async2');
}

console.log('script start');
async1();
console.log('script end');

// script start
// async1 start
// async2
// script end
// async1 end

// 第二道题
// 首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，
// 因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来
// 因为 await 是异步操作，后来的表达式不返回 Promise 的话，
// 就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码
// 同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10
let a = 0;
let b = async () => {
  a = a + (await 10);
  console.log('2', a); // -> '2' 10
};
b();
a++;
console.log('1', a); // -> '1' 1

// 打印顺序
// 1 1
// 1 10
```

## 模拟实现一个 Promise.finally

```ts
Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    (value) => P.resolve(callback()).then(() => value),
    (reason) =>
      P.resolve(callback()).then(() => {
        throw reason;
      })
  );
};
```

## 模拟实现一个 Promise.all

```ts
Promise.prototype.all = function (promises) {
  const values = [];
  return new Promise((resolve, reject) => {
    promises.forEach((promise) => {
      promise.then(
        (value) => {
          values.push(value);
          if (values.length === promises.length) {
            resolve(values);
          }
        },
        (reason) => {
          reject(reason);
        }
      );
    });
  });
};
```

## 模拟实现一个 Promise.race

```ts
Promise.prototype.race = function (promises) {
  return new Promise((resolve, reject) => {
    promises.map((promise) => {
      promise.then(
        (value) => {
          resolve(value);
        },
        (reason) => {
          reject(reason);
        }
      );
    });
  });
};
```
