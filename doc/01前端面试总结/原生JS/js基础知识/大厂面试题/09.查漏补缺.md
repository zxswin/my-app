## 查漏补缺

## requestIdleCallback 是干什么用的

- 浏览器帧绘制机制

```ts
/**
 * 一般的浏览器每秒钟会绘制60帧，也就是每帧需要16ms左右，如果js计算任务长时间占用线程那个，会导致一些ui无法及时得到渲染，出现卡顿。
 * 一帧内需要完成如下六个步骤的任务：
 * 1.处理用户的交互
 * 2.JS 解析执行
 * 3.帧开始。窗口尺寸变更，页面滚去等的处理
 * 4.requestAnimationFrame(rAF)
 * 5.布局
 * 6.绘制
 */
```

```ts
/**
 * 使用setTimeout的缺点
 * 我们可以使用setTimout，对这些任务进行延迟处理。但是我们并不知道，setTimeout在执行回调时，是否是浏览器空闲的时候
 *
 * requestIdleCallback 的callback会在浏览器的空闲时间运行
 *
 * 空闲时间
 * 1.第一种空闲时间
 * 如果执行一段动画,第一帧已经渲染到屏幕上了，到第二帧开始渲染，这段时间内属于空闲时间
 * 如果浏览器1s内屏幕刷新60次的。那么空闲时间会小于16ms（1000ms / 16）
 * 2.另外一种空闲时间，当用户属于空闲状态（没有与网页进行任何交互），并且没有屏幕中也没有动画执行。
 * 此时空闲时间是无限长的。但是为了避免不可预测的事（用户突然和网页进行交互），空闲时间最大应该被限制在50ms以内
 * 为什么最大是50ms？人类对100ms内的响应会认为是瞬时的。将空闲时间限制在50ms以内
 * 是为了避免，空闲时间内执行任务，从而导致了对用户操作响应的阻塞，使用户感到明显的响应滞后。
 *
 * 只会在帧末尾有空闲时间时会执行，不应该期望每一次帧结束都会执行requestIdleCallback。
 * 更新DOM，以及Promise的回调（会使帧超时）不适合放到 requestIdleCallback 的callback中
 */

// console
// 空闲时间1
// 等待了1000ms
// 空闲时间2
// Promise 会在空闲时间1接受后立即执行，即使没有空闲时间了也是如此。拖延了进入下一帧的时间

requestIdleCallback(() => {
  console.log('空闲时间1');
  Promise.resolve().then(() => {
    sleep(1000);
    console.log('等待了1000ms');
  });
});

requestIdleCallback(() => {
  console.log('空闲时间2');
});
```

- requestIdleCallback API 简介

```ts
/**
 * requestIdleCallback的第一个参数时callback当callback被调用时，
 *
 * 一个参数 deadline
 * deadline是一个对象，对象上有两个属性
 * timeRemaining，timeRemaining属性是一个函数，函数的返回值表示当前空闲时间还剩下多少时间
 * didTimeout，didTimeout属性是一个布尔值，如果didTimeout是true，那么表示本次callback的执行是因为超时的原因
 *
 * 第二个参数是options
 * options是一个对象，可以用来配置超时时间
 */
requestIdleCallback(
  (deadline) => {
    // deadline.timeRemaining() 返回当前空闲时间的剩余时间
    if (deadline.timeRemaining() > 0) {
      task();
    }
  },
  {
    timeout: 500,
  }
);
```

- 多个 callback 的执行机制

```ts
/**
 * 执行机制
 * 在空闲期间，callback的执行顺序是以FIFO（先进先出）的顺序。
 * 如果在空闲时间内依次执行callback时，有一个callback的执行时间，已经将空闲时间用完了，剩下的callback将会在下一次的空闲时间执行。
 */
const task1 = () => console.log('执行任务1');
const task2 = () => console.log('执行任务2');
const task3 = () => console.log('执行任务3');

// console
// 执行任务1
// 执行任务2
// 执行任务3
requestIdleCallback(task1);
requestIdleCallback(task2);
requestIdleCallback(task3);
```

- 把任务带到下一个空闲时间周期运行

```ts
/**
 * 如果当前的任务所需要的执行时间，超过了当前空闲时间周期内的剩余时间，我们也可以将任务带到下一个空闲时间周期内执行。
 * 在下一个空闲周期开始后，新添加的callback会被添加到callback列表的末尾
 *
 * 当我们网页处于不可见的状态时（比如切换到其他的tag），我们空闲时间将会每10s, 触发一次空闲期。
  */
const startTask = (deadline) {
    // 如果 `task` 花费的时间是20ms
    // 超过了当前空闲时间的剩余毫秒数，我们等到下一次空闲时间执行task
    if (deadline.timeRemaining() <= 20) {
        // 将任务带到下一个空闲时间周期内
        // 添加到下一个空闲时间周期callback列表的末尾
        requestIdleCallback(startTask)
    } else {
        // 执行任务
        task()
    }
}
```

- callback 的超时执行

```ts
/**
 * 如果指定了timeout，但是浏览器没有在timeout指定的时间内，执行callback。在下次空闲时间时，callback会强制执行。
 * 并且callback的参数，deadline.didTimeout等于true, deadline.timeRemaining()返回0。
 */
requestIdleCallback(
  (deadline) => {
    // true
    console.log(deadline.didTimeout);
  },
  {
    timeout: 1000,
  }
);

// 这个操作大概花费5000ms
for (let i = 0; i < 3000; i++) {
  document.body.innerHTML = document.body.innerHTML + `<p>${i}</p>`;
}
```

- requestIdleCallback 实践：在 requestIdleCallback 中打点(完成数据上报)

```ts
const datas = [];
let isReport = false;

function onClick() {
  // ... 一些业务逻辑

  datas.push({
    date: Date.now(),
  });

  handleDataReport();
}

function handleDataReport() {
  if (isReport) {
    return;
  }

  isReport = true;

  // 在空闲周期时，完成数据上报
  requestIdleCallback(dataReport);
}

function dataReport(deadline) {
  isReport = false;

  while (deadline.timeRemaining() > 0 && datas.length > 0) {
    const data = datas.pop();
    // 上报数据
    get(data);
  }

  if (datas.length) {
    // 如果有数据，没有上报完成，等待进入下一个空闲周期
    handleDataReport();
  }
}
```

## requestAnimationFrame(rAF)

- 屏幕刷新频率

```ts
/**
 * 即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)
 * 对于一般笔记本电脑，这个频率大概是60Hz
 *
 * 电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率正在不断的更新屏幕上的图像
 * 因为人的眼睛有视觉停留效应所以并不会感受到页面的闪烁
 */
```

- setTimeout

```ts
/**
 * setTimeout 通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的
 * setTimeout会出现卡顿、抖动的现象的原因
 * 1.setTimeout的执行时间并不是确定的。
 * setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，
 * 才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些
 * 2. setTimeout设置的固定时间间隔，不一定和屏幕的刷新时间相同
 * 导致setTimeout的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象
 */
```

- requestAnimationFrame

```ts
/**
 *
 * 特点：
 * 与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机
 * requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次
 * 这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题
 *
 * 优势
 * 1.CPU节能
 * 使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务,浪费CPU资源
 * requestAnimationFrame当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，requestAnimationFrame也会停止渲染，
 * 当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。
 *
 * 2.函数节流
 * 在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，
 * 使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。
 */
var progress = 0;

//回调函数

function render() {
  progress += 1; //修改图像的位置

  if (progress < 100) {
    //在动画没有结束前，递归渲染

    window.requestAnimationFrame(render);
  }
}

//第一帧渲染

window.requestAnimationFrame(render);
```

- cancelAnimationFrame 方法用于取消定时器

```ts
//控制台什么都不输出
var timer = requestAnimationFrame(function () {
  console.log(0);
});
cancelAnimationFrame(timer);
```

- 简单的进制度效果(setInterval)

```ts
function(){
    clearInterval(timer);
    myDiv.style.width = '0';
    timer = setInterval(function(){
        if(parseInt(myDiv.style.width) < 500){
            myDiv.style.width = parseInt(myDiv.style.width) + 5 + 'px';
            myDiv.innerHTML =     parseInt(myDiv.style.width)/5 + '%';
        }else{
            clearInterval(timer);
        }
    },16);
}
```

- 简单的进制度效果(setTimeout)

```ts
function(){
    clearTimeout(timer);
    myDiv.style.width = '0';
    timer = setTimeout(function fn(){
        if(parseInt(myDiv.style.width) < 500){
            myDiv.style.width = parseInt(myDiv.style.width) + 5 + 'px';
            myDiv.innerHTML =     parseInt(myDiv.style.width)/5 + '%';
            timer = setTimeout(fn,16);
        }else{
            clearTimeout(timer);
        }
    },16);
}
```

- 简单的进制度效果(requestAnimationFrame)

```ts
function(){
    myDiv.style.width = '0';
    cancelAnimationFrame(timer);
    timer = requestAnimationFrame(function fn(){
        if(parseInt(myDiv.style.width) < 500){
            myDiv.style.width = parseInt(myDiv.style.width) + 5 + 'px';
            myDiv.innerHTML =     parseInt(myDiv.style.width)/5 + '%';
            timer = requestAnimationFrame(fn);
        }else{
            cancelAnimationFrame(timer);
        }
    });
}
```

## JS 中的循环引用及问题

```ts
/**
 * 通过引用计数的策略进行垃圾回收会造成内存泄露
 * JSON.stringify会报错
 */
```

## event.target 和 event.currtager 的区别

```ts
/**
 * event.target代表的是触发事件的元素，而event.currentTarget代表的是那个绑定了事件处理函数的元素
 */
```

- base64 编码

```ts
/**
 * 把大图片编码到 html / css 中，会造成后者体积明显增加，明显影响网页的打开速度。
 */

window.btoa('china is so nb'); // 编码
// "Y2hpbmEgaXMgc28gbmI="
window.atob('Y2hpbmEgaXMgc28gbmI='); // 解码
// "china is so nb"
var user_icon = document.getElementById('icon');
user_icon.src = img_path; //指定图片路径
user_icon.onload = function () {
  base64 = getImageBase64(user_icon, fileExt); //base64编码
};
```

## 函数柯里化

```js
// 参考答案：
// 柯里化（currying）又称部分求值。一个柯里化的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。

// 举个例子，就是把原本：
// function(arg1,arg2)  变成 function(arg1)(arg2)
// function(arg1,arg2,arg3)  变成 function(arg1)(arg2)(arg3)
// function(arg1,arg2,arg3,arg4)  变成 function(arg1)(arg2)(arg3)(arg4)

// 总而言之，就是将：

// function(arg1,arg2,…,argn)  变成 function(arg1)(arg2)…(argn)

// 柯里化过的add()函数，可以接受部分参数
function add(x, y) {
  if (typeof y === 'undefined') {
    return function (newy) {
      return x + newy;
    };
  }
  // 完整应用
  return x + y;
}
// 测试调用
console.log(typeof add(4)); // [Function]
console.log(add(4)(6)); // 10
// 可以创建保存函数
let saveAdd = add(4);
console.log(saveAdd(6)); // 10
```

## 实现一个函数,对一个 url 进行请求,失败就再次请求,超过最大次数就走失败回调,任何一次成功都走成功回调

```js
/**
    @params url: 请求接口地址;
    @params body: 设置的请求体;
    @params succ: 请求成功后的回调
    @params error: 请求失败后的回调
    @params maxCount: 设置请求的数量
*/
function request(url, body, succ, error, maxCount = 5) {
  return fetch(url, body)
    .then((res) => succ(res))
    .catch((err) => {
      if (maxCount <= 0) return error('请求超时');
      return request(url, body, succ, error, --maxCount);
    });
}

// 调用请求函数
request(
  'https://java.some.com/pc/reqCount',
  { method: 'GET', headers: {} },
  (res) => {
    console.log(res.data);
  },
  (err) => {
    console.log(err);
  }
);
```

## 数组降维(flat)

```js
// 解析：使用 flat 方法会接收一个参数，这个参数是数值类型，是要处理扁平化数组的深度，生成后的新数组是独立存在的，不会对原数组产生影响。

// flat 方法的语法如下：

var newArray = arr.flat([depth]);
```

```js
// 其中 depth 指定要提取嵌套数组结构的深度，默认值为 1。
var arr = [1, 2, [3, 4, [5, 6]]];
console.log(arr.flat()); // [1, 2, 3, 4, [5, 6]]
console.log(arr.flat(2)); // [1, 2, 3, 4, 5, 6]

// 使用 Infinity，可展开任意深度的嵌套数组
var arr = [1, 2, [3, 4, [5, 6, [7, 8]]]];
console.log(arr.flat(Infinity)); // [1, 2, 3, 4, 5, 6, 7, 8]

// 在数组中有空项的时候，使用 flat 方法会将中的空项进行移除。
var arr = [1, 2, , 4, 5];
console.log(arr.flat()); // [1, 2, 4, 5]
```

## proxy 是实现代理，可以改变 js 底层的实现方式, 然后说了一下和 Object.defineProperty 的区别

```js
// 两者的区别总结如下：

// 代理原理：Object.defineProperty的原理是通过将数据属性转变为存取器属性的方式实现的属性读写代理。而Proxy则是因为这个内置的Proxy对象内部有一套监听机制，在传入handler对象作为参数构造代理对象后，一旦代理对象的某个操作触发，就会进入handler中对应注册的处理函数，此时我们就可以有选择的使用Reflect将操作转发被代理对象上。
// 代理局限性：Object.defineProperty始终还是局限于属性层面的读写代理，对于对象层面以及属性的其它操作代理它都无法实现。鉴于此，由于数组对象push、pop等方法的存在，它对于数组元素的读写代理实现的并不完全。而使用Proxy则可以很方便的监视数组操作。
// 自我代理：Object.defineProperty方式可以代理到自身（代理之后使用对象本身即可），也可以代理到别的对象身上（代理之后需要使用代理对象）。Proxy方式只能代理到Proxy实例对象上。这一点在其它说法中是Proxy对象不需要侵入对象就可以实现代理，实际上Object.defineProperty方式也可以不侵入。
```

## 单词

```pug
idle 空闲
deadline 截止日期
remaining 剩下的
depth 深度
```
