# Socket.IO

- Socket.IO 需要使用 node 的 v10.15.1 版本才能工作正常 使用最新版本会报错

## 运用场景

Socket.IO 是一个基于 Node.js 的实时应用程序框架，在即时通讯、通知与消息推送，实时分析等场景中有较为广泛的应用。
socket.io 支持 websocket、polling 两种数据传输方式
Egg Socket 内部默认使用 ws 引擎，uws 因为某些原因被废止。

## egg-socket.io 插件

- 框架提供了 egg-socket.io 插件，增加了以下开发规约：

```bash
namespace: 通过配置的方式定义 namespace（命名空间）
middleware: 对每一次 socket 连接的建立/断开、每一次消息/数据传递进行预处理
controller: 响应 socket.io 的 event 事件
router: 统一了 socket.io 的 event 与 框架路由的处理配置方式
```

### 安装 egg-socket.io

> npm i egg-socket.io --save

### 开启插件

```js
// {app_root}/config/plugin.js
exports.io = {
  enable: true,
  package: 'egg-socket.io'
};
```

### 配置插件

- 配置案例

```js
exports.io = {
  init: {}, // passed to engine.io
  namespace: {
    '/': {
      connectionMiddleware: [],
      packetMiddleware: []
    },
    '/example': {
      connectionMiddleware: [],
      packetMiddleware: []
    }
  }
};
// 命名空间为 / 与 /example, 不是 example
```

## socket.io-redis

egg-socket.io 内置了 socket.io-redis，在 cluster 模式下，使用 redis 可以较为简单的实现 clients/rooms 等信息共享
开启 redis 后，程序在启动时会尝试连接到 redis 服务器 此处 redis 仅用于存储连接实例信息
如果项目中同时使用了 egg-redis， 请单独配置，不可共用。

- redis 配置示例

```js
// {app_root}/config/config.${env}.js
exports.io = {
  redis: {
    host: { redis server host },
    port: { redis server port },
    auth_pass: { redis server password },
    db: 0,
  },
};
```

## 部署

- 修改 package.json 中 npm scripts 脚本：

```js
{
  "scripts": {
    "dev": "egg-bin dev --sticky",
    "start": "egg-scripts start --sticky"
  }
}
```

- Nginx 配置

```js
location / {
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header Host $host;
  proxy_pass   http://127.0.0.1:7001;

  # http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_bind
  # proxy_bind       $remote_addr transparent;
}
```

## 官网案例代码分析

- 项目目录结构

```bash
开启 egg-socket.io 的项目目录结构如下：

chat
├── app
│   ├── extend
│   │   └── helper.js
│   ├── io
│   │   ├── controller
│   │   │   └── chat.js
│   │   └── middleware
│   │       ├── auth.js
│   │       └── packet.js
│   └── router.js
├── config
└── package.json
注意：对应的文件都在 app/io 目录下
```

- 框架中间件 与 插件中间件

```bash
# app/middleware：框架中间件
框架中间件基于 http 模型设计，处理 http 请求。
# app/io/middleware：插件中间件
插件中间件基于 socket 模型设计，处理 socket.io 请求。
```

- auth.js

```js
/* 在每一个客户端连接或者退出时发生作用，故而我们通常在这一步进行授权认证，
对认证失败的客户端做出相应的处理 */
module.exports = () => {
  return async (ctx, next) => {
    const say = 'auth服务端发送的消息';
    ctx.socket.emit('res', 'auth!' + say);
    await next();
    console.log('disconnect!'); // 当断开连接的时候会触发
  };
};
```

- packet.js

```js
/* Packet
作用于每一个数据包（每一条消息）；在生产环境中，通常用于对消息做预处理，又或者是对加密消息的解密等操作 */
module.exports = () => {
  return async (ctx, next) => {
    console.log(ctx.packet);
    const say = 'packet服务端发送的消息';
    ctx.socket.emit('res', 'packet!' + say);
    await next();
    console.log('packet response!');
  };
};
```

- chat.js

```js
/* Controller
Controller 对客户端发送的 event 进行处理；由于其继承于 egg.Contoller, 拥有如下成员对象: 
ctx
app
service
config
logger*/
module.exports = app => {
  class Controller extends app.Controller {
    async index() {
      const message = this.ctx.args[0]; // 这个是接受到的客户端发送过来的消息
      console.log('chat :', message + ' : ' + process.pid);
      const say = 'chat服务端发送的消息';
      this.ctx.socket.emit('res', say);
    }
  }
  return Controller;
};
```

- router.js

```js
/* Router
路由负责将 socket 连接的不同 events 分发到对应的 controller，框架统一了其使用方式 */
// app.io.of('/chat')
app.io.of('/chat').route('chat', app.io.controller.chat.index);
```

## 一个简单的 websocket 前后端通讯案例(不使用框架)

- 服务器端代码

```js
// 导入WebSocket模块
const WebSocket = require('ws');

// 引用Server类
const WebSocketServer = WebSocket.Server;

// 实例化
const wss = new WebSocketServer({
  port: 3000 // 在3000端口上打开一个WebSocket Server
});

// 如果有WebSocket请求接入 wws对象可以响应connection事件来处理这个WebSocket
wss.on('connection', function(ws) {
  console.log(`与服务器连接上了`);
  ws.on('message', function(message) {
    console.log(`服务器接收到了信息: ${message}`); //服务器接收到的信息
    setTimeout(() => {
      ws.send(`你的名字是什么`, err => {
        // 服务器发送信息
        if (err) {
          console.log(`服务器报错了: ${err}`);
        }
      });
    }, 1000);
  });
});

console.log('ws server started at port 3000...');
```

- 前端代码

```js
/** WebSocket 通讯测试 */
$('#websocket').on('click', function() {
  let count = 0;
  let ws = new WebSocket('ws://localhost:3000'); // 创建webScoket对象
  ws.onopen = function() {
    // 打开webSocket链接
    console.log(`[CLIENT] open()`);
    ws.send('Hello!'); // 发送webSocket请求
  };

  ws.onmessage = function(message) {
    console.log(`[CLIENT] Received: ${message.data}`); // 客户端接收到的信息
    count++;
    if (count > 3) {
      ws.send('Goodbye!'); // 客户端发送的信息
      ws.close(); // 关闭webSocket链接
    } else {
      setTimeout(() => {
        ws.send(`Hello, I'm Mr No.${count}!`); // 客户端发送的信息
      }, 1000);
    }
  };
});
```

## Namespace/Room

- nsp 有如下的系统事件:

```bash
disconnecting doing the disconnect
disconnect connection has disconnected.
error Error occurred
```

- 命名空间

```bash
namespace 通常意味分配到不同的接入点或者路径，如果客户端没有指定 nsp，则默认分配到 "/" 这个默认的命名空间。
在 socket.io 中我们通过 of 来划分命名空间；
鉴于 nsp 通常是预定义且相对固定的存在，框架将其进行了封装，采用配置的方式来划分不同的命名空间。
```

## Room

- room 存在于 nsp 中，通过 join/leave 方法来加入或者离开; 框架中使用方法相同；

```js
/* 每一个 socket 连接都会拥有一个随机且不可预测的唯一 id Socket#id，并且会自动加入到以这个 id 命名的 room 中 */
const room = 'default_room';

module.exports = app => {
  return async (ctx, next) => {
    ctx.socket.join(room);
    ctx.app.io
      .of('/')
      .to(room)
      .emit('online', { msg: 'welcome', id: ctx.socket.id });
    await next();
    console.log('disconnection!');
  };
};
```

## 使用 egg-socket.io 来做一个支持 p2p 聊天的小例子

### Redis 安装

```bash
# Window 下安装
下载地址：https://github.com/MSOpenTech/redis/releases。
# 启动 默认没有密码
redis-cli.exe -h 127.0.0.1 -p 6379
# 设置key
set room demo
```

### 配置

- config.default.js

```js
config.io = {
  namespace: {
    /** 实现p2p聊天  */
    '/ptop': {
      connectionMiddleware: ['authp'],
      packetMiddleware: [] // 针对消息的处理暂时不实现
    },
    /** websocket测试  */
    '/chat': {
      connectionMiddleware: ['auth'],
      packetMiddleware: ['packet']
    }
  },
  // cluster 模式下，通过 redis 实现数据共享
  redis: {
    host: '127.0.0.1',
    port: 6379
  }
};

// 可选
config.redis = {
  client: {
    port: 6379,
    host: '127.0.0.1',
    password: '',
    db: 0
  }
};
```

- plugin.js 中的配置

```js
/** 开启 egg-socket.io 插件  */
exports.io = {
  enable: true,
  package: 'egg-socket.io'
};

/** 启动 redis */
exports.redis = {
  enable: true,
  package: 'egg-redis'
};
```

- io/controller/nsp.js

```js
const Controller = require('egg').Controller;

class NspController extends Controller {
  async exchange() {
    console.log('执行了1 nsp.js');
    const { ctx, app } = this;
    const nsp = app.io.of('/ptop');
    const message = ctx.args[0] || {};
    const socket = ctx.socket;
    const client = socket.id;

    console.log('客户端发送的消息', message);

    try {
      console.log('执行了2 nsp.js');
      const { target, payload } = message;
      if (!target) return;
      const msg = ctx.helper.parseMsg('exchange', payload, { client, target });
      console.log('服务器端发送了消息', target, msg);
      nsp.emit(target, msg);
    } catch (error) {
      console.log('执行了3 nsp.js');
      app.logger.error(error);
    }
  }
}

module.exports = NspController;
```

- io/middleware/authp.js

```js
/* eslint-disable handle-callback-err */
/* eslint-disable no-shadow */
const PREFIX = 'room';

module.exports = () => {
  return async (ctx, next) => {
    console.log('执行了authp.js');
    const { app, socket, logger, helper } = ctx;
    const id = socket.id;
    const nsp = app.io.of('/ptop');
    const query = socket.handshake.query;

    // 用户信息
    const { room, userId } = query;
    const rooms = [room];
    console.log('room', room);

    logger.debug('#user_info', id, room, userId);

    const tick = (id, msg) => {
      logger.debug('#tick', id, msg);

      // 踢出用户前发送消息
      socket.emit(id, helper.parseMsg('deny', msg));

      // 调用 adapter 方法踢出用户，客户端触发 disconnect 事件
      nsp.adapter.remoteDisconnect(id, true, err => {
        console.log('踢出用户');
        logger.error(err);
      });
    };

    // 检查房间是否存在，不存在则踢出用户
    // 备注：此处 app.redis 与插件无关，可用其他存储代替
    // const hasRoom = await app.redis.get(`${PREFIX}:${room}`);
    console.log('room', room);
    const hasRoom = await app.redis.get(PREFIX);
    console.log('hasRoom', hasRoom);
    logger.debug('#has_exist', hasRoom);

    // 如果房间不存在会触发这里
    if (!hasRoom) {
      tick(id, {
        type: 'deleted',
        message: 'deleted, room has been deleted.'
      });
      return;
    }

    // 用户加入
    logger.debug('#join', room);
    socket.join(room);

    // 在线列表
    nsp.adapter.clients(rooms, (err, clients) => {
      logger.debug('#online_join', clients);

      // 更新在线用户列表
      nsp.to(room).emit('online', {
        clients,
        action: 'join',
        target: 'participator',
        message: `User(${id}) joined.`
      });
    });

    await next();

    // 用户离开
    logger.debug('#leave', room);

    // 在线列表
    nsp.adapter.clients(rooms, (err, clients) => {
      logger.debug('#online_leave', clients);

      // 获取 client 信息
      // const clientsDetail = {};
      // clients.forEach(client => {
      //   const _client = app.io.sockets.sockets[client];
      //   const _query = _client.handshake.query;
      //   clientsDetail[client] = _query;
      // });

      // 更新在线用户列表
      nsp.to(room).emit('online', {
        clients,
        action: 'leave',
        target: 'participator',
        message: `User(${id}) leaved.`
      });
    });
  };
};
```

- 客户端代码

```js
// browser
const log = console.log;
const io = require('socket.io-client');

window.onload = function() {
  // init
  const socket = io('http://127.0.0.1:8080/ptop', {
    // 实际使用中可以在这里传递参数
    query: {
      room: 'demo',
      userId: `client_${Math.random()}`
    },

    transports: ['websocket']
  });

  socket.on('connect', () => {
    const id = socket.id;

    log('#connect,', id, socket);

    setTimeout(() => {
      socket.emit('exchange', {
        target: id,
        payload: {
          msg: 'test'
        }
      });
    }, 1000);

    // 监听自身 id 以实现 p2p 通讯
    socket.on(id, msg => {
      log('#receive,', msg);
    });
  });

  // 接收在线用户信息
  socket.on('online', msg => {
    log('#online,', msg);
  });

  // 系统事件
  socket.on('disconnect', msg => {
    log('#disconnect', msg);
  });

  socket.on('disconnecting', () => {
    log('#disconnecting');
  });

  socket.on('error', () => {
    log('#error');
  });

  window.socket = socket;
};
```
