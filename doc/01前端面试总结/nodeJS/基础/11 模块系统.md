## 模块系统

- nodeJS 模块内部的加载

```ts
/**
 * 从文件模块缓存中加载
 * 尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。
 *
 * 从原生模块加载
 * 原生模块的优先级仅次于文件模块缓存的优先级。
 *
 * require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。
 * 以 http 模块为例，尽管在目录下存在一个 http/http.js/http.node/http.json 文件
 * require("http") 都不会从这些文件中加载，而是从原生模块中加载。
 *
 * 原生模块也有一个缓存区，同样也是优先从缓存区加载。
 * 如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。
 *
 * 从文件加载
 * 当文件模块缓存中不存在，而且不是原生模块的时候
 * Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件
 *
 * 将详细描述查找文件模块的过程
 * require 方法接受以下几种参数的传递：
 * 1.http、fs、path 等，原生模块。
 * 2../mod 或../mod，相对路径的文件模块。
 * 3./pathtomodule/mod，绝对路径的文件模块。
 * 4.mod，非原生模块的文件模块。
 */
```

- 创建模块并使用模块

```ts
//hello.js
function Hello() {
  var name;
  this.setName = function (thyName) {
    name = thyName;
  };
  this.sayHello = function () {
    console.log('Hello ' + name);
  };
}
module.exports = Hello;
// 这样就可以直接获得这个对象了：

//main.js
var Hello = require('./hello');
hello = new Hello();
hello.setName('BYVoid');
hello.sayHello();
```
