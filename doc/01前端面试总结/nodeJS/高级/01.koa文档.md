## 安装

```js
// npm install koa -S
```

## 简单使用

```js
const Koa = require('koa');
const app = new Koa();

// response
app.use((ctx) => {
  ctx.body = 'Hello Koa';
});

app.listen(3000);
```

## 上下文(Context)

```js
const Koa = require('koa');
const app = new Koa();

app.use(async (ctx) => {
  // 1.ctx.app 应用程序实例引用

  // 2.ctx.app.emit
  // Koa 应用扩展了内部 EventEmitter。ctx.app.emit 发出一个类型由第一个参数定义的事件。
  // 对于每个事件，您可以连接 "listeners"，这是在发出事件时调用的函数。

  // 3.ctx.cookies.get(name, [options])
  // 通过 options 获取 cookie name:
  // signed 所请求的cookie应该被签名

  // 4.ctx.cookies.set(name, value, [options])
  // 通过 options 设置 cookie name 的 value

  // 5.ctx.throw([status], [msg], [properties])
  // 用来抛出一个包含 .status 属性错误的帮助方法，其默认值为 500。这样 Koa 就可以做出适当地响应。

  // ctx.throw(400);
  // ctx.throw(400, 'name required');
  // ctx.throw(400, 'name required', { user: user });

  ctx.response.body = 'ok';
  const ct = ctx.response.type;
  console.log('ct=====', ct); // text/plain
});

app.listen(3000);
```

## 请求(Request)

```js
const Koa = require('koa');
const app = new Koa();

app.use(async (ctx) => {
  // http://localhost:3000/foo/bar?color=blue&size=small

  // 1.请求头信息的获取
  // ctx.request.header 与 ctx.request.headers 都可以获取请求头信息,返回的结果是一样的.
  // console.log('请求头信息===', ctx.request.header);

  // 请求头信息 my-url baidu.com
  console.log('请求头信息 my-url', ctx.request.headers['my-url']);

  // 2.请求方法的获取
  // 请求方法 GET
  console.log('请求方法', ctx.request.method);

  // 3.获取请求 URL
  // 请求URL /foo/bar?color=blue&size=small
  console.log('请求URL', ctx.request.url);

  // 4.获取请求原始URL
  // 获取请求原始URL /foo/bar?color=blue&size=small
  console.log('获取请求原始URL', ctx.request.originalUrl);

  // 5.获取URL的来源
  // 获取URL的来源 http://localhost:3000
  console.log('获取URL的来源', ctx.request.origin);

  // 6.获取完整的请求URL，包括 protocol，host 和 url===
  // 获取完整的请求URL，包括 protocol，host 和 url=== http://localhost:3000/foo/bar?color=blue&size=small
  console.log(
    '获取完整的请求URL，包括 protocol，host 和 url===',
    ctx.request.href
  );

  // 7.获取请求路径名
  // 获取请求路径名 /foo/bar
  console.log('获取请求路径名', ctx.request.path);

  // 8.根据 ? 获取原始查询字符串
  // 根据 ? 获取原始查询字符串 color=blue&size=small
  console.log('根据 ? 获取原始查询字符串', ctx.request.querystring);

  // 9.根据 ? 获取原始查询字符串
  // 使用 ? 获取原始查询字符串 ?color=blue&size=small
  console.log('使用 ? 获取原始查询字符串', ctx.request.search);

  // 10.存在时获取主机（hostname:port）
  // 存在时获取主机（hostname:port） localhost:3000
  console.log('存在时获取主机（hostname:port）', ctx.request.host);

  // 11.存在时获取主机名。
  // 存在时获取主机名。 localhost
  console.log('存在时获取主机名。', ctx.request.hostname);

  // 12.获取 WHATWG 解析的 URL 对象
  console.log('获取 WHATWG 解析的 URL 对象', ctx.request.URL);

  // 13.获取请求 Content-Type, 不含 "charset" 等参数
  // 获取请求 Content-Type, 不含 "charset" 等参数 application/json
  console.log('获取请求 Content-Type, 不含 "charset" 等参数', ctx.request.type);

  // 14.存在时获取请求字符集，或者 undefined：
  // 存在时获取请求字符集，或者 undefined：
  console.log('存在时获取请求字符集，或者 undefined：', ctx.request.charset);

  // 15.获取解析的查询字符串, 当没有查询字符串时，返回一个空对象
  // 获取解析的查询字符串, 当没有查询字符串时，返回一个空对象 [Object: null prototype] { color: 'blue', size: 'small' }
  console.log(
    '获取解析的查询字符串, 当没有查询字符串时，返回一个空对象',
    ctx.request.query
  );

  // 16.通过 ctx.protocol == "https" 来检查请求是否通过 TLS 发出。
  // 通过 ctx.protocol == "https" 来检查请求是否通过 TLS 发出。 false
  console.log(
    '通过 ctx.protocol == "https" 来检查请求是否通过 TLS 发出。',
    ctx.request.secure
  );

  // 16.请求远程地址。
  // 请求远程地址。 ::1
  console.log('请求远程地址。', ctx.request.ip);

  // 17.检查传入请求是否包含 Content-Type 消息头字段， 并且包含任意的 mime type。
  // 如果没有请求主体，返回 null。 如果没有内容类型，或者匹配失败，则返回 false。
  // 反之则返回匹配的 content-type。
  // 检查传入请求是否包含 Content-Type 消息头字段 null
  console.log(
    '检查传入请求是否包含 Content-Type 消息头字段',
    ctx.request.is('application/json')
  );

  ctx.response.body = 'ok';
});

app.listen(3000);
```

## 响应(Response)

```js
const Koa = require('koa');
const app = new Koa();

app.use(async (ctx) => {
  // 1.response.header 响应头对象。
  // response.headers 响应头对象。别名是 response.header。

  // 2.response.status
  // 获取响应状态。默认情况下，response.status 设置为 404

  ctx.response.status = 200;

  // 3.response.body 获取响应主体。
  // 如果 response.status 未被设置, Koa 将会自动设置状态为 200 或 204

  // String
  // Content-Type 默认为 text/html 或 text/plain, 同时默认字符集是 utf-8。Content-Length 字段也是如此。

  // Buffer
  // Content-Type 默认为 application/octet-stream, 并且 Content-Length 字段也是如此。

  // Stream
  // Content-Type 默认为 application/octet-stream。

  // Object
  // Content-Type 默认为 application/json. 这包括普通的对象 { foo: 'bar' } 和数组 ['foo', 'bar']。

  // 4.response.get(field)
  // 不区分大小写获取响应头字段值 field
  const etag = ctx.response.get('ETag');

  // response.has(field)
  // 如果当前在响应头中设置了由名称标识的消息头，则返回 true. 消息头名称匹配不区分大小写.
  const rateLimited = ctx.response.has('X-RateLimit-Limit');

  // response.set(field, value)
  // 设置响应头 field 到 value:
  ctx.response.set('Cache-Control', 'no-cache');

  // response.append(field, value)
  // 用值 val 附加额外的消息头 field。

  ctx.response.append('Link', '<http://127.0.0.1/>');

  // response.set(fields)
  // 用一个对象设置多个响应头fields:

  // ctx.response.set({
  //   Etag: '1234',
  //   'Last-Modified': date,
  // });

  // response.remove(field)
  // 删除消息头 field。

  // response.type
  // 获取响应 Content-Type, 不含 "charset" 等参数。

  // response.is(types...)
  // 非常类似 ctx.request.is(). 检查响应类型是否是所提供的类型之一

  //  response.redirect(url, [alt])
  // 执行 [302] 重定向到 url.
  // 字符串 “back” 是特别提供 Referrer 支持的，当 Referrer 不存在时，使用 alt 或 “/”。

  ctx.redirect('back');
  ctx.redirect('back', '/index.html');
  ctx.redirect('/login');
  ctx.redirect('http://google.com');
  // 要更改 “302” 的默认状态，只需在该调用之前或之后给 status 赋值。要变更主体请在此调用之后:

  ctx.status = 301;
  ctx.redirect('/cart');
  ctx.body = 'Redirecting to shopping cart';

  ctx.response.body = 'ok';
  const ct = ctx.response.type;
  console.log('ct=====', ct); // text/plain
});

app.listen(3000);
```

## 级联案例分析

```ts
/**
 * 当一个中间件调用 next() 则该函数暂停并将控制传递给定义的下一个中间件。
 */
const Koa = require('koa');
const app = new Koa();

app.use(async (ctx, next) => {
  console.log('执行到第 1 个中间件……');
  await next(); // 等待下一个中间件执行完毕 才执行后面的内容
  const rt = ctx.response.get('X-Response-Time'); // 获取响应时间
  console.log(`${ctx.method} ${ctx.url} - ${rt}`); // 这个日志是最后才输出的内容
});

app.use(async (ctx, next) => {
  console.log('执行到第 2 个中间件……');
  const start = Date.now();
  await next(); // 等待下一个中间件执行完毕 才执行后面的内容
  const ms = Date.now() - start;
  ctx.set('X-Response-Time', `${ms}ms`); // 设置响应时间
});

app.use(async (ctx) => {
  console.log('执行到第 3 个中间件 输出响应文本……');
  ctx.body = 'Hello World';
});

app.listen(3000);

// 打印输出内容为： 每响应一次资源都会执行一次
// 执行到第 1 个中间件……
// 执行到第 2 个中间件……
// 执行到第 3 个中间件 输出响应文本……
// GET / - 5ms
// 执行到第 1 个中间件……
// 执行到第 2 个中间件……
// 执行到第 3 个中间件 输出响应文本……
// GET /favicon.ico - 0ms
```

## 错误的处理

- ctx.throw 处理错误

```js
const Koa = require('koa');
const app = new Koa();

// app.context
// app.context 是从其创建 ctx 的原型。您可以通过编辑 app.context 为 ctx 添加其他属性
app.context.db = {
  db: 'db',
};

app.use(async (ctx) => {
  ctx.throw(400, 'name required');
});

// 错误处理 -当 err.status 是 404 或 err.expose 是 true 时默认错误处理程序也不会输出错误。
// 要执行自定义错误处理逻辑，如集中式日志记录，您可以添加一个 “error” 事件侦听器：
// app.on('error', (err) => {
//   console.log('erver error');
// });

// 如果 req/res 期间出现错误，并且 _无法_ 响应客户端，Context 实例仍然被传递：
app.on('error', (err, ctx) => {
  console.log('erver error');
});

app.listen(3000);
```

- try-catch 处理错误

```js
app.use(async (ctx, next) => {
  try {
    await next();
  } catch (err) {
    err.status = err.statusCode || err.status || 500;
    throw err;
  }
});
```

- 自定义错误处理

```js
app.use(async (ctx, next) => {
  try {
    await next();
  } catch (err) {
    // will only respond with JSON
    ctx.status = err.statusCode || err.status || 500;
    ctx.body = {
      message: err.message,
    };
  }
});
```

## Koa 完整实例

```ts
/**
 * koa -- koa2 版本
 * koa 是 Express 的下一代基于 Node.js 的 web 框架，目前有 1.x 和 2.0 两个版本。
 */
```

- koa 的安装及使用

```ts
// 安装
// 1.npm install koa

// koa 简单代码示例
// 导入 koa，和 koa 1.x 不同，在 koa2 中，我们导入的是一个 class，因此用大写的 Koa 表示:
const Koa = require('koa');

// 创建一个 Koa 对象表示 web app 本身:
const app = new Koa();

// 对于任何请求，app 将调用该异步函数处理请求：
app.use(async (ctx, next) => {
  await next();
  ctx.response.type = 'text/html';
  ctx.response.body = '<h1>Hello, koa2!</h1>';
});

// 在端口 3000 监听:
app.listen(3000);
console.log('app started at port 3000...');
```

- 执行多个异步函数示例

```ts
/**
 * 参数 ctx 是由 koa 传入的封装了 request 和 response 的变量
 * 我们可以通过它访问 request 和 response
 * next 是 koa 传入的将要处理的下一个异步函数
 *
 * koa 把很多 async 函数组成一个处理链
 * 每个 async 函数都可以做一些自己的事情，然后用 await next()来调用下一个 async 函数
 *
 * 我们把每个 async 函数称为 middleware
 * 这些 middleware 可以组合起来，完成很多有用的功能。
 *
 *
 * ctx 对象有一些简写的方法，
 * 例如 ctx.url 相当于 ctx.request.url，
 * ctx.type 相当于 ctx.response.type。
 */
const Koa = require('koa');
const app = new Koa();

app.use(async (ctx, next) => {
  console.log(`${ctx.request.method} ${ctx.request.url}`); // 打印 URL
  await next(); // 调用下一个 middleware
});

app.use(async (ctx, next) => {
  const start = new Date().getTime(); // 当前时间
  await next(); // 调用下一个 middleware
  const ms = new Date().getTime() - start; // 耗费时间
  console.log(`Time: ${ms}ms`); // 打印耗费时间
});

app.use(async (ctx, next) => {
  await next();
  ctx.response.type = 'text/html';
  ctx.response.body = '<h1>Hello, koa2!</h1>';
});

// 在端口 3000 监听:
app.listen(3000);
console.log('app started at port 3000...');
```

- 处理 URL 并实现页面分离

```ts
/**
 * 1.单纯使用 koa2 实现对各类不同的 URL 的处理
 */
const Koa = require('koa');
const app = new Koa();

app.use(async (ctx, next) => {
  if (ctx.request.path === '/') {
    ctx.response.body = 'index page';
  } else {
    await next();
  }
});

app.use(async (ctx, next) => {
  if (ctx.request.path === '/test') {
    ctx.response.body = 'TEST page';
  } else {
    await next();
  }
});

app.use(async (ctx, next) => {
  if (ctx.request.path === '/error') {
    ctx.response.body = 'ERROR page';
  } else {
    await next();
  }
});
```

- koa-router

```ts
/**
 * 为了处理 URL，我们需要引入 koa-router 这个 middleware，让它负责处理 URL 映射。
 *
 * 安装 npm install koa-router
 * 注意导入 koa-router 的语句最后的()是函数调用
 * 注意 require('koa-router')返回的是函数
 * const router = require('koa-router')();
 */

const Koa = require('koa');

// 注意 require('koa-router')返回的是函数:
const router = require('koa-router')();

const app = new Koa();

// log request URL:
app.use(async (ctx, next) => {
  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
  await next();
});

// add url-route:
router.get('/hello/:name', async (ctx, next) => {
  var name = ctx.params.name;
  ctx.response.body = `<h1>Hello, ${name}!</h1>`;
  //示范 url http://127.0.0.1:3000/hello/mmmddd
});

router.get('/', async (ctx, next) => {
  ctx.response.body = '<h1>Index</h1>';
});

// add router middleware:
app.use(router.routes());

app.listen(3000);
console.log('app started at port 3000...');
```

- koa-bodyparser 处理 post 请求

```ts
/**
 * 用 router.get('/path', async fn)处理的是 get 请求。
 * 如果要处理 post 请求，可以用 router.post('/path', async fn)。
 * 解析原始 request 请求，然后，把解析后的参数，绑定到 ctx.request.body 中
 *
 * 安装
 * npm install koa-bodyparser -S
 *
 * 使用
 * app.use(bodyParser());
 */

// 一个简单的初步案例
const Koa = require('koa');
const bodyParser = require('koa-bodyparser');
const router = require('koa-router')();
const app = new Koa();
// log request URL:
app.use(async (ctx, next) => {
  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
  await next();
});
// parse request body:
app.use(bodyParser());
// add url-route:
router.get('/hello/:name', async (ctx, next) => {
  var name = ctx.params.name;
  ctx.response.body = `<h1>Hello, ${name}!</h1>`;
});
router.get('/', async (ctx, next) => {
  ctx.response.body = `<h1>Index</h1>

<form action="/signin" method="post">
<p>Name: <input name="name" value="koa"></p>
<p>Password: <input name="password" type="password"></p>
<p><input type="submit" value="Submit"></p>
</form>`;
});
router.post('/signin', async (ctx, next) => {
  var name = ctx.request.body.name || '',
    password = ctx.request.body.password || '';
  console.log(`signin with name: ${name}, password: ${password}`);
  if (name === 'koa' && password === '12345') {
    ctx.response.body = `<h1>Welcome, ${name}!</h1>`;
  } else {
    ctx.response.body = `<h1>Login failed!</h1>
<p><a href="/">Try again</a></p>`;
  }
});
// add router middleware:
app.use(router.routes());
app.listen(3000);
console.log('app started at port 3000...');
```

- 实现代码逻辑分离

```ts
// 1.app.js
const Koa = require('koa');
const bodyParser = require('koa-bodyparser');
const controller = require('./controller');
const app = new Koa();

// 打印出请求的 url 开始启动 web 服务功能:
app.use(async (ctx, next) => {
  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
  await next();
});

// 解析请求体:
app.use(bodyParser());

// 加入控制器:
app.use(controller());

app.listen(3000);
console.log('app started at port 3000...');
```

```ts
// 2.hello.js 业务逻辑代码
var fn_hello = async (ctx, next) => {
  var name = ctx.params.name;
  ctx.response.body = `<h1>Hello, ${name}!</h1>`;
};

module.exports = {
  'GET /hello/:name': fn_hello, //暴露出对于的 url 及方法
};
```

```ts
// 3.index.js 业务逻辑代码
var fn_index = async (ctx, next) => {
  ctx.response.body = `<h1>Index</h1> <form action="/signin" method="post"> <p>Name: <input name="name" value="koa"></p> <p>Password: <input name="password" type="password"></p> <p><input type="submit" value="Submit"></p> </form>`;
};

var fn_signin = async (ctx, next) => {
  var name = ctx.request.body.name || '',
    password = ctx.request.body.password || '';
  console.log(`signin with name: ${name}, password: ${password}`);
  if (name === 'koa' && password === '12345') {
    ctx.response.body = `<h1>Welcome, ${name}!</h1>`;
  } else {
    ctx.response.body = `<h1>Login failed!</h1> <p><a href="/">Try again</a></p>`;
  }
};

module.exports = {
  //暴露出对于的 url 及方法
  'GET /': fn_index,
  'POST /signin': fn_signin,
};
```

```ts
// 4.controller.js
const fs = require('fs');
// add url-route in /controllers:

function addMapping(router, mapping) {
  for (var url in mapping) {
    if (url.startsWith('GET ')) {
      var path = url.substring(4);
      router.get(path, mapping[url]);
      console.log(`register URL mapping: GET ${path}`);
    } else if (url.startsWith('POST ')) {
      var path = url.substring(5);
      router.post(path, mapping[url]);
      console.log(`register URL mapping: POST ${path}`);
    } else if (url.startsWith('PUT ')) {
      var path = url.substring(4);
      router.put(path, mapping[url]);
      console.log(`register URL mapping: PUT ${path}`);
    } else if (url.startsWith('DELETE ')) {
      var path = url.substring(7);
      router.del(path, mapping[url]);
      console.log(`register URL mapping: DELETE ${path}`);
    } else {
      console.log(`invalid URL: ${url}`);
    }
  }
}

function addControllers(router, dir) {
  fs.readdirSync(__dirname + '/' + dir)
    .filter((f) => {
      return f.endsWith('.js'); //获取说有的 js 文件
    })
    .forEach((f) => {
      console.log(`process controller: ${f}...`);
      let mapping = require(__dirname + '/' + dir + '/' + f);
      addMapping(router, mapping);
    });
}

module.exports = function (dir) {
  let controllers_dir = dir || 'controllers',
    router = require('koa-router')();
  addControllers(router, controllers_dir);
  return router.routes(); //暴露出 router.routes()给 app.js 使用
};
```

## 实现文件上传功能

```js
// 注意：
// content-type: text/html; charset=utf-8 默认情况服务器会根据响应内容自动设置
const Koa = require('koa');
let Router = require('koa-router');
const koaBody = require('koa-body');
const fs = require('mz/fs');

const path = require('path');

const app = new Koa();
const router = new Router();

const uuidv1 = require('uuid/v1'); // 用于生成唯一值

// 打印请求的 url
app.use(async (ctx, next) => {
  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
  await next();
});

app.use(koaBody()); // 解析请求体参数 要不然服务器无法识别

// get 请求
router.get('/api/hello', async (ctx, next) => {
  // console.log(ctx.request.query); // { name: 'koa', password: '12345' } 获取链接上的参数
  ctx.response.body = ctx;
});

// post 请求
router.post('/api/pt', async (ctx, next) => {
  // console.log(ctx.request.query); // { name: 'koa', password: '12345' } 获取链接上的参数
  // console.log(ctx.request.body); // { id: 'test', manufacturer: '测试数据', name: '测试数据 1', price: 888888 } 获取 body 上的数据
  ctx.response.body = ctx;
});

// 文件上传接口
router.post(
  '/api/upload',
  koaBody({
    // 自定义 koaBody 配置选项
    multipart: true, // 是否支持 multipart-formdate 的表单 默认是 false (其实就是是否支持文件上传)
    encoding: 'gzip',
    formidable: {
      uploadDir: path.join(__dirname, 'uploads/files'), // 设置文件默认上传目录 自定义目录和名称可以不写
      keepExtensions: true, // 保持文件的后缀
      maxFieldsSize: 2 * 1024 * 1024, // 文件上传大小
      onFileBegin: (name, file) => {
        // 文件上传前的设置
        // name 是 input type='file' 的 name 属性值
        // file 为单个文件对象 多个文件上传 则 次文件会执行多次

        console.log('=============================');
        console.log(file);
        console.log('=============================');

        let date = new Date();
        let month = Number.parseInt(date.getMonth()) + 1;
        month = month.toString().length > 1 ? month : `0${month}`;
        let fileDir = `${date.getFullYear()}${month}${date.getDate()}`;

        let dir = path.join(__dirname, `uploads/files/${fileDir}`); // 设置文件上传路径 必须真实存在

        /**
         * 要生成文件在自定义的目录中 必须使用同步模式 要不然无法生成在自动目录 而是生成在默认目录下
         */
        try {
          fs.accessSync(dir);
          console.log('可读可写');
          upload();
        } catch (err) {
          console.error('不可访问');
          try {
            fs.mkdirSync(dir);
            upload();
          } catch (err) {
            console.log('err', err);
          }
        }

        function upload() {
          // 自定义生成文件
          let extname = path.extname(file.name);
          let fileName = uuidv1();
          let filePath = path.join(dir, file.name);
          file.path = filePath; // 指定文件生成路径 用于生成文件
        }
      },
    },
  }),
  async (ctx, next) => {
    console.log('上传成功');
    // console.log(ctx.request.files); // 获取上传后文件的信息
    // console.log(ctx.request.body); // 获取其他的表单字段
    ctx.response.body = JSON.stringify(ctx.request.files);
  }
);

// 添加路由中间件
app.use(router.routes()).use(router.allowedMethods());
app.listen(3000);
console.log('app started at port 3000...');
```

## 文件上传的实现(推荐)

```js
// koa有三个中间件可以实现文件上传的功能，分别是
// 1）koa-body
// 2）busboy
// 3）koa-multer
```

```js
// 选择比较简单的koa-body来实现我们的文件上传功能
const Koa = require('koa');
let Router = require('koa-router');
const koaBody = require('koa-body');

const app = new Koa();
const router = new Router();

app.use(
  koaBody({
    multipart: true,
    formidable: {
      maxFileSize: 200 * 1024 * 1024, // 设置上传文件大小最大限制，默认2M
    },
  })
);

// 上传单个文件：
router.post('/uploadfile', async (ctx, next) => {
  // 上传单个文件
  const file = ctx.request.files.file; // 获取上传文件
  // 创建可读流
  const reader = fs.createReadStream(file.path);
  let filePath = path.join(__dirname, 'public/upload/') + `/${file.name}`;
  // 创建可写流
  const upStream = fs.createWriteStream(filePath);
  // 可读流通过管道写入可写流
  reader.pipe(upStream);
  return (ctx.body = '上传成功！');
});

// 上传多个文件:
router.post('/uploadfiles', async (ctx, next) => {
  // 上传多个文件
  const files = ctx.request.files.file; // 获取上传文件
  for (let file of files) {
    // 创建可读流
    const reader = fs.createReadStream(file.path);
    // 获取上传文件扩展名
    let filePath = path.join(__dirname, 'public/upload/') + `/${file.name}`;
    // 创建可写流
    const upStream = fs.createWriteStream(filePath);
    // 可读流通过管道写入可写流
    reader.pipe(upStream);
  }
  return (ctx.body = '上传成功！');
});
```

## koa 基础之 ejs 模板的使用

```js
// 引入模块
const Koa = require('koa');
const router = require('koa-router')(); /*引入是实例化路由 推荐*/
const views = require('koa-views');

// 实例化
let app = new Koa();

// 这样配置也可以 注意如果这样配置的话 模板的后缀名是 .html
app.use(views('views', { map: { html: 'ejs' } }));

router.get('/', async (ctx) => {
  let title = '你好 ejs';
  await ctx.render('index', {
    title: title,
  });
});

router.get('/news', async (ctx) => {
  // ctx.body = '这是一个新闻';
  let list = ['111', '222', '333'];

  let content = '<h2>这是一个h2</h2>';

  let num = 123;

  await ctx.render('news', {
    list: list,
    content: content,
    num: num,
  });
});

app.use(router.routes());
app.use(router.allowedMethods());

app.listen(8000);

/*
ejs 模板引擎的使用：
 * 1.npm install koa-views --save
 * 2.npm install ejs --save
 * 3.var views = require('koa-views');
 * app.use(views(__dirname, { extension: 'ejs' }))
 * 4.await ctx.render('index')
 */
```

## 静态资源的获取

```js
/**
 * koa-static 静态资源中间件 静态web服务
 * 1、cnpm install --save koa-static
 * 2、const static = require('koa-static');
 * 3、配置中间件
 * app.use(static('static'))
 */
// 引入模块
const Koa = require('koa');
const router = require('koa-router')(); /*引入是实例化路由 推荐*/
const views = require('koa-views');
const bodyParser = require('koa-bodyparser');
const static = require('koa-static');

// 实例化
let app = new Koa();

// 应用ejs模板引擎
app.use(views('views', { map: { html: 'ejs' } }));

// http://localhost:8000/css/basic.css 首先去static目录找,如果能找到返回对应的文件,找不到next()

// 配置静态web服务的中间件
// app.use(static('static'));
app.use(static(__dirname + '/static'));

app.use(static(__dirname + '/public')); // koa静态资源中间件可以配置多个

// 配置post bodyparser的中间件
app.use(bodyParser());

router.get('/', async (ctx) => {
  await ctx.render('css');
});

// 接收post提交的数据
router.post('/doAdd', async (ctx) => {
  console.log(ctx.request.body);
  ctx.body = ctx.request.body; // 获取表单提交的数据
});

app.use(router.routes());
app.use(router.allowedMethods());

app.listen(8000);
```

## koa 基础之 cookie 的基本使用

```js
/**
 * cookie的简介：
 * 1、cookie保存在浏览器客户端
 * 2、可以让我们用同一个浏览器访问同一个域名的时候共享数据
 *
 * cookie的作用：
 * 1、保存用户信息
 * 2、浏览器历史记录
 * 3、猜你喜欢的功能
 * 4、10天免登录
 * 5、多个页面之间的数据传递
 * 6、cookie实现购物车功能
 */
// 引入模块
const Koa = require('koa');
const router = require('koa-router')(); /*引入是实例化路由 推荐*/
const render = require('koa-art-template');
const path = require('path');

// 实例化
let app = new Koa();

// 配置 koa-art-template 模板引擎
render(app, {
  root: path.join(__dirname, 'views'), // 视图的位置
  extname: '.html', // 后缀名
  debug: process.env.NODE_ENV !== 'production', // 是否开启调试模式
});

router.get('/', async (ctx) => {
  // 正常就这样配置就可以了
  /**
     ctx.cookies.set('userinfo', 'zhangsan', {
      maxAge: 1000 * 60 * 60
    });
     */

  ctx.cookies.set('userinfo', 'zhangsan11', {
    maxAge: 1000 * 60 * 60,
    // path: '/news', /*配置可以访问的页面*/
    // domain: '.baidu.com', /*正常情况不要设置 默认就是当前域下面的所有页面都可以访问*/
    /**
     * a.baidu.com
     * b.baidu.com 共享cookie
     */
    httpOnly: false, // true表示这个cookie只有服务器端可以访问,false表示客户端(js)、服务器端都可以访问
  });

  let list = {
    name: '张三',
  };
  await ctx.render('cookie', {
    list: list,
  });
});

router.get('/news', async (ctx) => {
  let userinfo = ctx.cookies.get('userinfo');

  let app = {
    name: '张三',
  };
  await ctx.render('cookie-news', {
    list: app,
  });
});

app.use(router.routes());
app.use(router.allowedMethods());

app.listen(8000);
```

## koa 基础之 koa 中 session 的使用

```js
/**
 * koa 中 session 的使用
 * 1、npm install koa-session --save
 * 2、const session = require('koa-session');
 * 3、app.keys = ['some secret hurr'];
 * const CONFIG = {
 *   key: 'koa:sess',
 *   maxAge: 86400000,
 *   overwrite: true,
 *   httpOnly: true,
 *   signed: true,
 *   rolling: false,
 *   renew: false
 * }
 *
 * 4、设置 session
 * ctx.session.username = '张三';
 * 5、获取 session
 * ctx.session.username
 */
// 引入模块
const Koa = require('koa');
const router = require('koa-router')(); /*引入是实例化路由 推荐*/
const render = require('koa-art-template');
const path = require('path');
const session = require('koa-session');

// 实例化
let app = new Koa();

// 配置 koa-art-template 模板引擎
render(app, {
  root: path.join(__dirname, 'views'), // 视图的位置
  extname: '.html', // 后缀名
  debug: process.env.NODE_ENV !== 'production', // 是否开启调试模式
});

// 配置session的中间件
app.keys = ['some secret hurr']; /** cookie的签名 */
const CONFIG = {
  key: 'koa:sess' /** 默认 */,
  maxAge: 86400000 /** cookie的过期时间 【需要修改】*/,
  overwrite: true /** (boolean) can overwrite or not (default true) 没有效果 默认*/,
  httpOnly: true /** true表示只有服务器端可以获取cookie*/,
  signed: true /** 默认 签名 */,
  rolling: false /** 在每次请求时强行设置 cookie,这将重置 cookie 过期时间(默认：false) 【需要修改】*/,
  renew: true /** (boolean) renew session when session is nearly expired 【需要修改】*/,
};
app.use(session(CONFIG, app));

router.get('/', async (ctx) => {
  // 获取session
  console.log(ctx.session.userinfo);
  await ctx.render('index', {
    list: {
      name: '张三',
    },
  });
});

router.get('/news', async (ctx) => {
  // 获取session
  console.log(ctx.session.userinfo);
  ctx.body = '新闻页面';
});

router.get('/login', async (ctx) => {
  // 设置session
  ctx.session.userinfo = '张三';
  ctx.body = '登录成功';
});

app.use(router.routes());
app.use(router.allowedMethods());

app.listen(8000);
```

## Koa 实现重定向

```js
// koa2 301重定向完整代码：
router.get('/', async (ctx) => {
  ctx.status = 301;
  ctx.redirect('/cart');
});

// koa2 302重定向代码：
router.get('/', async (ctx) => {
  ctx.status = 302;
  ctx.redirect('/cart');
});
```

## router.allowedMethods()

```js
// 在加了router.allowedMethods()中间件情况下，如果接口是get请求，而前端使用post请求，会返回405 Method Not Allowed ，提示方法不被允许 ，并在响应头有添加允许的请求方式；而在不加这个中间件这种情况下，则会返回 404 Not Found找不到请求地址，并且响应头没有添加允许的请求方式

app.use(router.routes());
app.use(router.allowedMethods());
```

## Koa 与 Express

```js
// 在理念上，Koa 旨在 “修复和替换节点”，而 Express 旨在 “增加节点”。 Koa 使用Promise(JavaScript一种异步手段)和异步功能来摆脱回调地狱的应用程序，并简化错误处理。 它暴露了自己的 ctx.request 和 ctx.response 对象，而不是 node 的 req 和 res 对象。

// 另一方面，Express 通过附加的属性和方法增加了 node 的 req 和 res 对象，并且包含许多其他 “框架” 功能，如路由和模板，而 Koa 则没有。

// 因此，Koa 可被视为 node.js 的 http 模块的抽象，其中 Express 是 node.js 的应用程序框架。
```

## 资源

```js
// 文档地址
// https://github.com/demopark/koa-docs-Zh-CN

// https://www.kancloud.cn/aibabel/koafornodejs/1813811
```
