# webpack 的使用

## webpack 的安装

- 安装 webpack

```bash
# 安装最新稳定版本
npm i -D webpack
# 安装指定版本
npm i -D webpack@3.0.0
# 安装最新的体验版本
npm i -D webpack@beta
```

- webpack 的启用

```bash
# 命令行的方式运行
node_modules/.bin/webpack
# Npm Script 中定义
"scripts":{
  "start":"webpack --config webpack.config.js"
}
```

## 常用配置项目说明

### Entry

- context

```ts
/**
 * webpack寻找相对路径文件时,会以context为根目录
 * webpack默认当前工作目录为context
 */
module.exports = {
  // 必须为一个绝对路径的字符串
  context: path.resolve(__dirname, 'app')
};
```

- Entry 的类型

```ts
/**
 * 如果是array类型,则搭配output.library配置项使用时,
 * 只有数组中最后一个入口文件的模块会被导出
 */

// string 可以是相对路径
module.exports = {
  entry: './app/entry'
};

// array
module.exports = {
  entry: ['./app/entry1', './app/entry2']
};

// object
module.exports = {
  entry: {
    a: './app/entrya',
    b: ['./app/entryb', './app/entry2']
  }
};
```

- Chunk 的名称

```ts
/**
 * 如果entry是string或array,只会生成一个Chunk,名称是main
 * 如果entry是object,Chunk名称为object中键的名称
 */
```

## Output

- filename

```ts
/**
 * =========filename==========
 * 配置输出文件的名称 为string类型
 * 内在变量
 * 1.id Chunk的唯一标示从0开始
 * 2.name Chunk的名称
 * 3.hash Chunk的唯一标示的Hash只
 * 4.chunkhash Chunk内容的Hash值
 *
 * hash 和 chunkhash的长度是可以指定的
 * [hash:8]代表8位Hash值,默认是20位
 *
 *  ExtractTextWebpackPlugin使用的是根据提取内容代码生成的contenthash
 */

module.exports = {
  output: {
    filename: '[name].js'
  }
};
```

- chunkFilename

```ts
/**
 * =========chunkFilename==========
 * 配置无入口的Chunk在输出时的文件名称
 * 指定在运行过程中生成的chunk在输出时的文件名称
 * 运行时生成chunk的场景包括：
 * 1.使用CommonChunkPlugin
 * 2.使用import('path/to/module')动态加载
 * chunkFilename支持内置变量
 */
```

- path

```ts
/**
 * output.path配置输出文件存放在本地的目录
 * 必须位string类型的绝对路径
 * 内置变量只有一个hash,代表一次编译操作的Hash值
 */

module.exports = {
  output: {
    filename: '[name].js',
    path: path.resolve(__dirname, 'dist_[hash]')
  }
};
```

- publicPath

```ts
/**
 * output.publicPath 配置发布到线上资源的URL前缀,位string类型
 * 默认位空字符串,即使用相当路径
 * 内置变量只有一个hash,代表一次编译操作的Hash值
 */
module.exports = {
  output: {
    filename: '[name]_[chunkhash:8].js',
    publicPath: 'https://www.abc.com/js/'
  }
};

// html文件对相关资源的引用
<script src="https://www.abc.com/js/a_12345678.js"></script>;
```

- crossOriginLoading

```ts
/**
 * webpack通过插入一个<script>标签去加载异步资源(JSONP)的方式
 * output.crossOriginLoading 用于配置这个标签的crossorigin值
 * script标签的crossorigin属性的取值
 * 1.anonymous(默认) 在加载资源的时候不带上用户的Cookies
 * 2.use-credentials 在加载此脚步资源的时候会加上Cookies
 *
 * 通常设置crossorigin来获取异步加载脚步执行时的详细错误信息
 */
```

- libraryTarget 和 library

```ts
/**
 * output.libraryTarget 配置以何种方式导出库
 * output.library 配置导出库的名称
 *
 * output.libraryTarget 是字符串的枚举类型
 * 1.var(默认)
 * 编写的库通过var被赋值给library指定名称的变量(output.library='LibraryName')
 * 使用库的方法 LibraryName.doSomething();
 * 如果output.library的值为空则直接导出库代码内容,一个有返回值的自执行函数
 *
 * 2.commonjs
 * 编写的库通过CommonJS规范导出
 * 假设配置了output.library='LibraryName'
 * 库的使用如下
 * require('npm-module')['LibraryName'].doSomething();
 *
 * 3.commonjs2
 * 编写的库通过CommonJS2的规范导出
 * 无需配置output.library,此时配置output.library没有意义
 * 使用库的方法
 * require('npm-module').doSomething();
 *
 * 4.this
 * 编写的库将通过this被赋值给library指定的名称
 * 假设配置了output.library='libraryName'
 * this.libraryName.doSomething();
 *
 * 5.window
 * 编写的库将通过window被赋值给library指定的名称
 * 假设配置了output.library='libraryName'
 * window.libraryName.doSomething();
 *
 * 6.global
 * 编写的库将通过global被赋值给library指定的名称
 * 假设配置了output.library='libraryName'
 * global.libraryName.doSomething();
 */
```

- libraryExport

```ts
/**
 * output.libraryExport 配置要导出的模块中哪些模块需要被导出
 * 只有在output.libraryTarget被设置成common.js或者commonjs2时才有意义
 *
 * 例如要导出的模块源码是
 * export const a=1;
 * export default b=2;
 *
 * 只导出其中的a
 * 需要将output.libraryExport设置成a
 *
 * 使用库的方法
 * require('npm-module')  // 1
 */
```

### module 配置处理模块的规则

- rules

```ts
/**
 * rules配置模块的读取和解析规则,通常用来配置Loader
 */

// 命中js文件
module: {
  rules: [
    {
      test: /\.js$/, // 命中js文件
      // 使用bable-loader转换js文件
      // 传递cacheDirectory参数用于缓存编译结构,加快编译速度
      use: ['babel-loader?cacheDirectory'],
      // 只命中src目录里的js文件 加快webpack的搜索速度
      include: path.resolve(__dirname, 'src')
    }
  ];
},

// 命中scss文件
module: {
  rules: [
    {
      test: /\.scss$/,
      // 使用一组loader去处理SCSS文件
      // 处理顺序由后到前
      use: ['style-loader', 'css-loader', 'sass-loader'],
      // 排除node_modules目录下的文件
      exclude: path.resolve(__dirname, 'node_modules')
    }
  ];
},

// 对非文本文件采用file-loader加载
module: {
  rules: [
    {
      test: /\.(gif|png|jpe?g|eot|woff|ttf|svg|pdf)$/,
      use: ['file-loader'],
    }
  ];
},

// 当loader需要传入多个参数的时候
module: {
  rules: [
    {
      test: /\.js$/, // 命中js文件
      // 使用bable-loader转换js文件
      // 传递cacheDirectory参数用于缓存编译结构,加快编译速度
      use:[
        {
          loader:'babel-loader',
          options:{
            cacheDirectory:true,
          },
          // enforce:'post'的含义是将该Loader的执行顺序放在最后
          // enforce:'pre'的含义是将该Loader的执行顺序放在最前
          enforce:'post',
        }
      ],
    }
  ];
},

// test, include, exclude 支持数组类型
test:[/\.jsx?$/,/\.tsx?$/]
include:[
  path.resolve(__dirname, 'src'),
  path.resolve(__dirname, 'tests'),
],
exclude:[
  path.resolve(__dirname, 'node_modules'),
  path.resolve(__dirname, 'bower_modules'),
];

```

- noParse

```ts
/**
 * noParse配置项可以让webpack忽略对部分没有采用模块化的文件递归解析和处理
 * noParse是可选配置项 类型是RegExp,[RegExp],function
 */

// 忽略jQuery,ChartJS
// 使用正则表达式
noParse: /jquery|chartjs/;

// 使用函数3.0版本开始支持
noParse: content => {
  // content代表一个模块的文件路径
  // 返回true或false
  return /jquery|charjs/.test(content);
};
```

- parser

```ts
/**
 * webpack默认支持AMD，CommonJS, SystemJS, ES6的解析
 * parser属性可以更细粒度地配置哪些模块语法被解析,哪些不被解析
 */

module: {
  rules: [
    {
      test: /\.js$/,
      use: ['babel-loader'],
      parser: {
        amd: false, // 禁用AMD
        commonjs: false, // 禁用CommonJS
        system: false, // 禁用SystemJS
        harmony: false // ES6 import/export
      }
    }
  ];
}
```

### Resolve 配置 webpack 如何寻找模块所对对应的文件

- alias 别名

```ts
/**
 * resolve.alias通过别名来将原导入路径映射成一个新的导入路径
 */

// 当通过import Button from 'components/button'导入时
// 实际上被alias等价替换成
// import Button from './src/components/button'
resolve: {
  alias: {
    components: './src/components/';
  }
}

// 也可以使用$符号来缩写范围
// 只会命中以react为结尾的导入语句
// import 'react';被替换为import '/path/to/react.min.js'
resolve: {
  alias: {
    'react$': '/path/to/react,min.js';
  }
}
```

- mainFields

```ts
/**
 * 一些第三方模块会针对不同的环境提供几份代码,如ES5,ES6
 * resolve.mainFields webpack会根据mainFields的配置去决定优先采取那份代码
 */

// mainFields默认配置如需:
mainFields: ['browser', 'main'];

// webpack会根据数组里的顺序在package.json文件中查找,只会使用找到的第一个文件
```

- extensions

```ts
/**
 * resolve.extensions 导入语句没有带文件后缀的时候,webpack会自动带上后缀去尝试访问文件是否存在
 */

// 默认配置为
extensions: ['.js', '.json'];

// 设置webpack优先使用目录下的ts文件
extensions: ['.ts', '.js', '.json'];
```

- modules

```ts
/**
 * resolve.modules配置webpack去哪些目录下寻找第三方模块,默认只会去node_module目录下寻找
 */

// 假设被大量导入的模块都在./src/components目录下
modules: ['./src/components', 'node_modules'];
// 然后可以通过下面方式导入组件
import 'button';
```

- descriptionFiles

```ts
/**
 * resolve.descriptionFiles配置描述第三方模块的文件名称,也就是package.json文件
 */

// 默认配置
descriptionFiles: ['package.json'];
```

- enforceExtension 与 enforceModuleExtension

```ts
/**
 * resolve.enforceExtension被配置为true,则所有导入语句都必须带文件后缀
 *
 * resolve.enforceModuleExtension只对node_modules下的模块生效
 * 第三方模块导入通常没有带后缀名
 * 通过设置resolve.enforceModuleExtension:false来兼容第三方模块
 */
```

### Plugin

```ts
/**
 * plugin用于扩展webpack的功能
 * plugin配置项接收一个数组
 * 数组中的每一项都是一个要使用的Plugin的实例
 * plugin需要的参数通过构造函数传入
 */

const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');
module.exports = {
  plugins: [
    // 所有页面都会用到的公共代码被提取到common代码块中
    new CommonsChunkPlugin({
      name: 'common',
      chunks: ['a', 'b']
    })
  ]
};
```

### DevServer

- devServer.hot 配置是否启用模块热替换功能

```ts
/**
 * 可以在不刷新整个界面的情况下用新模块替换老模块来做到实时预览
 */
```

- devServer.inline

```ts
/**
 * devServer.inline用于配置是否将代理客户端自动注入将运行页面中的Chunk里,默认自动注入
 *
 * 如果开启：构建变化后的代码时,通过代理客户端控制网页刷新
 *
 * 如果关闭：通过iframe的方式去运行要开发的网页
 * 通过刷新iframe来实现实时预览
 * 访问地址：http://localhost:8080/webpack-dev-server/实时预览的界面
 */
```

- devServer.historyApiFallback

```ts
/**
 * devServer.historyApiFallback 用于方便地开发用于HTML5 History API的单页面运用
 * 在访问命中路由的时候返回对于的界面
 */

// 最简单的配置devServer.historyApiFallback的方法,任何请求都会返回index.html
historyApiFallback: true;

// 配置根据不同的请求返回不同的html文件

historyApiFallback: {
  rewrites: [
    // /user开头的都返回user.html
    { from: /^\/user/, to: '/user.html' },
    { from: /^\/game/, to: '/game.html' },

    // 其他返回index.html
    { from: /./, to: '/index.html' }
  ];
}
```

- devServer.contentBase

```ts
/**
 * devServer.contentBase配置DevServer HTTP服务器文件根目录
 * 默认情况下为当前的执行目录,通常是项目根目录
 *
 * contentBase只能用来配置暴露本地文件的规则 通过配置contentBase:false来关闭暴露本地文件
 */

// 将项目根目录下的public目录设置为DevServer服务器的文件根目录
devServer: {
  contentBase: path.join(__dirname, 'public');
}
```

- devServer.headers

```ts
/**
 * devServer.headers可以在HTTP响应中注入HTTP响应头
 */
devServer:{
  headers:{
    'X-foo':'bar'
  }
}
```

- devServer.host

```ts
/**
 * devServer.host 用于配置DevServer服务监听的地址
 * host的默认值是127.0.0.1 只有本地可以访问
 *
 * 如果想让局域网中其他设备可以访问
 * 启动DevServer的时候带上 --host 0.0.0.0
 */
```

- devServer.port

```ts
/**
 * 配置DevServer服务监听端口,默认是8080
 */
```

- devServer.allowedHosts

```ts
/**
 * devServer.allowedHosts配置一个白名单列表 只有HTTP请求的HOST在列表里才正常返回
 */

allowedHosts: [
  // 配置单个域名
  'host.com',
  'sub.host.com',

  // host2.com和所有的子域名都将被匹配
  '.host2.com'
];
```

- devServer.disableHostCheck

```ts
/**
 * devServer.disableHostCheck 配置是否关闭用于DNS重新绑定的HTTP请求的HOST检查
 * 关闭后可以接受来自任何host的请求
 * 搭配 --host 0.0.0.0 使用,让其他设备访问自己的本地服务
 */

allowedHosts: [
  // 配置单个域名
  'host.com',
  'sub.host.com',

  // host2.com和所有的子域名都将被匹配
  '.host2.com'
];
```

- devServer.https

```ts
/**
 * devServer.https配置切换为HTTPS服务 默认为HTTP服务
 */

// 自动生成HTTPS证书
devServer: {
  https: true;
}

// 使用自己的证书
devServer: {
  https:{
    key:fs.readFileSync('path/to/server.key'),
    cert:fs.readFileSync('path/to/server.crt'),
    ca:fs.readFileSync('path/to/ca.pem'),
  }
}
```

- devServer.clientLogLevel

```ts
/**
 * devServer.clientLogLevel 配置客户端的日志等级
 * 会影响浏览器开发者工具看到的日志内容,默认为info级别,输出所有类型的日志
 *
 * 可取如下值
 * none,error,warning,info
 */
```

- devServer.compress

```ts
/**
 * devServer.compress 配置是否启用Gzip压缩,默认为false
 */
```

- devServer.open

```ts
/**
 * devServer.open 用于DevServer启动且第一次完成构建时，自动用我们系统默认的浏览器去打开要开发的网页
 * devServer.openPage配置项用于打开指定的url网页
 */
```

### 其他配置项

- Target

```ts
/**
 * target配置项可以让webpack构建出针对不同运行环境的代码
 * 1.web 针对浏览器(默认),代码都集中在一个文件里
 * 2.node 针对node.js 使用require语句加载Chunk代码
 * 3.async-node 针对node.js 异步加载Chunk代码
 * 4.webworker 针对WebWorker
 * 5.electron-main 针对Electron主线程
 * 6.electron-renderer 针对Electron渲染线程
 *
 * 当设置target:'node',require('fs')语句会被保留,fs模块不会被打包到Chunk里
 */
```

- Devtool

```ts
/**
 * devtool配置webpack如何生成Source Map,默认值为false,即不生成Source Map
 */

// 构建出来的代码生成Source Map方便调试
module.export = {
  devtool: 'source-map'
};
```

- Watch 和 WatchOptions

```ts
/**
 * 监听模式默认是关闭的
 * 在使用DevServer时,监听模式默认是开启的
 */

// 开启监听模式
module.export = {
  watch: true
};

// watchOptions配置项去更加灵活地控制监听模式
moudle.export = {
  // 只有在开启监听模式时,watchOptions才会有意义
  watcch: true,
  watchOptions: {
    // 不监听的文件或文件夹,支持正则匹配,默认为空
    ignored: /node_modules/,
    // 监听变化后等待300ms再去执行动作
    aggregateTimeout: 300,
    // 默认每次询问系统文件变化情况的时间 默认每秒询问1000次
    poll: 1000
  }
};
```

- Externals

```ts
/**
 * externals 告诉webpack要构建的代码中使用来哪些不用被打包的模块
 * 不用将全局变量打包到代码中而是直接使用它们
 */

module.export = {
  externals: {
    // 将导入语句中的jquery替换成运行环境里的全局变量jQuery
    jquery: 'jQuery'
  }
};

// 代码中引入jquery
import $ from 'jquery';
```

- ResolveLoader

```ts
/**
 * ResolveLoader用于告诉webpack如何去寻找Loader
 * 常用于加载本地的Loader
 */

// ResolveLoader的默认配置
module.exports = {
  resolveLoader: {
    // 去那个目录下寻找Loader
    modules: ['node_modules'],
    // 入口文件的后缀
    extensions: ['.js', '.json'],
    // 指明入口文件的字段
    mainFields: ['loader', 'main']
  }
};
```

## 多种配置类型

- 导出一个 Function

```ts
/**
 * 只写一个配置文件即可满足在开发和生产环境下的构建切换
 * 运行webpack时会向函数传入两个参数
 * 1.env
 * 如启动命令是 webpack --env.production --env.bao=foo,
 * 则env的值为{"production":true,"bao":"foo"}
 *
 * 2.argv
 * 代表启动webpack时通过命令行传入的所有参数
 * 例如--config --env --devtool
 * 通过webpack -h 列出所有webpack支持的命令行参数
 *
 * 需要构建生产代码的时候只需要执行
 * webpack --env.production --config webpack.config.js
 */

// webpack.config.js
const path = require('path');
const UglifyJsPlugin = require('UglifyJsPlugin');

module.exports = function(env = {}, argv) {
  const plugins = [];
  const isProduction = env['production'];

  // 在生产环境中才压缩
  if(isProduction){
    plugins.push(
      // 压缩输出的js代码
      new UglifyJsPlugin();
    )
  }

  return {
    plugins:plugins,
    // 生产环境中不输出Source Map
    devtool:isProduction?undefined:'source-map'
  }
};
```

- 导出一个返回的 Promise 函数

```ts
/**
 * 某些情况下不能以同步的方式返回
 */

module.exports = function(env = {}, argv) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, 5000);
  });
};
```

- 导出多份配置

```ts
/**
 * webpack支持导出一个数组,数组里的每一份配置都会执行一遍构建 3.1.0版本才支持该特性
 * 适用于构建一个需要上传到NPM仓库的文件,包含多种格式化的代码 例如CommonJS , UMD
 */

module.exports = {
  // 多份配置
};
```

## 总结

```bash
1.源文件加入构建流需要配置entry
2.文件输出位置需要配置output
3.寻找依赖模块策略配置resolve
4.解析和转换文件的策略配置module.rules
5.其他需要使用Plugin配置实现

```
