# Webpack 运行机制

## webpack 的运行机制

- 处理流程

```js
// 初始化配置参数 -> 绑定事件钩子回调 -> 确定Entry逐一遍历 -> 使用loader编译文件 -> 输出文件

// Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。
// Webpack 通过 Tapable 来组织这条复杂的生产线。
// Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。
```

- Tapable 的原理

```js
// 通过发布者-订阅者模式实现，它的部分核心代码可以概括成下面这样：
// 所有的编译过程的生命周期钩子事件都放在hooks数组中统一管理
class SyncHook {
  constructor() {
    this.hooks = [];
  }

  // 订阅事件
  tap(name, fn) {
    this.hooks.push(fn);
  }

  // 发布
  call() {
    this.hooks.forEach(hook => hook(...arguments));
  }
}
```

- webpack 运行环节

```js
// 1.初始化参数
//   读取webpack.config.js文件,执行配置文件中的实例化语句
//   生成Complier传入的plugin的apply方法为webpack事件流挂上自定义钩子
// 2.environment
//   开始读取配置的entries,递归遍历所有的入口文件
// 3.entryOption
// 4.run
// 5.compiler
// 6.compilation(开始)
// 7.make(开始编译)
// 8.compilation(过程)
//   用用户配置好的loader对文件内容进行编译(buidModule)
//   编译好的文件内容使用acorn解析生成AST静态语法书(normalModuleLoader)
//   逐个拉取依赖关系递归操作,最后将所有的模块中的require语法替换成__webpack_require__来模拟模块化操作
//   buidModule -> normalModuleLoader -> seal
// 9.emit
// 完成所有的文件的编译及转换,可以在事件回调的compilation.assets上拿到所需数据(包括输出资源，代码块Chunk等)
// 10.done / failed
```

- 什么是 AST

```js
// AST:抽象语法书(Abstract Syntax Tree)简称语法树
// 它以树状的形式表现编程语言中的语法结果，树上的每一个节点表示源代码的一种结构
// 转换成AST的目的就是将我们书写的字符串文件转换成计算机更容易识别的数据结构
```

- webpack 输出结果源码阅读(没有设置 splitChunk)

```js
// 大致逻辑
// 引入的各个依赖模块会以key是路径,value是模块的执行代码的对象作为参数传入下面的立即调用函数中
// installedModules对象用于存储已经加载的模块
// 如果模块已经加装则直接返回该模块下的exports属性,包含了该模块所要执行的程序
// 如果模块没有被加载过这个设置key为改模块的路径(moduleId),并执行改模块下的方法并保存在exports属性中
// 设置模块是否已经加载的标志为true,标识该模块已经加载
// 会递归执行模块中出现的__webpack_require__()方法 并重复上面的步骤

//  __webpack_require__ 为最终输出的文件已经转换好了
(function (modules) {
  //  缓存已经加载过的module的exports
  //  module在exports之前还是有js需要执行的，缓存的目的就是优化这一过程
  // The module cache
  var installedModules = {};

  // The require function
  /**
   * 模拟CommonJS require()
   * @param {String} moduleId 模块路径
   */
  function __webpack_require__(moduleId) {

    // Check if module is in cache
    if (installedModules[moduleId]) {
      return installedModules[moduleId].exports;
    }
    // Create a new module (and put it into the cache)
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {}
    };

    // 执行单个module JS Function并填充installedModules与module
    // function mudule(module, __webpack_exports__[, __webpack_require__])
    // Execute the module function
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

    // Flag the module as loaded
    module.l = true;

    // Return the exports of the module
    return module.exports;
  }

  // expose the modules object (__webpack_modules__)
  __webpack_require__.m = modules;

  // expose the module cache
  __webpack_require__.c = installedModules;

 ......

  // __webpack_public_path__
  __webpack_require__.p = "";

  // 加载Entry并返回Entry的exports
  // Load entry module and return exports
  return __webpack_require__(__webpack_require__.s = "./src/index.js");
})
  // modules其实就是一个对象，键是模块的路径，值就是模块的JS Function
  ({
    "./src/index.js": function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module.js */ \"./src/module.js\");\n/* harmony import */ var _module_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_module_js__WEBPACK_IMPORTED_MODULE_0__);\n{};\nconsole.log(_module_js__WEBPACK_IMPORTED_MODULE_0___default.a.s);\n\n//# sourceURL=webpack:///./src/index.js?");
    },
    "./src/module.js": function (module, exports) {
      eval("{};var s = 123;\nconsole.log(s);\nmodule.exports = {\n  s: s\n};\n\n//# sourceURL=webpack:///./src/module.js?");
    }
  });
```

- webpack 输出结果源码阅读(设置 splitChunk)

```js
//简单来说就是把拆分出来的文件分别读取依赖并用__webpack_require__()分别生成各自的文件

// 如果我们配置了splitChunk，这时候输出的文件就和你的Chunk挂钩了
// webpackJsonpCallback 处理chunk数据
// @param {Array} data  [[chunkId(chunk名称)], modules(Object), [...other chunks(所有需要的chunk)]]
// webpackJsonpCallback([0,1], {
//   2: function(){},
//   3:function(){}
// }, [2]);
//  1.chunk1有可能依赖chunk0，要先执行chunk0，也有可能chunk0已经执行过了，所以需要判断
//  2.将module = 2/3 的定义保存在modules对象中
//  3.执行module = 2的模块的代码，注入三个参数


// 首先判断 chunkIds 在 installedChunks 里没有回调函数未执行完， 有的话则放到 callbacks 中， 并且等一下统一执行，j 将 chunkIds 在 installedChunks 中全部表为 0， 然后将 moreModules 合并到 modules 中。

// 将 callbacks 执行完毕并清空， 保证了该模块加载开始前所有前置依赖内容都会加载完毕。
// 最后判断 morMModules[0]。有值说明该文件为入口文件，则开始执行入口文件的模块

// 这里面只有 mouules[0] 不是固定的，其他 modules 下标都是唯一的


//@file: dist/common/runtime.js
 // 当配置了splitChunk之后，此时IIFE的形参modules就成了摆设，
 // 真正的module还有chunk都被存放在了一个挂载在window上的全局数组`webpackJsonp`上了
 (function(modules) { // webpackBootstrap
	 // install a JSONP callback for chunk loading
	 /**
	  * webpackJsonpCallback 处理chunk数据
	  * @param {Array} data  [[chunkId(chunk名称)], modules(Object), [...other chunks(所有需要的chunk)]]
	  */
 	function webpackJsonpCallback(data) {
    // chunk的名称，如果是entry chunk也就是我们entry的key
 		var chunkIds = data[0];
    // 依赖模块
 		var moreModules = data[1];
 		var executeModules = data[2];

 		// add "moreModules" to the modules object,
 		// then flag all "chunkIds" as loaded and fire callback
 		var moduleId, chunkId, i = 0, resolves = [];
 		for(;i < chunkIds.length; i++) {
 			chunkId = chunkIds[i];
 			if(installedChunks[chunkId]) {
 				resolves.push(installedChunks[chunkId][0]);
 			}
 			installedChunks[chunkId] = 0;
 		}
 		for(moduleId in moreModules) {
 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
 				modules[moduleId] = moreModules[moduleId];
 			}
 		}
 		if(parentJsonpFunction) parentJsonpFunction(data);

 		while(resolves.length) {
 			resolves.shift()();
 		}

 		// add entry modules from loaded chunk to deferred list
 		deferredModules.push.apply(deferredModules, executeModules || []);

 		// run deferred modules when all chunks ready
 		return checkDeferredModules();
 	};
 	function checkDeferredModules() {
 		var result;
 		for(var i = 0; i < deferredModules.length; i++) {
 			var deferredModule = deferredModules[i];
 			var fulfilled = true;
 			for(var j = 1; j < deferredModule.length; j++) {
 				var depId = deferredModule[j];
 				if(installedChunks[depId] !== 0) fulfilled = false;
 			}
 			if(fulfilled) {
 				deferredModules.splice(i--, 1);
 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
 			}
 		}
 		return result;
 	}

 	// The module cache
 	var installedModules = {};

	// 缓存chunk，同理module
 	// object to store loaded and loading chunks
 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
 	// Promise = chunk loading, 0 = chunk loaded
 	var installedChunks = {
 		"common/runtime": 0
 	};

 	var deferredModules = [];

 	// The require function
 	function __webpack_require__(moduleId) {
 		// Check if module is in cache
 		if(installedModules[moduleId]) {
 			return installedModules[moduleId].exports;
 		}
 		// Create a new module (and put it into the cache)
 		var module = installedModules[moduleId] = {
 			i: moduleId,
 			l: false,
 			exports: {}
 		};
 		// Execute the module function
 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
 		// Flag the module as loaded
 		module.l = true;
 		// Return the exports of the module
 		return module.exports;
 	}


 	// expose the modules object (__webpack_modules__)
 	__webpack_require__.m = modules;

 	// expose the module cache
 	__webpack_require__.c = installedModules;

 	......

 	// __webpack_public_path__
 	__webpack_require__.p = "";

 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
 	jsonpArray.push = webpackJsonpCallback;
 	jsonpArray = jsonpArray.slice();
 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
 	var parentJsonpFunction = oldJsonpFunction;


 	// run deferred modules from other chunks
 	checkDeferredModules();
 })([]);
//@file: dist/common/utils.js
(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["common/utils"], {
  "./src/index.js": function (module, __webpack_exports__, __webpack_require__) {
    "use strict";
    eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module.js */ \"./src/module.js\");\n/* harmony import */ var _module_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_module_js__WEBPACK_IMPORTED_MODULE_0__);\n{};\nconsole.log(_module_js__WEBPACK_IMPORTED_MODULE_0___default.a.s);\n\n//# sourceURL=webpack:///./src/index.js?");
  },
  "./src/module.js": function (module, exports) {
    eval("{};var s = 123;\nconsole.log(s);\nmodule.exports = {\n  s: s\n};\n\n//# sourceURL=webpack:///./src/module.js?");
  }
}]);
```

- 开启多线程提升编译速度

```js
// 主要花费时间的部分也就是递归遍历各个entry然后寻找依赖逐个编译的过程
// 每次递归都需要经历 String->AST->String 的流程，经过loader还需要处理一些字符串或者执行一些JS脚本
// node.js单线程,可以使用happypack开启

// 利用了node.js原生的cluster模块去开辟多进程执行构建
// 估计到版本5多进程构建已经被集成在webpack本身上了(webpack4目前还没有集成)
// @file: webpack.config.js
const HappyPack = require('happypack');
const os = require('os');
// 开辟一个线程池
// 拿到系统CPU的最大核数，让happypack将编译工作灌满所有CPU核
const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });

module.exports = {
  // ...
  plugins: [
    new HappyPack({
      id: 'js',
      threadPool: happyThreadPool,
      loaders: ['babel-loader']
    }),

    new HappyPack({
      id: 'styles',
      threadPool: happyThreadPool,
      loaders: ['style-loader', 'css-loader', 'less-loader']
    })
  ]
};
```

## 编写自定义 webpack loader

- 一个最简单的 loader

```js
/**
 * loader Function
 * @param {String} content 文件内容
 */
module.exports = function(content) {
  return '{};' + content;
};

// webpack.config.js中的配置
{
  test: /\.js$/,
  exclude: /node_modules/,
  use: {
      //这里是我的自定义loader的存放路径
      loader: path.resolve('./loaders/index.js'),
      options: {
        test: 1
      }
  }
}
```

- Loader 实战常用技巧

```js
// 通过 loader-utils 获取loader的配置信息
const loaderUtils = require('loader-utils');

module.exports = function(content) {
  // 获取用户配置的options
  const options = loaderUtils.getOptions(this);
  console.log('***options***', options);
  return '{};' + content;
};

// 使用 this.callback 方法去导出数据
// this.callback 可以传入四个参数（其中后两个参数可以省略），他们分别是：
// error：Error | null，当loader出错时向外跑出一个Error
// content：String | Buffer，经过loader编译后需要导出的内容
// sourceMap：为方便调试生成的编译后内容的source map
// ast: 本次编译生成的AST静态语法树，之后执行的loader可以直接使用这个AST，可以省去重复生成AST的过程
module.exports = function(content) {
  //return "{};" + content
  this.callback(null, '{};' + content);
};

// 异步loader
// 通过this.async
// 返回一个callback Function，在适当时候执行这个callback就可以了
module.exports = function(content) {
  function timeout(delay) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve('{};' + content);
      }, delay);
    });
  }
  const callback = this.async();
  timeout(1000).then(data => {
    callback(null, data);
  });
};
```

- loaders 的执行顺序

```js
// loader的执行顺序是从后往前的，你也可以把它理解为这个loaders数组的出栈过程
```

- loader 缓存

```js
// webpack增量编译机制会观察每次编译时的变更文件，在默认情况下，webpack会对loader的执行结果进行缓存，这样能够大幅度提升构建速度
// 可以手工关闭缓存
module.exports = function(content) {
  //关闭loader缓存
  this.cacheable(false);
  return '{};' + content;
};
```

- pitch 钩子全程传参

```js
// 在loader文件里你可以exports一个命名为 pitch 的函数，它会先于所有的loader执行
module.exports.pitch = (remaining, preceding, data) => {
  console.log('***remaining***', remaining);
  console.log('***preceding***', preceding);
  // data会被挂在到当前loader的上下文this上在loaders之间传递
  data.value = 'test';
};

// 它可以接受三个参数，最重要的就是第三个参数data，你可以为其挂在一些所需的值，
// 一个rule里的所有的loader在执行时都能拿到这个值。
module.exports = function(content) {
  //***this data*** test
  console.log('***this data***', this.data.value);
  return '{};' + content;
};

module.exports.pitch = (remaining, preceding, data) => {
  data.value = 'test';
};
```

## 插件

```js
// 可以通过 tap 方法监听事件，使用 call 方法广播事件
// compiler.hooks.someHook.tap(/* ... */);
// 在webpack事件流上挂载回调的方法，在回调里执行你所需的操
```

- 实现一个简单的 webpack 插件

```js
//@file: plugins/myplugin.js
class myPlugin {
    constructor(options){
        //用户自定义配置
        this.options = options
        console.log(this.options)
    }
    apply(compiler) {
        console.log("This is my first plugin.")
    }
}

module.exports = myPlugin

// 使用
const MyPlugin = require('./plugins/myplugin-4.js')

module.exports = {
    ......,
    plugins: [
        new MyPlugin("Plugin is instancing.")
    ]
}
```

- 自定义 webpack 事件流事件

```js
// 引入Tapable并找到你想用的hook，同步hook or 异步hook
const { SyncHook } = require('tapable');
// 实例化Tapable中你所需要的hook并挂载在compiler或compilation上
compiler.hooks.myHook = new SyncHook(['data']);

// 在你需要监听事件的位置tap监听
compiler.hooks.myHook.tap('Listen4Myplugin', data => {
  console.log('@Listen4Myplugin', data);
});

// 在你所需要广播事件的时机执行call方法并传入数据
compiler.hooks.environment.tap(pluginName, () => {
  //广播自定义事件
  compiler.hooks.myHook.call("It's my plugin.");
});
```

- 自定义插件里实例化一个 hook 并挂载在 webpack 事件流上

```js
// @file: plugins/myplugin.js
const pluginName = 'MyPlugin';
// tapable是webpack自带的package，是webpack的核心实现
// 不需要单独install，可以在安装过webpack的项目里直接require
// 拿到一个同步hook类
const { SyncHook } = require('tapable');
class MyPlugin {
  // 传入webpack config中的plugin配置参数
  constructor(options) {
    // { test: 1 }
    console.log('@plugin constructor', options);
  }

  apply(compiler) {
    console.log('@plugin apply');
    // 实例化自定义事件
    compiler.hooks.myPlugin = new SyncHook(['data']);

    compiler.hooks.environment.tap(pluginName, () => {
      //广播自定义事件
      compiler.hooks.myPlugin.call("It's my plugin.");
      console.log('@environment');
    });

    // compiler.hooks.compilation.tap(pluginName, (compilation) => {
    // 你也可以在compilation上挂载hook
    // compilation.hooks.myPlugin = new SyncHook(['data'])
    // compilation.hooks.myPlugin.call("It's my plugin.")
    // });
  }
}
module.exports = MyPlugin;

// 在监听插件里监听我的自定义事件
// @file: plugins/listen4myplugin.js
class Listen4Myplugin {
  apply(compiler) {
    // 在myplugin environment 阶段被广播
    compiler.hooks.myPlugin.tap('Listen4Myplugin', data => {
      console.log('@Listen4Myplugin', data);
    });
  }
}

module.exports = Listen4Myplugin;

// 在webpack配置里引入两个插件并实例化
// @file: webpack.config.js
const MyPlugin = require('./plugins/myplugin-4.js')
const Listen4Myplugin = require('./plugins/listen4myplugin.js')

module.exports = {
    ......,
    plugins: [
        new MyPlugin("Plugin is instancing."),
        new Listen4Myplugin()
    ]
}
```

- 实战剖析

```js
// html-webpack-plugin ，我们发现在readme底部有这样一段demo
function MyPlugin(options) {
  // Configure your plugin with options...
}

MyPlugin.prototype.apply = function(compiler) {
  compiler.hooks.compilation.tap('MyPlugin', compilation => {
    console.log('The compiler is starting a new compilation...');

    compilation.hooks.htmlWebpackPluginAfterHtmlProcessing.tapAsync(
      'MyPlugin',
      (data, cb) => {
        data.html += 'The Magic Footer';

        cb(null, data);
      }
    );
  });
};

module.exports = MyPlugin;
```

## 参考文章

- [webpack4.0 源码分析之 Tapable](https://juejin.im/post/5abf33f16fb9a028e46ec352)
- [webpack4 提升 180%编译速度](https://www.cnblogs.com/yangsg/p/10601604.html)
- [编写自定义 webpack loader](https://github.com/jerryOnlyZRJ/webpack-loader/blob/master/docs/webpack-loader.md)
- [编写自定义 webpack plugin](https://github.com/jerryOnlyZRJ/webpack-loader/blob/master/docs/webpack-plugin.md)
