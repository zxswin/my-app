# webpack 基本概念

## 概念

```bash
# 当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，
# 其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。

# 从 webpack v4.0.0 开始，可以不用引入一个配置文件
# webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）
# loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块

# 通过选择 development 或 production 之中的一个，
# 来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化
```

## 入口起点(entry points)

```bash
# entry 属性传入「文件路径(file path)数组」将创建“多个主入口(multi-main entry)”。

# 推荐使用对象语法
# 单页面运用程序
const config = {
  entry: {
    app: './src/app.js',
    vendors: './src/vendors.js'
  }
};
# 多页面运用程序
const config = {
  entry: {
    pageOne: './src/pageOne/index.js',
    pageTwo: './src/pageTwo/index.js',
    pageThree: './src/pageThree/index.js'
  }
};
```

## 输出(output)

```bash
# 只指定一个输出配置

# 一个入口起点
const config = {
  output: {
    filename: 'bundle.js',
    path: '/home/proj/public/assets'
  }
};

module.exports = config;

# 多个入口起点
{
  entry: {
    app: './src/app.js',
    search: './src/search.js'
  },
  output: {
    filename: '[name].js',
    path: __dirname + '/dist'
  }
}

// 写入到硬盘：./dist/app.js, ./dist/search.js

# 高级进阶
# 使用 CDN 和资源 hash 的复杂示例
output: {
  path: "/home/proj/cdn/assets/[hash]",
  publicPath: "http://cdn.example.com/assets/[hash]/"
}

# 如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置
__webpack_public_path__ = myRuntimePublicPath

// 剩余的应用程序入口
```

## 模式(mode)

```bash
# 提供 mode 配置选项，告知 webpack 使用相应模式的内置优化。
# 只设置 NODE_ENV，则不会自动设置 mode
module.exports = {
  mode: 'production'
};

# 也可以通过Cli参数传递
webpack --mode=production

# 支持的参数类型
# development
// webpack.development.config.js
module.exports = {
+ mode: 'development'
- plugins: [
-   new webpack.NamedModulesPlugin(),
-   new webpack.DefinePlugin({ "process.env.NODE_ENV": JSON.stringify("development") }),
- ]
}

# production
// webpack.production.config.js
module.exports = {
+  mode: 'production',
-  plugins: [
-    new UglifyJsPlugin(/* ... */),
-    new webpack.DefinePlugin({ "process.env.NODE_ENV": JSON.stringify("production") }),
-    new webpack.optimize.ModuleConcatenationPlugin(),
-    new webpack.NoEmitOnErrorsPlugin()
-  ]
}
```

## loader

```bash
# loader 可以使你在 import 或"加载"模块时预处理文件

# 通过配置方式使用loader
module.exports = {
  module: {
    rules: [
      { test: /\.ts$/, use: 'ts-loader' },
      {
        test: /\.css$/,
        use: [
          { loader: 'style-loader' },
          {
            loader: 'css-loader',
            options: {
              modules: true
            }
          }
        ]
      }
    ]
  }
}

# 通过内联方式使用loader
# 使用 ! 将资源中的 loader 分开
# 选项可以传递查询参数，例如 ?key=value&foo=bar，
# 或者一个 JSON 对象，例如 ?{"key":"value","foo":"bar"}。
import Styles from 'style-loader!css-loader?modules!./styles.css';

# 通过 CLI 使用 loader
webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader'

```

## 插件(plugins)

```bash
# webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上
# 插件目的在于解决 loader 无法实现的其他事

# 使用插件
# 插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例
const HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装
const webpack = require('webpack'); //访问内置的插件
const path = require('path');

const config = {
  entry: './path/to/my/entry/file.js',
  output: {
    filename: 'my-first-webpack.bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        use: 'babel-loader'
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};

module.exports = config;

# 使用 Node API 的方式
# some-node-script.js
const webpack = require('webpack'); //访问 webpack 运行时(runtime)
const configuration = require('./webpack.config.js');

let compiler = webpack(configuration);
compiler.apply(new webpack.ProgressPlugin());

compiler.run(function(err, stats) {
  // ...
});
```

## 配置(configuration)

```bash
# webpack 配置是标准的 Node.js CommonJS 模块
# 通过 require(...) 导入其他文件
# 通过 require(...) 使用 npm 的工具函数
# 使用 JavaScript 控制流表达式，例如 ?: 操作符
# 对常用值使用常量或变量
# 编写并执行函数来生成部分配置

var path = require('path');
module.exports = {
  mode: 'development',
  entry: './foo.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'foo.bundle.js'
  }
};
```

## 模块(modules)

```bash
# 对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系
# ES2015 import 语句
# CommonJS require() 语句
# AMD define 和 require 语句
# css/sass/less 文件中的 @import 语句。
# 样式(url(...))或 HTML 文件(<img src=...>)中的图片链接(image url)
```

## 模块解析(module resolution)

```bash
# 使用 enhanced-resolve，webpack 能够解析三种文件路径
# 绝对路径
import "/home/me/file";
import "C:\\Users\\me\\file";

# 相对路径
import "../src/file1";
import "./file2";

# 模块路径
import "module";
import "module/lib/file";

# 使用 [resolve.extensions] 选项作为文件扩展名来解析，此选项告诉解析器在解析中能够接受哪些扩展名（例如 .js, .jsx）。

```

## 依赖图(dependency graph)

```bash
# 从这些 入口起点 开始，webpack 递归地构建一个 依赖图 ，这个依赖图包含着应用程序所需的每个模块，
# 然后将所有这些模块打包为少量的 bundle - 通常只有一个 - 可由浏览器加载。
```

## manifest

```bash
# webpack 的 runtime 和 manifest，管理所有模块的交互
# 通过使用 bundle 计算出内容散列(content hash)作为文件名称,通过使用浏览器缓存来改善项目的性能

# Runtime
# runtime 包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑

# Manifest
# 当完成打包并发送到浏览器时，会在运行时通过 Manifest 来解析和加载模块。
# 它会保留所有模块的详细要点
# 通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块。

```

## 构建目标(targets)

```bash
# 要设置 target 属性，只需要在你的 webpack 配置中设置 target 的值
module.exports = {
  target: 'node'
};

# 多个 Target
# 可以通过打包两份分离的配置来创建同构的库
var path = require('path');
var serverConfig = {
  target: 'node',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'lib.node.js'
  }
  //…
};

var clientConfig = {
  target: 'web', // <=== 默认是 'web'，可省略
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'lib.js'
  }
  //…
};

module.exports = [ serverConfig, clientConfig ];
```

## 模块热替换(hot module replacement)

```bash
# 模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。

# 工作原理

# 在运用程序中
# 应用程序代码要求 HMR runtime 检查更新。
# HMR runtime（异步）下载更新，然后通知应用程序代码。
# 应用程序代码要求 HMR runtime 应用更新。
# HMR runtime（同步）应用更新。

# 在编译器中
# 除了普通资源，编译器(compiler)需要发出 "update"，以允许更新之前的版本到新的版本。
# 更新后的 manifest(JSON)
# 一个或多个更新后的 chunk (JavaScript)
# 编译器确保模块 ID 和 chunk ID 在这些构建之间保持一致。

# 在模块中
# style-loader 实现了 HMR 接口；当它通过 HMR 接收到更新，它会使用新的样式替换旧的样式。
# 如果一个模块没有 HMR 处理函数，更新就会冒泡(bubble up)。
# 这意味着一个简单的处理函数能够对整个模块树(complete module tree)进行更新

# 在 HMR Runtime 中
# check 发送 HTTP 请求来更新 manifest。如果请求失败，说明没有可用更新。
# 如果请求成功，待更新 chunk 会和当前加载过的 chunk 进行比较。对每个加载过的 chunk，会下载相对应的待更新 chunk。
# 当所有待更新 chunk 完成下载，就会准备切换到 ready 状态。

# apply 方法将所有被更新模块标记为无效。
# 所有无效模块都被（通过 dispose 处理函数）处理和解除加载。
```
