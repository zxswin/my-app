# webpack 指南

## 快速起步

- 安装

```bash
## webpack-cli 命令行交互工具
## webpack
## webpack-dev-server 服务器开发环境

## 创建一个项目
## 创建package.json文件
npm init -y

## 安装webpack-cli | webpack | webpack-dev-server
npm i webpack-cli webpack webpack-dev-server -D

## 安装相关依赖
## 安装一个要打包到生产环境的安装包时
npm install --save lodash
## 安装一个用于开发环境的安装包
npm install --save-dev 安装包

```

- 配置

```js
/*  在 webpack 4 中，可以无须任何配置使用也可以正常运行
 * 如果 webpack.config.js 存在，则 webpack 命令将默认选择使用它。

 * 在根目录下新建 webpack.config.js 文件
 * 可通过npx使用新配置文件执行构建
 * npx webpack --config webpack.config.js

 * 通过NPM 脚本(NPM Scripts)使用新配置文件执行构建
*/
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack"
  },
/* 使用 npm run build 命令执行构建 */
```

## 管理资源

- css 资源的处理

```bash
## 安装 style-loader 和 css-loader
cnpm i style-loader css-loader -D
## webpack 根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的 loader。
{
  test: /\.css$/,
  use: ['style-loader', 'css-loader']
}
## 样式会解析并通过<style>标签插入到index.html中
```

- 加载图片

```bash
## 安装file-loader
npm i file-loader -D

## 图片的引用
## import MyImage from './my-image.png'
该图像将被处理并添加到 output 目录，
并且_MyImage 变量将包含该图像在处理后的最终 url。
## CSS 中的 url('./my-image.png') 会使用类似的过程去处理。
## html-loader 以相同的方式处理 <img src="./my-image.png" />
{
  test: /\.(png|svg|jpg|gif)$/,
  use: ['file-loader']
},
## 压缩和优化图片
## 安装image-webpack-loader url-loader

```

- 加载字体

```bash
## 安装 file-loader 和 url-loader
## 可以接收并加载任何文件，然后将其输出到构建目录
npm i file-loader url-loader -D
{
  test: /\.(woff|woff2|eot|ttf|otf)$/,
  use: ['file-loader']
}

```

- 加载数据

```bash
## JSON文件
## 仅读取了数据 并没有在dist目录下生成json文件
JSON 支持实际上是内置的，也就是说 import Data from './data.json' 默认将正常运行。

## 导入 CSV、TSV 和 XML
## 安装csv-loader xml-loader
## csv-loader 依赖于papaparse
npm i papaparse csv-loader xml-loader -D
import Data from './data.xml';
console.log(Data);
{
  test: /\.(csv|tsv)$/,
  use: ['csv-loader']
},
{
  test: /\.xml$/,
  use: ['xml-loader']
}

```

- 全局资源

```bash
## 提倡使用如下目录结构管理资源
- |- /assets
+ |– /components
+ |  |– /my-component
+ |  |  |– index.jsx
+ |  |  |– index.css
+ |  |  |– icon.svg
+ |  |  |– img.png
```

## 管理输出

- 多个入口文件

```bash
## 构建后会在dist目录中生成多个编译后的js文件
entry: {
  app: './src/index.js',
  print: './src/print.js'
},
output: {
  filename: '[name].bundle.js',
  path: path.resolve(__dirname, 'dist')
}
```

- 设定 HtmlWebpackPlugin

```bash
## 安装 html-webpack-plugin
npm i html-webpack-plugin -D

## 配置
const HtmlWebpackPlugin = require('html-webpack-plugin');
plugins: [
  new HtmlWebpackPlugin({
    title: 'Output Management'
  })
],

## 构建后会自动生成index.html文件，并引入对应的js文件
## 无需模板也可以生产index.html文件

## 安装html-webpack-template
除了默认模板之外，还提供了一些额外的功能

```

- 清理 /dist 文件夹

```bash
## 每次构建前清理 /dist 文件夹，是比较推荐的做法
## 安装clean-webpack-plugin
npm i clean-webpack-plugin -D

## 配置
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
plugins: [
  new CleanWebpackPlugin(),
  new HtmlWebpackPlugin({
    title: 'Output Management'
  })
],

```

- manifest

```bash
## 通过 manifest，webpack 知道应该生成哪些文件
## 通过 manifest，webpack 能够对「你的模块映射到输出 bundle 的过程」保持追踪。
## 通过使用 WebpackManifestPlugin，可以直接将数据提取到一个 json 文件，以供使用
```

## 开发

- 使用 source map

```bash
## 使用 source map
## 准确地知道错误来自于哪个源文件
## source map 功能，将编译后的代码映射回原始源代码
## 如果一个错误来自于 b.js，source map 就会明确的告诉你

## 配置
## 使用 inline-source-map 选项(不要用于生产环境)
devtool: 'inline-source-map',
```

- 使用 webpack-dev-server

```bash
## 代码发生变化后自动编译代码
## 自动刷新浏览器
## 配置
## 在 localhost:8080 下建立服务，将 dist 目录下的文件，作为可访问文件。
devServer: {
  contentBase: './dist'
},

## 在package中配置Script
"start": "webpack-dev-server --open",
```

- 使用 webpack-dev-middleware 进行自定义配置

```bash
## webpack-dev-server 在内部使用了webpack-dev-middleware
## webpack-dev-middleware 是一个容器(wrapper)，它可以把 webpack 处理后的文件传递给一个服务器(server)
## 它也可以作为一个单独的包来使用，以便进行更多自定义设置来实现更多的需求

## 安装 express 和 webpack-dev-middleware：
## 使用koa会报错
npm i express webpack-dev-middleware -D

## 在webpack.config.js文件中
output: {
  filename: '[name].bundle.js',
  path: path.resolve(__dirname, 'dist'),
  publicPath: '/'
}

## 新建server.js
const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');

const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);

app.use(
  webpackDevMiddleware(compiler, {
    publicPath: config.output.publicPath
  })
);

app.listen(3000, function() {
  console.log('Example app listening on port 3000!\n');
});

## package.json文件中配置快捷启动
"server": "node server.js"

## 如果有修改能自动编译 但是浏览器貌似不能自动刷新

```

## 模块热替换

- 启用 HMR

```bash
## 它允许在运行时更新各种模块，而无需进行完全刷新
## HMR 不适用于生产环境，这意味着它应当只在开发环境使用


## 使用webpack-dev-server的配置(这种方式速度是最快的)
## NamedModulesPlugin，以便更容易查看要修补(patch)的依赖
const webpack = require('webpack');
devServer: {
  contentBase: './dist',
  hot: true
},
new webpack.NamedModulesPlugin(),
new webpack.HotModuleReplacementPlugin()

## webpack-dev-middleware的配置
## 安装webpack-hot-middleware包，以在你的自定义服务或应用程序上启用 HMR
npm i webpack-hot-middleware -D

## server.js文件中(不会自动刷新和进行热替换bug)
const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');
const webpackHotMiddleware = require('webpack-hot-middleware');

const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);

app.use(
  webpackDevMiddleware(compiler, {
    publicPath: config.output.publicPath
  })
);

app.use(
  webpackHotMiddleware(compiler, {
    heartbeat: 2000
  })
);

app.listen(3000, function() {
  console.log('Example app listening on port 3000!\n');
});

```

-通过 Node.js API (自定义配置推荐使用)

```bash
## 当使用 webpack dev server 和 Node.js API 时
## 不要将 dev server 选项放在 webpack 配置对中。而是，在创建选项时，将其作为第二个参数传递
## new WebpackDevServer(compiler, options)

## 感觉启动速度比较慢

## 新建dev-server.js文件
const webpackDevServer = require('webpack-dev-server');
const webpack = require('webpack');

const config = require('./webpack.config.js');
const options = {
  contentBase: './dist',
  hot: true,
  host: 'localhost'
};

webpackDevServer.addDevServerEntrypoints(config, options);
const compiler = webpack(config);
const server = new webpackDevServer(compiler, options);

server.listen(5000, 'localhost', () => {
  console.log('dev server listening on port 5000');
});

## package.json添加快捷启动
"dev": "node dev-server.js"

```

- HMR 修改样式表

```bash
## 安装 style-loader css-loader
npm i style-loader css-loader -D

## 常规配置后即可实现热替换
```

- 其他代码和框架

```bash
## React Hot Loader：实时调整 react 组件。
## Vue Loader：此 loader 支持用于 vue 组件的 HMR，提供开箱即用体验。
## Elm Hot Loader：支持用于 Elm 程序语言的 HMR。
## Redux HMR：无需 loader 或插件！只需对 main store 文件进行简单的修改。
## Angular HMR：没有必要使用 loader！只需对主要的 NgModule 文件进行简单的修改，由 HMR API 完全控制。
```

- index.js 文件

```js
import _ from 'lodash';
import printMe from './print.js';
import './styles.css';

import { cube } from './math.js';

function component() {
  var element = document.createElement('div');
  var btn = document.createElement('button');

  element.innerHTML = _.join(['Hello', 'webpack'], ' ');

  btn.innerHTML = '点击我';
  btn.onclick = printMe;
  element.appendChild(btn);
  return element;
}

let element = component(); // 当 print.js 改变导致页面重新渲染时，重新获取渲染的元素
document.body.appendChild(element);

if (module.hot) {
  module.hot.accept('./print.js', function() {
    console.log('Accepting the updated printMe module!');
    document.body.removeChild(element);
    element = component(); // 重新渲染页面后，component 更新 click 事件处理
    document.body.appendChild(element);
  });
}
```

## tree shaking 树摇晃

- 基本概念

```bash
## tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。
## 它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。

## webpack 4 正式版本
## 通过 package.json 的 "sideEffects" 属性作为标记，向 compiler 提供提示，
## 表明项目中的哪些文件是 "pure(纯的 ES2015 模块)"，由此可以安全地删除文件中未使用的部分。
```

- 添加一个通用模块

```bash
## 添加src/main.js
export function square(x) {
  return x * x;
}

export function cube(x) {
  return x * x * x;
}

## 问题一：square 没有被导入，但是，它仍然被包含在 bundle 中

```

- 将文件标记为无副作用(side-effect-free)

```bash
## 通过 package.json 的 "sideEffects" 属性来实现
## 标记为 false，来告知 webpack，它可以安全地删除未用到的 export 导出
{
  "name": "your-project",
  "sideEffects": false
}
## 副作用」不纯的代码
## 定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。
{
  "name": "your-project",
  "sideEffects": [
    "./src/some-side-effectful-file.js"
  ]
}

## 任何导入的文件都会受到 tree shaking 的影响
## 如果在项目中使用类似 css-loader 并导入 CSS 文件，则需要将其添加到 side effect 列表中，以免在生产模式中无意中将它删除：
{
  "name": "your-project",
  "sideEffects": [
    "./src/some-side-effectful-file.js",
    "*.css"
  ]
}

## 最后，还可以在 module.rules 配置选项 中设置 "sideEffects"。

```

- 压缩输出

```bash
## 使用 -p(production) 这个 webpack 编译标记，来启用 uglifyjs 压缩插件
## --optimize-minimize 标记也会在 webpack 内部调用 UglifyJsPlugin。
## webpack 4 开始，也可以通过 "mode" 配置选项轻松切换到压缩输出，只需设置为 "production"
mode: 'production',
## 看到 cube 函数的修改版本（function r(e){return e*e*e}n.a=r）

## 具体步骤
## 使用 ES2015 模块语法（即 import 和 export）。
## 在项目 package.json 文件中，添加一个 "sideEffects" 入口。
## 引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 UglifyJSPlugin）。
```

## 生产环境构建

- 配置

```bash
# 建议为每个环境编写彼此独立的 webpack 配置

#  按照 webpack-merge 插件配置通用配置
npm i webpack-merge -D

# 新建 webpack.common.js 文件
const path = require('path');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: {
    app: './src/index.js'
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
      title: 'Production'
    })
  ],
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
};
# 新建 webpack.dev.js 文件
# 在 webpack.dev.js 中，我们为此环境添加了推荐的 devtool（强大的 source map）和简单的 devServer 配置。
const merge = require('webpack-merge');
const common = require('./webpack.common.js');

module.exports = merge(common, {
  devtool: 'inline-source-map',
  devServer: {
    contentBase: './dist',
    hot: true
  }
});
# 新建 webpack.prod.js 文件
# 在 webpack.prod.js 中，我们引入了之前在 tree shaking 指南中介绍过的 UglifyJSPlugin(本身具备删除多余代码的能力)。
const webpack = require('webpack');
const merge = require('webpack-merge');
const UglifyJSPlugin = require('uglifyjs-webpack-plugin');
const common = require('./webpack.common.js');

module.exports = merge(common, {
  plugins: [
    new UglifyJSPlugin({
      sourceMap: true
    }),
    new webpack.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify('production')
    })
  ]
});

# 修改 NPM Scripts
# 将 npm start 定义为开发环境脚本，并在其中使用 webpack-dev-server
# 将 npm run build 定义为生产环境脚本
"scripts": {
  "test": "echo \"Error: no test specified\" && exit 1",
  "build": "webpack --config webpack.prod.js",
  "start": "webpack-dev-server --open --config webpack.dev.js",
  "server": "node server.js",
  "dev": "node dev-server.js",
  "builds": "webpack"
},
```

- 其他可以用于压缩代码并删除未引用代码功能的插件

```bash
# UglifyJSPlugin
# BabelMinifyWebpackPlugin
# ClosureCompilerPlugin
```

- source map 配置

```bash
# 在生产环境中使用 source-map 选项
# 避免在生产中使用 inline-*** 和 eval-***，因为它们可以增加 bundle 大小，并降低整体性能
new UglifyJSPlugin({
  sourceMap: true
}),
# 在开发环境中用到的 inline-source-map
devtool: 'inline-source-map',
```

- 指定环境

```bash
# 无法在构建脚本 webpack.config.js 中，将 process.env.NODE_ENV 设置为 "production"
# process.env.NODE_ENV === 'production' 这样的条件语句，在 webpack 配置文件中，无法按照预期运行
# 使用 webpack 内置的 DefinePlugin 为所有的依赖定义process.env.NODE_ENV变量
const webpack = require('webpack');

new webpack.DefinePlugin({
  'process.env.NODE_ENV': JSON.stringify('production')
})

# 任何位于 /src 的本地代码都可以关联到 process.env.NODE_ENV 环境变量
if (process.env.NODE_ENV !== 'production') {
  console.log('Looks like we are in development mode!');
}

# 使用 ExtractTextPlugin 将 CSS 分离成单独的文件
```

- CLI 替代选项

```bash
# --optimize-minimize 标记将在后台引用 UglifyJSPlugin
# --define process.env.NODE_ENV="'production'"  和 使用DefinePlugin插件定义环境变量的作用是一样的
# webpack -p 将自动地调用上述这些标记，从而调用需要引入的插件
# 推荐使用配置方式 让你更方便地控制这两个插件中的其他选项
```

## 代码分离

- 入口起点：使用 entry 配置手动地分离代码。

```bash
# 存在的问题
# 如果入口 chunks 之间包含重复的模块，那些重复模块都会被引入到各个 bundle 中
# 这种方法不够灵活，并且不能将核心应用程序逻辑进行动态拆分代码。
entry: {
  index: './src/index.js',
  another: './src/another-module.js'
},

```

- 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。

```bash
# CommonsChunkPlugin 插件可以将公共的依赖模块提取到已有的入口 chunk 中
# new webpack.optimize.CommonsChunkPlugin 在webpack4中已经移除不可使用
# webpack中使用如下配置
# optimization 和 plugins 是同级的
const webpack = require('webpack');
optimization: {
  splitChunks: {
    cacheGroups: {
      commons: {
        name: 'commons', // 提取的chunk的名称
        chunks: 'initial',
        minChunks: 2 // 被多少个模块重复引用的时候进行提取操作
      }
    }
  }
},

# 其他对于代码分离很有帮助的插件和 loaders
# ExtractTextPlugin: 用于将 CSS 从主应用程序中分离。
# bundle-loader: 用于分离代码和延迟加载生成的 bundle。
# promise-loader: 类似于 bundle-loader ，但是使用的是 promises。

```

- 动态导入：通过模块的内联函数调用来分离代码。

```bash
# 动态代码拆分时，webpack 提供了两个类似的技术
# 第一种，也是优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。
# 第二种，则是使用 webpack 特定的 require.ensure
# import() 调用会在内部用到 promises。

# 移除其他分离代码功能的配置 比如 optimization
# 添加chunkFilename配置 这里使用了 chunkFilename，它决定非入口 chunk 的名称
output: {
  filename: '[name].bundle.js',
  path: path.resolve(__dirname, 'dist'),
  chunkFilename: '[name].bundle.js',
  publicPath: '/'
}

# 在index.js文件中使用import() 动态引入模块
# 不再使用静态导入 lodash，而是通过使用动态导入来分离一个 chunk
# 在注释中使用了 webpackChunkName。这样做会导致我们的 bundle 被命名为 lodash.bundle.js ，而不是 [id].bundle.js
# 配置中使用UglifyJSPlugin貌似会报错，编译不通过(待解决)
function getComponent() {
  return import(/* webpackChunkName: "lodash" */ 'lodash')
    .then(_ => {
      var element = document.createElement('div');

      element.innerHTML = _.join(['Hello', 'webpack'], ' ');

      return element;
    })
    .catch(error => 'An error occurred while loading the component');
}

getComponent().then(component => {
  document.body.appendChild(component);
});
```

- bundle 分析(bundle analysis)

```bash
# 官方分析工具
webpack --profile --json

# 其他社区分析工具
webpack-chart: webpack 数据交互饼图。
webpack-visualizer: 可视化并分析你的 bundle，检查哪些模块占用空间，哪些可能是重复使用的。
webpack-bundle-analyzer: 一款分析 bundle 内容的插件及 CLI 工具，以便捷的、交互式、可缩放的树状图形式展现给用户。
```

## 懒加载

- print.js 文件

```js
console.log(
  'The print.js module has loaded! See the network tab in dev tools...'
);

export default () => {
  console.log('Button Clicked: Here\'s "some text"!');
};
```

- index.js 文件

```js
import _ from 'lodash';

function component() {
  var element = document.createElement('div');

  var button = document.createElement('button');
  var br = document.createElement('br');

  button.innerHTML = 'Click me and look at the console!';
  element.innerHTML = _.join(['Hello', 'webpack'], ' ');
  element.appendChild(br);
  element.appendChild(button);

  // Note that because a network request is involved, some indication
  // of loading would need to be shown in a production-level site/app.
  button.onclick = e =>
    import(/* webpackChunkName: "print" */ './print').then(module => {
      var print = module.default;

      print();
    });

  return element;
}

document.body.appendChild(component());
```

```bash
# 调用 ES6 模块的 import() 方法（引入模块）时，必须指向模块的 .default 值，因为它才是 promise 被处理后返回的实际的 module 对象

```

- 不同框架的懒加载

```bash
# 许多框架和类库对于如何用它们自己的方式来实现（懒加载）都有自己的建议。这里有一些例子：
React: Code Splitting and Lazy Loading
Vue: Lazy Load in Vue using Webpack's code splitting
AngularJS: AngularJS + Webpack = lazyLoad by @var_bincom
```

## 缓存

```bash
# 编译生成的文件能够被客户端缓存，而在文件内容变化后，能够请求到新的文件。
```

- 输出文件的文件名(Output Filenames)

```bash
# 使用 output.filename 进行文件名替换
# [hash] 替换可以用于在文件名中包含一个构建相关(build-specific)的 hash
# [chunkhash] 替换，在文件名中包含一个 chunk 相关(chunk-specific)的哈希。
const path = require('path');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
      title: 'Caching'
    })
  ],
  output: {
    filename: '[name].[chunkhash].js',
    path: path.resolve(__dirname, 'dist')
  }
};

# 运行构建脚本 npm run build
# 问题：如果不做修改，文件名可能会变，也可能不会(大概率文件名会变化)
# webpack4版本如果不改动文件名不会变化
# 因为 webpack 在入口 chunk 中，包含了某些样板(boilerplate)，特别是 runtime 和 manifest。
# 样板(boilerplate)指 webpack 运行时的引导代码）

```

- 提取模板(Extracting Boilerplate)

```bash
# 将 webpack 的样板(boilerplate)和 manifest 提取出来
# 效果：提取出样板文件，分离第三方库文件 ， 只有改过的文件文件名才会变动
const path = require('path');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: {
    main: './src/index.js',
    vendor: ['lodash'], // 需要提取的库文件列表
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
      title: 'Caching'
    })
  ],

  optimization: {
    // 提取样板(boilerplate)文件
    runtimeChunk: {
      name: 'manifest'
    },
    splitChunks: {
      cacheGroups: {
        // 库文件提取
        vendor: {
          name: 'vendor', // 提取的chunk的名称
          chunks: 'initial',
          minChunks: 2 // 被多少个模块重复引用的时候进行提取操作
        }
      }
    }
  },
  output: {
    filename: '[name].[chunkhash].js',
    path: path.resolve(__dirname, 'dist')
  }
};

```

- 模块标识符(Module Identifiers)

```bash
# 每个 module.id 会基于默认的解析顺序(resolve order)进行增量。
# 也就是说，当解析顺序发生变化，ID 也会随之改变

# NamedModulesPlugin插件，将使用模块的路径，而不是数字标识符
# 虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些

# HashedModuleIdsPlugin，推荐用于生产环境构建：

# 经过测试 webpack4下修改了main.js的文件或其他业务逻辑文件
# 只有业务逻辑文件的文件名会产生变化(webpack3存在其他文件变化的bug)

# 处理模块标识符(Module Identifiers)，使得未改动文件保持文件名
# new webpack.HashedModuleIdsPlugin()

const path = require('path');
const webpack = require('webpack');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: {
    main: './src/index.js',
    vendor: ['lodash']
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
      title: 'Caching'
    }),
    // 处理模块标识符(Module Identifiers)，使得未改动文件保持文件名
    new webpack.HashedModuleIdsPlugin()
  ],
  optimization: {
    runtimeChunk: {
      name: 'manifest'
    },
    splitChunks: {
      cacheGroups: {
        vendor: {
          name: 'vendor', // 提取的chunk的名称
          chunks: 'initial',
          minChunks: 2 // 被多少个模块重复引用的时候进行提取操作
        }
      }
    }
  },
  output: {
    filename: '[name].[chunkhash].js',
    path: path.resolve(__dirname, 'dist')
  }
};

```

## shimming

- shimming 全局变量

```bash
# 处理某些库如jQuery可能创建一些需要被导出的全局变量
# 一些第三方的库(library)可能会引用一些全局依赖（例如 jQuery 中的 $）
# webpack并不推荐使用全局变量，而是让前端开发更加模块化

# 运用到的插件是ProvidePlugin 插件
# 模块中可以通过访问一个变量来获取到 package 包
# 如果 webpack 知道这个变量在某个模块中被使用了，那么 webpack 将在最终 bundle 中引入我们给定的 package

# 执行原理
# 当webpack遇到了至少一处用到 lodash 变量的模块实例，那请你将 lodash package 包引入进来，并将其提供给需要用到它的模块。

# src/index.js文件
function component() {
  var element = document.createElement('div');
  element.innerHTML = _.join(['Hello', 'webpack'], ' ');
  return element;
}

document.body.appendChild(component());

# webpack.config.js 配置
const path = require('path');
const webpack = require('webpack');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
  },
  plugins: [
    // ProvidePlugin插件
    new webpack.ProvidePlugin({
      _: 'lodash'
    })
  ]
};

# 使用 ProvidePlugin 暴露某个模块中单个导出值
# 通过一个“数组路径”进行配置（例如 [module, child, ...children?]

# 配置示例：无论 join 方法在何处调用，我们都只会得到的是 lodash 中提供的 join 方法
# 这样就能很好的与 tree shaking 配合，将 lodash 库中的其他没用到的部分去除(有待验证，貌似不可以)
# src/index.js
function component() {
  var element = document.createElement('div');

  // element.innerHTML = _.join(['Hello', 'webpack'], ' ');
  element.innerHTML = join(['Hello', 'webpack'], ' ');

  return element;
}

document.body.appendChild(component());

# webpack.config.js
const path = require('path');
const webpack = require('webpack');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  plugins: [
    new webpack.ProvidePlugin({
    join: ['lodash', 'join'] // 通过数组路径模式把子模块暴露为全局变量
    })
  ]
};

```

- 细粒度 shimming

```js
/**
 * 处理某些传统的模块依赖的 this 指向的是 window 对象
 * index.js
 */

function component() {
  var element = document.createElement('div');

  element.innerHTML = join(['Hello', 'webpack'], ' ');

  // Assume we are in the context of `window`
  this.alert("Hmmm, this probably isn't a great idea...");

  return element;
}

document.body.appendChild(component());

/**
 * 当模块运行在 CommonJS 环境下这将会变成一个问题，也就是说此时的 this 指向的是 module.exports
 * 可以通过使用 imports-loader 覆写 this
 * webpack.config.js
 */
const path = require('path');
const webpack = require('webpack');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: require.resolve('index.js'),
        use: 'imports-loader?this=>window'
      }
    ]
  },
  plugins: [
    new webpack.ProvidePlugin({
      join: ['lodash', 'join']
    })
  ]
};
```

- 全局 exports

```js
/**
 * 通过使用 exports-loader，将一个全局变量作为一个普通的模块来导出
 * 例如，为了将 file 导出为 file 以及将 helpers.parse 导出为 parse
 * src/globals.js
 */
var file = 'blah.txt';
var helpers = {
  test: function() {
    console.log('test something');
  },
  parse: function() {
    console.log('parse something');
  }
};

/** webpack.config.js  */
const path = require('path');
const webpack = require('webpack');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: require.resolve('index.js'),
        use: 'imports-loader?this=>window'
      },
      {
        test: require.resolve('globals.js'),
        use: 'exports-loader?file,parse=helpers.parse'
      }
    ]
  },
  plugins: [
    new webpack.ProvidePlugin({
      join: ['lodash', 'join']
    })
  ]
};

/** 使用  */
import { file, parse } from './globals.js';
```

- 加载 polyfills

```js
/**
 * 安装 babel-polyfill 处理非现代浏览器对ES6的支持
 * npm install --save babel-polyfill
 *
 * 安装 whatwg-fetch 仅用于检查浏览器是否支持fetch方法
 * npm install --save whatwg-fetch
 *
 * 新建 polyfills.js 文件
 * src/polyfills.js
 *
 * 根据条件去加载新的 polyfills.bundle.js 文件
 *
 */

/** polyfills.js   */
import 'babel-polyfill';
import 'whatwg-fetch';

/** webpack.config.js  */
const path = require('path');
const webpack = require('webpack');

module.exports = {
  entry: {
    polyfills: './src/polyfills.js', // 添加polyfills 入口文件 将会生产一个polyfills文件
    index: './src/index.js'
  },
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: require.resolve('index.js'),
        use: 'imports-loader?this=>window'
      },
      {
        test: require.resolve('globals.js'),
        use: 'exports-loader?file,parse=helpers.parse'
      }
    ]
  },
  plugins: [
    new webpack.ProvidePlugin({
      join: ['lodash', 'join']
    })
  ]
};

/**
 * 根据条件去加载新的 polyfills.bundle.js 文件
 * 在html文件中加入如下代码
 */

var modernBrowser = 'fetch' in window && 'assign' in Object;

if (!modernBrowser) {
  var scriptElement = document.createElement('script');
  scriptElement.async = false;
  scriptElement.src = '/polyfills.bundle.js';
  document.head.appendChild(scriptElement);
}
```

- 深度优化

```js
/**
 * babel-preset-env package 使用 browserslist 来转译那些你浏览器中不支持的特性
 *
 * script-loader 可以处理一下老旧的模块
 */
```

- Node 内置

```js
/**
 * 像 process 这种 Node 内置模块，能直接根据配置文件(configuration file)进行正确的 polyfills，
 * 且不需要任何特定的 loaders 或者 plugins。
 */
```

## 渐进式网络应用程序

- 本地测试服务器搭建

```js
/**
 * 安装依赖
 * 安装 http-server 搭建一个服务器
 * npm i http-server -D
 * 安装 anywhere 目录变成一个静态文件服务器的根目录。
 * npm i anywhere -D
 *
 * PWA 通过使用名为 Service Workers 的网络技术，在离线(offline)时应用程序能够继续运行功能。
 *
 * 安装 workbox-webpack-plugin 插件
 * npm i workbox-webpack-plugin -D
 */

/* webpack.config.js */
const WorkboxPlugin = require('workbox-webpack-plugin');
new WorkboxPlugin.GenerateSW({
  // 这些选项帮助 ServiceWorkers 快速启用
  // 不允许遗留任何“旧的” ServiceWorkers
  clientsClaim: true,
  skipWaiting: true
});

/**
 * index.js
 * 注册 Service Worker
 */
import _ from 'lodash';
import printMe from './print.js';

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker
      .register('/service-worker.js')
      .then(registration => {
        console.log('SW registered: ', registration);
      })
      .catch(registrationError => {
        console.log('SW registration failed: ', registrationError);
      });
  });
}
```

## TypeScript

- 基础安装

```js
/**
 * 安装相关依赖
 * npm install --save-dev typescript ts-loader
 */

/**
 * 在根目录添加 tsconfig.json文件
 */
{
  "compilerOptions": {
    "outDir": "./dist/",
    "sourceMap": true,
    "noImplicitAny": true,
    "module": "es6",
    "target": "es5",
    "jsx": "react",
    "allowJs": true
  }
}

/** webpack.config.js  */
const path = require('path');

module.exports = {
  entry: './src/index.ts',
  devtool: 'inline-source-map',
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/
      }
    ]
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js']
  },
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
};

```

- 使用第三方库

```js
/**
 * 搜索第三方库的声明文件的地址
 * http://microsoft.github.io/TypeSearch/
 *
 * 安装对应的声明文件
 * npm install --save-dev @types/lodash
 */
```

- 导入其他资源

```js
/**
 * 要在 TypeScript 里使用非代码资源，我们需要告诉 TypeScript 如何兼容这些导入类型
 * 创建 custom.d.ts 文件
 * 这个文件用来编写自定义的类型声明
 *
 *
 * 通过指定任何以 .svg 结尾的导入，并将模块的 content 定义为 any，将 SVG 声明一个新的模块。
 * 可以通过将类型定义为字符串，来更加显式地将它声明为一个 url。同样的理念适用于其他资源，包括 CSS, SCSS, JSON 等。
 */
declare module "*.svg" {
  const content: any;
  export default content;
}
```

## 使用环境变量

```js
/**
 * 通过设置 --env 可以使你根据需要，传入尽可能多的环境变量
 * webpack --env.NODE_ENV=local --env.production --progress
 * 如果设置 env 变量，却没有赋值，--env.production 默认将 --env.production 设置为 true。
 */

/* webpack.config.js */
module.exports = env => {
  // Use env.<YOUR VARIABLE> here:
  console.log('NODE_ENV: ', env.NODE_ENV); // 'local'
  console.log('Production: ', env.production); // true

  return {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist')
    }
  };
};
```

## 构建性能

```js
/**
 * 1.保持版本最新
 */

/* 2.将 loaders 应用于最少数的必要模块中 */
{
  test: /\.js$/,
  include: path.resolve(__dirname, "src"),
  loader: "babel-loader"
}

/* 3.每个额外的 loader/plugin 都有启动时间。尽量少使用不同的工具。  */

/**
 * 4.提高解析速度
 * 尽量减少 resolve.modules, resolve.extensions, resolve.mainFiles, resolve.descriptionFiles 中类目的数量，因为他们会增加文件系统调用的次数。
 * 如果你不使用 symlinks ，可以设置 resolve.symlinks: false (例如 npm link 或者 yarn link).
 * 如果你使用自定义解析 plugins ，并且没有指定 context 信息，可以设置 resolve.cacheWithContext: false 。
  */

/* 5.使用 DllPlugin 将更改不频繁的代码进行单独编译。这将改善引用程序的编译速度，即使它增加了构建过程的复杂性。  */

/*
 * 6.减少编译的整体大小，以提高构建性能。尽量保持 chunks 小巧。
 * 使用 更少/更小 的库。
 * 在多页面应用程序中使用 CommonsChunksPlugin。
 * 在多页面应用程序中以 async 模式使用 CommonsChunksPlugin 。
 * 移除不使用的代码。
 * 只编译你当前正在开发部分的代码。
 */

/**
 * thread-loader 可以将非常消耗资源的 loaders 转存到 worker pool 中。
 * 不要使用太多的 workers
 * 进程间通讯(IPC)是非常消耗资源的
 */

/**
 * 持久化缓存
 * 使用 cache-loader 启用持久化缓存。使用 package.json 中的 "postinstall" 清除缓存目录。
  */

```

- 针对开发环境特别有用的配置

```js
/**
 * 1. 增量编译
 * 使用 webpack 的监听模式。
 * 在监听模式下构建会记录时间戳并将信息传递给编译让缓存失效。
 *
 * 使用 watchOptions.poll 来增加轮询的间隔。
 * 有许多监听文件会导致 CPU 大量负载
 */

/**
 * 2.在内存中编译
 * 以下几个实用工具通过在内存中进行代码的编译和资源的提供，但并不写入磁盘来提高性能:
 * webpack-dev-server
 * webpack-hot-middleware
 * webpack-dev-middleware
 */

/**
 * 3.不同的 devtool 的设置，会导致不同的性能差异
 * "eval" 具有最好的性能，但并不能帮助你转译代码。
 * 果你能接受稍差一些的 mapping 质量，可以使用 cheap-source-map 选项来提高性能
 * 使用 eval-source-map 配置进行增量编译。
 * 在大多数情况下，cheap-module-eval-source-map 是最好的选择。
 */

/**
 * 4.避免在生产环境下才会用到的工具
 * UglifyJsPlugin
 * ExtractTextPlugin
 * [hash]/[chunkhash]
 * AggressiveSplittingPlugin
 * AggressiveMergingPlugin
 * ModuleConcatenationPlugin
 */

/**
 * 最小化入口 chunk
 * 应当在生成入口 chunk 时，尽量减少入口 chunk 的体积，以提高性能。
 * 只提取包含 runtime 的 chunk ，其他 chunk 都作为子模块:
 */
new CommonsChunkPlugin({
  name: 'manifest',
  minChunks: Infinity
});
```

- 针对生产环境特别有用的配置

```js
/**
 * 1.进行多个编译时，以下工具可以帮助到你:
 * parallel-webpack: 它允许编译工作在 worker 池中进行。
 * cache-loader: 缓存可以在多个编译时之间共享。
 */

/**
 * 2.Source maps 真的很消耗资源
 */

/**
 * 3.项目中的 preset/plugins 数量最小化。
 */

/**
 * 4.TypeScript
 * 在单独的进程中使用 fork-ts-checker-webpack-plugin 进行类型检查。
 * 配置 loaders 跳过类型检查。
 * 使用 ts-loader 时，设置 happyPackMode: true / transpileOnly: true。
 */

/**
 * Sass
 * node-sass 中有个来自 Node.js 线程池的阻塞线程的 bug。 当使用 thread-loader 时，需要设置 workerParallelJobs: 2。
 */
```

## 内容安全策略

```js
/**
 * 为每个唯一的页面视图生成和提供一个唯一的基于 hash 的 nonce
 * nonce 应该是一个 base64 编码的字符串。
 */

/**
 * 在 entry 文件中
 */
__webpack_nonce__ = 'c29tZSBjb29sIHN0cmluZyB3aWxsIHBvcCB1cCAxMjM=';

/**
 * 启用 CSP
 * 以下是一个包含 CDN 白名单 URL 的 CSP header 的示例：
 * Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com;
 */
```

## 管理依赖

```js
/**
 * 带表达式的 require 语句
 * 如果你的 request 含有表达式(expressions)，会创建一个上下文(context)，
 * 因为在编译时(compile time)并不清楚具体是哪一个模块被导入。
 * webpack 能够支持动态 require，但会导致所有可能用到的模块都包含在 bundle 中
 */
require('./template/' + name + '.ejs');

/**
 * require.context
 * 使用 require.context() 方法来创建自己的（模块）上下文
 * 你可以给这个方法传 3 个参数：要搜索的文件夹目录，是否还应该搜索它的子目录，以及一个匹配文件的正则表达式。
 */
require.context('./test', false, /\.test\.js$/);
// （创建了）一个包含了 test 文件夹（不包含子目录）下面的、所有文件名以 `.test.js` 结尾的、能被 require 请求到的文件的上下文。
require.context('../', true, /\.stories\.js$/);
// （创建了）一个包含了父级文件夹（包含子目录）下面，所有文件名以 `.stories.js` 结尾的文件的上下文。
```

- 上下文模块 API

```js
/**
 * 一个上下文模块导出一个（require）函数，这个函数可以接收一个参数：request
 * resolve 是一个函数，它返回请求被解析后得到的模块 id。
 * keys 也是一个函数，它返回一个数组，由所有可能被上下文模块处理的请求（译者注：参考下面第二段代码中的 key）组成。
 */
function importAll(r) {
  r.keys().forEach(r);
}

importAll(require.context('../components/', true, /\.js$/));

// 在构建时，所有被 require 的模块都会被存到（上面代码中的）cache 里面。
var cache = {};

function importAll(r) {
  r.keys().forEach(key => (cache[key] = r(key)));
}

importAll(require.context('../components/', true, /\.js$/));
```

## 公共路径(public path)

- 在构建项目时设置路径值

```js
import webpack from 'webpack';

// 如果预先定义过环境变量，就将其赋值给`ASSET_PATH`变量，否则赋值为根目录
const ASSET_PATH = process.env.ASSET_PATH || '/';

export default {
  output: {
    publicPath: ASSET_PATH
  },

  plugins: [
    // 该插件帮助我们安心地使用环境变量
    new webpack.DefinePlugin({
      'process.env.ASSET_PATH': JSON.stringify(ASSET_PATH)
    })
  ]
};
```

- 即时设定路径值

```js
/**
 * 在你的项目入口
 */
__webpack_public_path__ = process.env.ASSET_PATH;

/**
 * 将公共路径(public path)赋值移至自己的专属模块，然后将其导入到你的 entry.js 之上
 */
// entry.js
import './public-path';
import './app';
```

## 集成(integrations)

- Grunt

```js
/**
 * npm install --save-dev grunt-webpack webpack
 */

// Gruntfile.js

const webpackConfig = require('./webpack.config.js');

module.exports = function(grunt) {
  grunt.initConfig({
    webpack: {
      options: {
        stats: !process.env.NODE_ENV || process.env.NODE_ENV === 'development'
      },
      prod: webpackConfig,
      dev: Object.assign({ watch: true }, webpackConfig)
    }
  });

  grunt.loadNpmTasks('grunt-webpack');
};
```

- Gulp

```js
/**
 * npm install --save-dev webpack-stream
 */
var gulp = require('gulp');
var webpack = require('webpack-stream');
gulp.task('default', function() {
  return gulp
    .src('src/entry.js')
    .pipe(
      webpack({
        // 一些配置选项……
      })
    )
    .pipe(gulp.dest('dist/'));
});
```

- Mocha

```js
/**
 * npm install --save-dev webpack mocha mocha-webpack
  */
mocha-webpack 'test/**/*.js'
```

- Karma

```js
/**
 * npm install --save-dev webpack karma karma-webpack
 */
module.exports = function(config) {
  config.set({
    files: [
      { pattern: 'test/*_test.js', watched: false },
      { pattern: 'test/**/*_test.js', watched: false }
    ],
    preprocessors: {
      'test/*_test.js': ['webpack'],
      'test/**/*_test.js': ['webpack']
    },
    webpack: {
      // 一些自定义的 webpack 配置……
    },
    webpackMiddleware: {
      // 一些自定义的 webpack-dev-middleware 配置……
    }
  });
};
```

## 补充知识

- npx 使用教程

```bash
## npm 从5.2版开始，增加了 npx 命令
## 万一不能用，就要手动安装一下
npm install -g npx

## npx解决了哪些问题
## 让项目内部安装的模块用起来更方便
## 1.通过命令行执行,项目脚本和 package.json 的scripts字段里面有对应配置(方案1)
npm run webpack
## 2.项目的根目录下执行(方案2)
node-modules/.bin/mocha --version
## 3.在项目根目录下通过npx执行(方案3推荐)
npx webpack

## 原理
## 会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。
## 由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。
# 等同于 ls
npx ls

## 避免全局模块安装
## npx可以运行全局安装模块，而不运行安装全局模块
## npx 将模块下载到一个临时目录，使用以后再删除。
## 以后再次执行上面的命令，会重新下载对应模块

## 只要 npx 后面的模块无法在本地发现，就会下载同名模块。
## 允许运行指定版本：指定使用 3.1.0 版本的uglify-js压缩脚本
npx uglify-js@3.1.0 main.js -o ./dist/main.js

## 命令参数
## --no-install
## 让 npx 强制使用本地模块，不下载远程模块
## 如果本地不存在该模块，就会报错。
npx --no-install http-server

## --ignore-existing
## 忽略本地的同名模块，强制安装使用远程模块
npx --ignore-existing create-react-app my-react-app

## 使用npx允许不同版本的node
## 下面命令会使用 0.12.8 版本的 Node 执行脚本。
## 原理是从 npm 下载这个版本的 node，使用后再删掉。
## 某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些
npx node@0.12.8 -v
v0.12.8

## -p 参数
## -p参数用于指定 npx 所要安装的模块
## 下面命令先指定安装node@0.12.8，然后再执行node -v命令。
npx -p node@0.12.8 node -v
v0.12.8
## -p参数对于需要安装多个模块的场景很有用
npx -p lolcatjs -p cowsay [command]

## -c参数
## 如果 npx 安装多个模块，默认情况下，所执行的命令之中，
## 只有第一个可执行项会使用 npx 安装的模块，后面的可执行项还是会交给 Shell 解释。
## -c参数可以将所有命令都用 npx 解释。
npx -p lolcatjs -p cowsay -c 'cowsay hello | lolcatjs'


## 执行 GitHub 源码
## 远程代码必须是一个模块，即必须包含package.json和入口脚本
## 执行 Gist 代码
$ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32
## 执行仓库代码
$ npx github:piuccio/cowsay hello
```

## optimization 总结

```js
// minimize
// 默认为true，效果就是压缩js代码。

// minimizer
// 可以自定义UglifyJsPlugin和一些配置,默认的压缩为uglifyjs-webpack-plugin

//比如在构建的时候,希望新增css的压缩
minimizer: mode === 'development'
  ? []
  : [
      new UglifyJsPlugin({
        cache: true,
        parallel: true,
        sourceMap: mode === 'development'
      }),
      new OptimizeCSSAssetsPlugin()
    ];

// runtimeChunk
// 默认为false,runtime相关的代码(各个模块之间的引用和加载的逻辑)内嵌入每个entry
// true：对于每个entry会生成runtime~${entrypoint.name}的文件。
// 'single': 会生成一个唯一单独的runtime.js文件，就是manifest。
// multiple：和true一致。
// name:{}：自定义runtime文件的name
runtimeChunk: {
  name: () => 'manifest';
}

// noEmitOnErrors
// 默认为true,编译错误的时候是否不生成资源。

// namedModules,namedChunks
// development默认都为true,production默认为false，选择是否给module和chunk更有意义的名称。
// nameModules:true这里会显示路径
// nameModules:false直接采用索引自增
// namedChunks:true
// namedChunks:false采用索引

// moduleIds
// 一般不建议配置namedModules,namedChunks
// 针对module的配置，这里会取hashed。
// 针对chunk的配置，特别是异步代码

// removeAvailableModules,removeEmptyChunks,mergeDuplicateChunks,flagIncludedChunks
// 这4个参数构建默认都是true,主要是用于构建优化，不需要改,基本就是字面意思

// splitChunks

// 主要就是根据不同的策略来分割打包出来的bundle
// 1.chunks
// async（默认）：
splitChunks: {
  chunks: 'async'; //分割异步打包的代码，
}
//all:
splitChunks:{
   chunks:'all',//同时分割同步和异步代码,推荐。
   cacheGroup:{//默认的规则不会打包,需要单独定义
     a: {
       test: /a\.js/,
       chunks: "all",
       name: "a",
       enforce: true
     }
   }
}
// initial
splitChunks:{
   chunks:'initial'//也会同时打包同步和异步，但是异步内部的引入不再考虑，直接打包在一起，会将vue和b的内容直接打包成chunk,
   cacheGroup:{//默认的规则不会打包,需要单独定义
     a: {
       test: /a\.js/,
       chunks: "all",
       name: "a",
       enforce: true
     }
   }
}

// 2.name
// 分割的js名称，默认为true，返回
// ${cacheGroup的key} ${automaticNameDelimiter} ${moduleName},可以自定义。

// 3.minChunks
// 最小公用模块次数，默认为1

// 4.minSize,maxSize,maxAsyncRequests（按需加载时候最大的并行请求数）,maxInitialRequests（一个入口最大的并行请求数）
// 都为字面意思，一般不建议改。

// 5.cacheGroups
// 缓存策略，默认设置了分割node_modules和公用模块。内部的参数可以和覆盖外部的参数。
// test 正则匹配文件
// priority 优先级
// reuseExistingChunk是否复用存在的chunk
cacheGroup:{
  a: {
    test: /a\.js/,//匹配规则
    minChunks:2,//重写公用chunks的次数
    chunks: "all",
    name: "a",//重写文件名称
    enforce: true //强制生成
  }
}

// 6.automaticNameDelimiter
// 文件名称分隔符号~
```

## 参考文章

- [webpack 中文文档](https://www.webpackjs.com/concepts/)
- [markdown 文件编写规范](https://www.cnblogs.com/liugang-vip/p/6337580.html)
- [Webpack 揭秘——走向高阶前端的必经之路](https://github.com/jerryOnlyZRJ/webpack-loader)
- [Webpack 运行机制](https://github.com/jerryOnlyZRJ/webpack-loader)
- [《深入浅出 webpack》 读书笔记](https://blog.csdn.net/qq_39232515/article/details/88394114)
- [npm 中文网](https://www.npmjs.cn/)
