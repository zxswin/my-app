## redux-saga 的使用

```js
// redux-saga 是一个用于管理应用程序 Side Effect（副作用，例如异步获取数据，访问浏览器缓存等）的 library
// redux-saga 是一个 redux 中间件，意味着这个线程可以通过正常的 redux action 从主应用程序启动，暂停和取消，它能访问完整的 redux state，也可以 dispatch redux action。

// 不同于 redux thunk，你不会再遇到回调地狱了，你可以很容易地测试异步流程并保持你的 action 是干净的。
```

## 安装

```js
// npm install --save redux-saga
```

## 简单的使用

- ui 部分

```js
class UserComponent extends React.Component {
  ...
  onSomeButtonClicked() {
    const { userId, dispatch } = this.props
    // 触发USER_FETCH_REQUESTED action
    dispatch({type: 'USER_FETCH_REQUESTED', payload: {userId}})
  }
  ...
}
```

- 创建一个 Saga

```js
// 创建一个 Saga 来监听所有的 USER_FETCH_REQUESTED action，并触发一个 API 调用获取用户数据。
import { call, put, takeEvery, takeLatest } from 'redux-saga/effects';
import Api from '...';

// worker Saga : 将在 USER_FETCH_REQUESTED action 被 dispatch 时调用
function* fetchUser(action) {
  try {
    const user = yield call(Api.fetchUser, action.payload.userId);
    yield put({ type: 'USER_FETCH_SUCCEEDED', user: user });
  } catch (e) {
    yield put({ type: 'USER_FETCH_FAILED', message: e.message });
  }
}

/*
  在每个 `USER_FETCH_REQUESTED` action 被 dispatch 时调用 fetchUser
  允许并发（译注：即同时处理多个相同的 action）
*/
function* mySaga() {
  yield takeEvery('USER_FETCH_REQUESTED', fetchUser);
}

/*
  也可以使用 takeLatest

  不允许并发，dispatch 一个 `USER_FETCH_REQUESTED` action 时，
  如果在这之前已经有一个 `USER_FETCH_REQUESTED` action 在处理中，
  那么处理中的 action 会被取消，只会执行当前的
*/
function* mySaga() {
  yield takeLatest('USER_FETCH_REQUESTED', fetchUser);
}

export default mySaga;
```

- main.js

```js
// 为了能跑起 Saga，我们需要使用 redux-saga 中间件将 Saga 与 Redux Store 建立连接。
import { createStore, applyMiddleware } from 'redux';
import createSagaMiddleware from 'redux-saga';

import reducer from './reducers';
import mySaga from './sagas';

// create the saga middleware
const sagaMiddleware = createSagaMiddleware();
// mount it on the Store
const store = createStore(reducer, applyMiddleware(sagaMiddleware));

// then run the saga
sagaMiddleware.run(mySaga);

// render the application
```

## 一个简单的使用例子

```js
import { delay } from 'redux-saga';
import { put, takeEvery, all } from 'redux-saga/effects';

export function* helloSaga() {
  console.log('Hello Sagas!');
}

// Our worker Saga: 将执行异步的 increment 任务
export function* incrementAsync() {
  // delay，这个函数返回一个延迟 1 秒再 resolve 的 Promise 我们将使用这个函数去 block(阻塞) Generator。
  // use the call Effect
  yield call(delay, 1000);
  yield put({ type: 'INCREMENT' });
}

// Our watcher Saga: 在每个 INCREMENT_ASYNC action spawn 一个新的 incrementAsync 任务
export function* watchIncrementAsync() {
  yield takeEvery('INCREMENT_ASYNC', incrementAsync);
}

// notice how we now only export the rootSaga
// single entry point to start all Sagas at once
export default function* rootSaga() {
  yield all([helloSaga(), watchIncrementAsync()]);
}
```

- main.js

```js
import { createStore, applyMiddleware } from 'redux';
import createSagaMiddleware from 'redux-saga';
import rootSaga from './sagas';

//...
const sagaMiddleware = createSagaMiddleware();

const store = createStore(reducer, applyMiddleware(sagaMiddleware));

sagaMiddleware.run(rootSaga);
```

```js
// put 还是 call 都不执行任何 dispatch 或异步调用，它们只是简单地返回 plain Javascript 对象。

// put({type: 'INCREMENT'}) // => { PUT: {type: 'INCREMENT'} }
// call(delay, 1000)        // => { CALL: {fn: delay, args: [1000]}}
```

- 编写测试用例

```js
import test from 'tape';

import { put, call } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import { incrementAsync } from './sagas';

test('incrementAsync Saga test', (assert) => {
  const gen = incrementAsync();

  assert.deepEqual(
    gen.next().value,
    call(delay, 1000),
    'incrementAsync Saga must call delay(1000)'
  );

  assert.deepEqual(
    gen.next().value,
    put({ type: 'INCREMENT' }),
    'incrementAsync Saga must dispatch an INCREMENT action'
  );

  assert.deepEqual(
    gen.next(),
    { done: true, value: undefined },
    'incrementAsync Saga must be done'
  );

  assert.end();
});
```

## 使用 Saga 辅助函数

- 创建一个将执行异步 action 的任务

```js
import { call, put } from 'redux-saga/effects';

export function* fetchData(action) {
  try {
    const data = yield call(Api.fetchUser, action.payload.url);
    yield put({ type: 'FETCH_SUCCEEDED', data });
  } catch (error) {
    yield put({ type: 'FETCH_FAILED', error });
  }
}
```

```js
// takeEvery 允许多个 fetchData 实例同时启动。在某个特定时刻，尽管之前还有一个或多个 fetchData 尚未结束，我们还是可以启动一个新的 fetchData 任务，

// 如果我们只想得到最新那个请求的响应（例如，始终显示最新版本的数据）。我们可以使用 takeLatest 辅助函数。
import { takeLatest } from 'redux-saga';

function* watchFetchData() {
  yield* takeLatest('FETCH_REQUESTED', fetchData);
}
```

- 后台启动多个 saga 的 Effect

```js
import { takeEvery } from 'redux-saga/effects'

// FETCH_USERS
function* fetchUsers(action) { ... }

// CREATE_USER
function* createUser(action) { ... }

// 同时使用它们
export default function* rootSaga() {
  yield takeEvery('FETCH_USERS', fetchUsers)
  yield takeEvery('CREATE_USER', createUser)
}
```

## 声明式 Effects

```js
import { call } from 'redux-saga/effects';

function* fetchProducts() {
  const products = yield call(Api.fetch, '/products');
  // ...
}
```

```js
// all 创建一个纯文本对象描述函数调用。redux-saga middleware 确保执行函数调用并在响应被 resolve 时恢复 generator。
// 这让你能容易地测试 Generator，就算它在 Redux 环境之外。因为 call 只是一个返回纯文本对象的函数而已。

import { call } from 'redux-saga/effects';
import Api from '...';

const iterator = fetchProducts();

// expects a call instruction
assert.deepEqual(
  iterator.next().value,
  call(Api.fetch, '/products'),
  "fetchProducts should yield an Effect call(Api.fetch, './products')"
);
```

```js
// cps 可以用来处理 Node 风格的函数 （例如，fn(...args, callback) 中的 callback 是 (error, result) => () 这样的形式，

import { cps } from 'redux-saga'

const content = yield cps(readFile, '/path/to/file')


// 当然你也可以像测试 call 一样测试它：
import { cps } from 'redux-saga/effects'

const iterator = fetchSaga()
assert.deepEqual(iterator.next().value, cps(readFile, '/path/to/file') )
```

## 错误处理

```js
import Api from './path/to/api';
import { call, put } from 'redux-saga/effects';

// ...

function* fetchProducts() {
  try {
    const products = yield call(Api.fetch, '/products');
    yield put({ type: 'PRODUCTS_RECEIVED', products });
  } catch (error) {
    yield put({ type: 'PRODUCTS_REQUEST_FAILED', error });
  }
}
```

## 监听未来的 action

- 使用 takeEvery('\*')

```js
// 使用 takeEvery('*')（使用通配符 * 模式），我们就能捕获发起的所有类型的 action。
import { select, takeEvery } from 'redux-saga/effects';

function* watchAndLog() {
  yield takeEvery('*', function* logger(action) {
    const state = yield select();

    console.log('action', action);
    console.log('state after', state);
  });
}
```

- 使用 take Effect 来实现和上面相同的功能

```js
import { select, take } from 'redux-saga/effects';

function* watchAndLog() {
  // 注意，我们运行了一个无限循环的 while(true)。记住这是一个 Generator 函数，它不具备 从运行至完成 的行为（run-to-completion behavior）。 Generator 将在每次迭代阻塞以等待 action 发起。
  while (true) {
    const action = yield take('*');
    const state = yield select();

    console.log('action', action);
    console.log('state after', state);
  }
}
```

- 用户初次创建完三条 Todo 信息时显示祝贺信息。

```js
import { take, put } from 'redux-saga/effects';

function* watchFirstThreeTodosCreation() {
  for (let i = 0; i < 3; i++) {
    const action = yield take('TODO_CREATED');
  }
  yield put({ type: 'SHOW_CONGRATULATION' });
}
```

- take 和 takeEvery 的区别

```js
// 在 takeEvery 的情况中，被调用的任务无法控制何时被调用， 它们将在每次 action 被匹配时一遍又一遍地被调用。并且它们也无法控制何时停止监听。

// 而在 take 的情况中，控制恰恰相反。与 action 被 推向（pushed） 任务处理函数不同，Saga 是自己主动 拉取（pulling） action 的。 看起来就像是 Saga 在执行一个普通的函数调用 action = getNextAction()，这个函数将在 action 被发起时 resolve。

// 使用拉取（pull）模式，我们可以在同一个地方写控制流，而不是重复处理相同的 action。
function* loginFlow() {
  while (true) {
    yield take('LOGIN');
    // ... perform the login logic
    yield take('LOGOUT');
    // ... perform the logout logic
  }
}
```

## 无阻塞调用

```js
// 为了表示无阻塞调用，redux-saga 提供了另一个 Effect：fork。 当我们 fork 一个 任务，任务会在后台启动，调用者也可以继续它自己的流程，而不用等待被 fork 的任务结束。

// 为了取消 fork 任务，我们可以使用一个指定的 Effect cancel
import { take, put, call, fork, cancel } from 'redux-saga/effects';

// ...

function* loginFlow() {
  while (true) {
    const { user, password } = yield take('LOGIN_REQUEST');
    // fork return a Task object
    const task = yield fork(authorize, user, password);
    const action = yield take(['LOGOUT', 'LOGIN_ERROR']);
    if (action.type === 'LOGOUT') yield cancel(task);
    yield call(Api.clearItem('token'));
  }
}

// cancel Effect 不会粗暴地结束我们的 authorize 任务，相反它会给予一个机会执行清理的逻辑。 在 finally 区块可以处理任何的取消逻辑（以及其他类型的完成逻辑）。由于 finally 区块执行在任何类型的完成上（正常的 return, 错误, 或强制取消），如果你想要为取消作特殊处理，有一个 cancelled Effect：

import { take, call, put, cancelled } from 'redux-saga/effects';
import Api from '...';

function* authorize(user, password) {
  try {
    const token = yield call(Api.authorize, user, password);
    yield put({ type: 'LOGIN_SUCCESS', token });
    yield call(Api.storeItem, { token });
    return token;
  } catch (error) {
    yield put({ type: 'LOGIN_ERROR', error });
  } finally {
    if (yield cancelled()) {
      // ... put special cancellation handling code here
    }
  }
}
```

## 同时执行多个任务

```js
import { call } from 'redux-saga/effects';

// 正确写法, effects 将会同步执行
const [users, repos] = yield[(call(fetch, '/users'), call(fetch, '/repos'))];
```

## 在多个 Effects 之间启动 race

```js
// 触发一个远程的获取请求，并且限制了 1 秒内响应，否则作超时处理。
import { race, call, put } from 'redux-saga/effects';
import { delay } from 'redux-saga';

function* fetchPostsWithTimeout() {
  const { posts, timeout } = yield race({
    posts: call(fetchApi, '/posts'),
    timeout: call(delay, 1000),
  });

  if (posts) put({ type: 'POSTS_RECEIVED', posts });
  else put({ type: 'TIMEOUT_ERROR' });
}

// race 的另一个有用的功能是，它会自动取消那些失败的 Effects。
// 在 CANCEL_TASK action 被发起的情况下，race Effect 将自动取消 backgroundTask，并在 backgroundTask 中抛出一个取消错误。
import { race, take, call } from 'redux-saga/effects'

function* backgroundTask() {
  while (true) { ... }
}

function* watchStartBackgroundTask() {
  while (true) {
    yield take('START_BACKGROUND_TASK')
    yield race({
      task: call(backgroundTask),
      cancel: take('CANCEL_TASK')
    })
  }
}
```

## 使用 yield\* 对 Sagas 进行排序

```js
function* playLevelOne() { ... }

function* playLevelTwo() { ... }

function* playLevelThree() { ... }

function* game() {
  const score1 = yield* playLevelOne()
  yield put(showScore(score1))

  const score2 = yield* playLevelTwo()
  yield put(showScore(score2))

  const score3 = yield* playLevelThree()
  yield put(showScore(score3))
}
```

## 组合 Sagas

```js
function* mainSaga(getState) {
  const results = yield [call(task1), call(task2), ...]
  yield put(showResults(results))
}

// 希望用户在有限的时间内完成一些游戏：
function* game(getState) {
  let finished
  while(!finished) {
    // 必须在 60 秒内完成
    const {score, timeout} = yield race({
      score: call( play, getState),
      timeout: call(delay, 60000)
    })

    if (!timeout) {
      finished = true
      yield put(showScore(score))
    }
  }
}
```

## 取消任务

```js
// 一旦任务被 fork，可以使用 yield cancel(task) 来中止任务执行。取消正在运行的任务。
import {
  take,
  put,
  call,
  fork,
  cancel,
  cancelled,
  delay,
} from 'redux-saga/effects';
import { someApi, actions } from 'somewhere';

function* bgSync() {
  try {
    while (true) {
      yield put(actions.requestStart());
      const result = yield call(someApi);
      yield put(actions.requestSuccess(result));
      yield delay(5000);
    }
  } finally {
    if (yield cancelled()) yield put(actions.requestFailure('Sync cancelled!'));
  }
}

function* main() {
  while (yield take(START_BACKGROUND_SYNC)) {
    // 启动后台任务
    const bgSyncTask = yield fork(bgSync);

    // 等待用户的停止操作
    yield take(STOP_BACKGROUND_SYNC);
    // 用户点击了停止，取消后台任务
    // 这会导致被 fork 的 bgSync 任务跳进它的 finally 区块
    yield cancel(bgSyncTask);
  }
}
```

## redux-saga 的 fork model

```js
// 在 redux-saga 的世界里，你可以使用 2 个 Effects 在后台动态地 fork task

// fork 用来创建 attached forks
// spawn 用来创建 detached forks

import { delay } from 'redux-saga';
import { fork, call, put } from 'redux-saga/effects';
import api from './somewhere/api'; // app specific
import { receiveData } from './somewhere/actions'; // app specific

function* fetchAll() {
  const task1 = yield fork(fetchResource, 'users');
  const task2 = yield fork(fetchResource, 'comments');
  yield call(delay, 1000);
}

function* fetchResource(resource) {
  const { data } = yield call(api.fetch, resource);
  yield put(receiveData(data));
}

function* main() {
  yield call(fetchAll);
}

function* fetchAll() {
  yield all([
    call(fetchResource, 'users'), // task1
    call(fetchResource, 'comments'), // task2,
    call(delay, 1000),
  ]);
}
```

## 并发

- takeEvery

```js
import { fork, take } from 'redux-saga/effects';

const takeEvery = (pattern, saga, ...args) =>
  fork(function* () {
    while (true) {
      const action = yield take(pattern);
      yield fork(saga, ...args.concat(action));
    }
  });
```

- takeLatest

```js
import { cancel, fork, take } from 'redux-saga/effects';

const takeLatest = (pattern, saga, ...args) =>
  fork(function* () {
    let lastTask;
    while (true) {
      const action = yield take(pattern);
      if (lastTask) {
        yield cancel(lastTask); // 如果任务已经结束，则 cancel 为空操作
      }
      lastTask = yield fork(saga, ...args.concat(action));
    }
  });
```

## 节流（Throttling）

```js
import { throttle } from 'redux-saga/effects';

function* handleInput(input) {
  // ...
}

function* watchInput() {
  yield throttle(500, 'INPUT_CHANGED', handleInput);
}
```

## 防抖动（Debouncing）

```js
import { call, cancel, fork, take, delay } from 'redux-saga/effects'

function* handleInput(input) {
  // 500ms 防抖动
  yield delay(500)
  ...
}

function* watchInput() {
  let task
  while (true) {
    const { input } = yield take('INPUT_CHANGED')
    if (task) {
      yield cancel(task)
    }
    task = yield fork(handleInput, input)
  }
}
```

- 发起 ajax 请求

```js
import { delay } from 'redux-saga/effects';

function* updateApi(data) {
  while (true) {
    try {
      const apiResponse = yield call(apiRequest, { data });
      return apiResponse;
    } catch (error) {
      yield put({
        type: 'UPDATE_RETRY',
        error,
      });
      yield delay(2000);
    }
  }
}

function* updateResource({ data }) {
  const apiResponse = yield call(updateApi, data);
  yield put({
    type: 'UPDATE_SUCCESS',
    payload: apiResponse.body,
  });
}

export function* watchUpdateResource() {
  yield takeLatest('UPDATE_START', updateResource);
}
```

## 撤销（Undo）

```js
// Undo 通过允许 action 顺利进行来尊重使用者，在假设使用者不知道他们在做什么之前。
import { take, put, call, spawn, race, delay } from 'redux-saga/effects';
import { updateThreadApi, actions } from 'somewhere';

function* onArchive(action) {
  const { threadId } = action;
  const undoId = `UNDO_ARCHIVE_${threadId}`;

  const thread = { id: threadId, archived: true };

  // show undo UI element, and provide a key to communicate
  yield put(actions.showUndo(undoId));

  // optimistically mark the thread as `archived`
  yield put(actions.updateThread(thread));

  // allow the user 5 seconds to perform undo.
  // after 5 seconds, 'archive' will be the winner of the race-condition
  const { undo, archive } = yield race({
    undo: take((action) => action.type === 'UNDO' && action.undoId === undoId),
    archive: delay(5000),
  });

  // hide undo UI element, the race condition has an answer
  yield put(actions.hideUndo(undoId));

  if (undo) {
    // revert thread to previous state
    yield put(actions.updateThread({ id: threadId, archived: false }));
  } else if (archive) {
    // make the API call to apply the changes remotely
    yield call(updateThreadApi, thread);
  }
}

function* main() {
  while (true) {
    // wait for an ARCHIVE_THREAD to happen
    const action = yield take('ARCHIVE_THREAD');
    // use spawn to execute onArchive in a non-blocking fashion, which also
    // prevents cancellation when main saga gets cancelled.
    // This helps us in keeping state in sync between server and client
    yield spawn(onArchive, action);
  }
}
```

## 资源

```js
// redux-saga 官方文档
// https://redux-saga-in-chinese.js.org/
```
