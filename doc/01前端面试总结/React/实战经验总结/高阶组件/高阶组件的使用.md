# 高阶组件的使用

## 装饰器

- 基本概念

```ts
/**
 * 装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。
 * 这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。
 */
```

- 类装饰器

```ts
/**
 * 装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。
 */
@testable
class MyTestableClass {
  // ...
}

function testable(target) {
  target.isTestable = true;
}

MyTestableClass.isTestable; // true

/**
 * 原理剖析
 * 基本上，装饰器的行为就是下面这样
 */

@decorator
class A {}

// 等同于

class A {}
A = decorator(A) || A;

/**
 * 装饰器外面再封装一层函数,用于传入其他的参数
 */
function testable(isTestable) {
  return function (target) {
    target.isTestable = isTestable;
  };
}

@testable(true)
class MyTestableClass {}
MyTestableClass.isTestable; // true

@testable(false)
class MyClass {}
MyClass.isTestable; // false

/**
 * 通过目标类的prototype对象给类添加实例属性
 */
function testable(target) {
  target.prototype.isTestable = true;
}

@testable
class MyTestableClass {}

let obj = new MyTestableClass();
obj.isTestable; // true

/**
 * 通过装饰器来实现一个混合类
 */
// mixins.js
export function mixins(...list) {
  return function (target) {
    Object.assign(target.prototype, ...list);
  };
}

// main.js
import { mixins } from './mixins';

const Foo = {
  foo() {
    console.log('foo');
  },
};

@mixins(Foo)
class MyClass {}

let obj = new MyClass();
obj.foo(); // 'foo'
```

- 方法的装饰器

```ts
/**
 * 如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行
 * 装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升
 */

class Mathfn {
  @log
  add(a, b) {
    return a + b;
  }
}

console.dir(Mathfn);

function log(target, name, descriptor) {
  // 装饰器第一个参数是类的原型对象，Mathfn.ptotoType
  // 装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型
  // 第二个参数是所要装饰的属性名，
  // 第三个参数是该属性的描述对象
  console.log('target', target);
  var oldValue = descriptor.value;
  // descriptor对象原来的值如下
  // {
  //   value: specifiedFunction,
  //   enumerable: false,
  //   configurable: true,
  //   writable: true
  // };

  descriptor.value = function () {
    console.log(`Calling ${name} with`, arguments);
    // 后面math实例调用了这个方法,所有this指向了math的实例
    return oldValue.apply(this, arguments);
  };

  return descriptor;
}

const math = new Mathfn();

math.add(2, 4);
```

- 装饰器类不能用于装饰普通的方法

```ts
/**
 * 由于存在函数提升，使得装饰器不能用于函数。
 * 类是不会提升的，所以就没有这方面的问题
 */

var readOnly = require('some-decorator');

@readOnly
function foo() {}

// 实际代码运行是这样的
var readOnly;

@readOnly
function foo() {}

readOnly = require('some-decorator');

/**
 * 高阶函数的形式直接执行,装饰普通方法
 */
function doSomething(name) {
  console.log('Hello, ' + name);
}

function loggingDecorator(wrapped) {
  return function () {
    console.log('Starting');
    const result = wrapped.apply(this, arguments);
    console.log('Finished');
    return result;
  };
}

const wrapped = loggingDecorator(doSomething);
```

- 属性装饰器

```ts
/**
 * 属性装饰器表达式会在运行时当作函数被调用，
 * 传入下列2个参数：
 * 1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
 * 2、成员的名字。
 */

//属性装饰器
function logProperty(params: any) {
  return function (target: any, attr: any) {
    console.log(target); // 对于实例成员是类的原型对象。
    console.log(attr); // 要装饰的属性
    target[attr] = params;
  };
}

class HttpClient {
  @logProperty('http://loaderman.com')
  public url: any | undefined;
  constructor() {}
  getData() {
    console.log(this.url);
  }
}
var http = new HttpClient();
console.log('http', http);
http.getData();
```

## 高阶组件的基本使用

- 高阶组件的基本使用

```tsx
/**
 * 高阶组件是复用组件逻辑的一种高阶技巧,是基于React组合特性而形成的一种设计模式
 * 注意点:
 * 1.不要在render方法中使用HOC
 * 2.如果使用到包装组件的静态方法需要单独拷贝这些静态方法
 * 3.使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法
 * 4.ref不会被传递
 * 如果将ref添加到返回的HOC高阶组件中,则ref指向容器组件,而不是包装组件
 * 5.高阶组件可以使用with开头
 */

import React, { Component } from 'react';

// 接收一个组件
const withSubscription = (WrappedComponent, selectData) => {
  // 并返回另外一个组件
  return class extends Component<any, any> {
    constructor(props) {
      super(props);
      this.state = {
        data: selectData(),
      };
    }

    render() {
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
  };
};

// 包装组件1
class Comlist1 extends Component<any, any> {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <React.Fragment>
        <div>这是包装组件1：</div>
        <p>{this.props.data}</p>
      </React.Fragment>
    );
  }
}

// 包装组件二
class Comlist2 extends Component<any, any> {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <React.Fragment>
        <div>这是包装组件2：</div>
        <p>{this.props.data}</p>
      </React.Fragment>
    );
  }
}

const Comlist1WithSubscription = withSubscription(Comlist1, () => '包装组件1');
const Comlist2WithSubscription = withSubscription(Comlist2, () => '包装组件2');

class Game extends Component<any, any> {
  render() {
    return (
      <React.Fragment>
        <Comlist1WithSubscription />
        <Comlist2WithSubscription />
      </React.Fragment>
    );
  }
}

export default Game;
```

- 属性代理模式的高阶组件

```tsx
import React, { Component } from 'react';

const Mycontainer = (WrappedComponent) => {
  return class extends Component {
    // 通过ref获取包装组件的实例
    proc = (WrappedComponentInstance) => {
      console.log('获取到包装组件的实例', WrappedComponentInstance);
    };
    render() {
      // 需要添加给包装组件的新特性
      const newProps = {
        name: '包装组件的名称',
        data: [1, 2, 3, 4],
        ref: this.proc,
      };
      return (
        <React.Fragment>
          <div>通过高阶组件包装过了</div>
          <WrappedComponent {...this.props} {...newProps} />
        </React.Fragment>
      );
    }
  };
};

class HOCcomponent extends Component {
  constructor(props) {
    super(props);
    this.state = {};
  }
  componentDidMount() {
    // 可以获取到高阶组件传递过来的额外属性
    console.log(this.props);
  }
  render() {
    return (
      <div className="HOCcomponent">
        <div>这是一个包装组件</div>
      </div>
    );
  }
}

export default Mycontainer(HOCcomponent);
```

- 反向继承模式下的高阶组件

```ts
import React, { Component } from 'react';

const Mycontainer = (WrappedComponent) => {
  return class extends WrappedComponent {
    render() {
      const elementsTree = super.render();
      console.log('elementTree', elementsTree);
      console.log('获取包装组件的props', this.props);
      console.log('获取包装组件的state', this.state);
      let newProps = {};
      if (elementsTree && elementsTree.type === 'input') {
        newProps = {
          value: '经过高阶组件修改后的输入控件的值',
          onChange: () => {},
        };
      }
      const props = Object.assign({}, elementsTree.props, newProps);
      const newElementsTree = React.cloneElement(
        elementsTree,
        props,
        elementsTree.props.children
      );
      return newElementsTree;
    }
  };
};

class HOCcomponent extends Component {
  constructor(props) {
    super(props);
    this.state = {
      show: false,
    };
  }

  componentDidMount() {
    this.setState(
      (preState, props) => {
        console.log('包装组件的preState', preState);
        console.log('包装组件的props', props);
        return {
          show: true,
        };
      },
      () => {
        console.log('包装组件状态已经发生改变');
      }
    );
  }

  render() {
    return <input value="这是一个包装组件" />;
  }
}

export default Mycontainer(HOCcomponent);
```

## 简单的提示框高阶组件用法

- 提示框

```tsx
import React, { Component } from 'react';

const TipsLayout = (WrapComponent) => {
  return class extends Component {
    render() {
      return (
        <div className="tip-container">
          <h2>提示组件的标题</h2>
          <div className="tip-content">
            {/* 显示不同内容的组件 */}
            <WrapComponent />
          </div>
        </div>
      );
    }
  };
};

export default TipsLayout;
```

- 提示框内容 A

```tsx
import React, { Component } from 'react';
import TipsLayout from './TipsLayout';
class TipContentA extends Component {
  render() {
    return (
      <div className="TipContentA">
        <div>提示内容A</div>
      </div>
    );
  }
}

export default TipsLayout(TipContentA);
```
