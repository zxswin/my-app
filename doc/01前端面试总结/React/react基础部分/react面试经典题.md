## react 的虚拟 dom 是怎么实现 diff 算法

```ts
/**
 * 递归遍历虚拟dom进行比较,只会对同一层的节点进行比较
 * 1.若发现节点已不存在，则该节点及其子节点会被完全删除，不会用于进一步的比较
 * 2.若发现节点类型不一样，则会直接删除该节点,然后直接创建新的节点进行替换
 * 3.若节点类型一样，则会比较prop是否有更新，假如有prop不一样，则会重新设置该节点的属性,并比较其子节点
 *
 */
```

## react 的事件机制

```ts
/**
 *
 * 事件实现机制
 * react 的事件机制利用了事件委托机制。
 * 事件并没有绑定在真实的 dom 节点上，而是把事件都绑定在结构的最外层 document，使用一个统一的事件监听器。
 * 所有的事件都由这个监听器统一分发。
 * 
 * 组件挂载和更新时，会将绑定的事件分门别类的放进一个的事件池里。
 * 事件触发时，根据事件产生的Event对象找到触发事件的组件，再通过组件标识和事件类型从事件池里找到对应的事件监听回调，
 * 然后执行相关的监听函数

 *
 * 特点:
 * 1.react合成事件仅实现了冒泡机制
 * 2.react合成事件无法阻止原生事件的冒泡。反之原生事件的阻止冒泡行为，却可以阻止合成事件的传播。
 */
```

## React 中 keys 的作用

```ts
/**
 * 保证元素的key在其同级元素中具有唯一性
 * 在React Diff算法借助元素的Key值,更快的找到对应的节点,判断元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。
 * 如果key一样，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新，如果key不一样，则react先销毁该组件，然后重新创建该组件
 */
```

## 类组件和函数式组件之间有何不同

```ts
/**
 * 函数式组件
 * 组件不会被实例化,整体渲染性能得到提升
 * 组件不能访问this对象
 * 组件无法访问生命周期的方法
 * 无状态组件只能访问输入的props,无副作用
 */
```

## react 和 vue 的区别

```ts
/**
 * 1.监听数据变化的实现原理不同
 * Vue通过 getter/setter以及一些函数的劫持，能精确知道数据变化。
 * React不精确监听数据变化而是setState后触发重新构建虚拟dom进行diff
 *
 * 2.数据流的不同
 * vue支持数据的双向绑定
 * React一直不支持双向绑定，提倡的是单向数据流
 *
 * 3.学法不一样
 * react是类式的组件写法,
 * vue是声明式的写法
 *
 * 4.组件通信的区别
 * Vue父组件通过props向子组件传递数据,子组件通过事件向父组件发送消息
 * React父组件通过props可以向子组件传递数据或者回调；可以通过 context 进行跨层级的通信
 *
 * 5.框架本质不同
 * Vue本质是MVVM框架，由MVC发展而来；
 * React是前端组件化框架，由后端组件化发展而来。
 *
 * 框架的选择上
 * vue的响应式机制也有问题，就是当state特别多的时候，Watcher也会很多，会导致卡顿，
 * 所以大型应用（状态特别多的）一般用react，更加可控。
 */
```

## 在 React 中，refs 的作用是什么

```ts
/**
 * Refs 可以用于获取一个 DOM 节点或者 React 组件的引用
 *
 * 如何创建refs
 * 通过React.createRef（）创建的，并通过ref属性附加到react元素，在构造组件中，
 * 通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。
 */
```

## 什么是虚拟 DOM

```js
// 虚拟DOM其实就是用一个原生的JS对象去描述一个DOM节点，实际上它只是对真实 DOM 的一层抽象。最终可以通过一系列操作使这棵树映射到真实环境上。

// 相当于在js与DOM之间做了一个缓存，利用patch（diff算法）对比新旧虚拟DOM记录到一个对象中按需更新， 最后创建真实的DOM

// 模板 ==> 渲染函数 ==> 虚拟DOM树 ==> 真实DOM
```

## 什么是高阶组件

```js
// 高阶组件(HOC)是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为纯组件，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为

// HOC 可以用于以下许多用例

// 代码重用、逻辑和引导抽象
// 渲染劫持
// state 抽象和操作
// props 处理
```

## 在构造函数调用 super 并将 props 作为参数传入的作用是啥

```js
// 在调用 super() 方法之前，子类构造函数无法使用this引用，ES6 子类也是如此。
// 将 props 参数传递给 super() 调用的主要原因是在子构造函数中能够通过this.props来获取传入的 props。
```

## 受控组件和非受控组件区别是啥

```js
// 受控组件是 React 控制中的组件，并且是表单数据真实的唯一来源。
// 非受控组件是由 DOM 处理表单数据的地方，而不是在 React 组件中。

// 尽管非受控组件通常更易于实现，因为只需使用refs即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。
```

## 区分 Real DOM 和 Virtual DOM

```js
// Real DOM
// 1. 更新缓慢。
// 2. 可以直接更新 HTML。
// 3. 如果元素更新，则创建新DOM。
// 4. DOM操作代价很高。
// 5. 消耗的内存较多。

// Virtual DOM
// 1. 更新更快。
// 2. 无法直接更新 HTML。
// 3. 如果元素更新，则更新 JSX 。
// 4. DOM 操作非常简单。
// 5. 很少的内存消耗。
```
