## React 生命周期及更新机制

- 父组件状态更新对子组件的影响

```tsx
/**
 * 1.只要父组件render了,会触发它下面的所有子组件重新render(包括了子组件下面的子组件)
 * 2.React的diff算法会决定是否确实更新DOM元素
 * 3.重新渲染是javascript执行的,速度很快,父组件触发下面子组件的重新渲染效率不会有太大的影响
 */
```

- 挂载阶段的生命周期调用顺序

```ts
/**
 * 1.constructor()
 * 2.static getDerivedStateFromProps()
 * 3.render()
 * 4.componentDidMount();
 *
 * 即将过时的生命周期应该避免使用他们
 * componentWillMount()
 */
```

- 更新阶段的生命周期调用顺序

```ts
/**
 * 当组件的props或state发生变化时触发更新
 * 1.static getDerivedStateFromProps()
 * 2.shouldComponentUpdate()
 * 3.render()
 * 4.getSnapshotBeforeUpdate()
 * 5.componentDidUpdate()
 *
 * 即将过时的生命周期方法
 * componentWillUpdate()
 * componentWillReceiveProps()
 */
```

- 卸载阶段执行的生命周期方法

```ts
/**
 * componentWillUnmount()
 */
```

- 错误处理

```ts
/**
 * 当渲染过程,生命周期 或子组件的构造函数中抛出异常错误会调用如下方法
 * static getDerivedStateFromError()
 * componentDidCatch()
 */
```

## 各个生命周期函数详解

- render() 方法

```ts
/**
 * render() 方法是 class 组件中唯一必须实现的方法
 * render() 函数应该为纯函数，修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。
 * 如果需要和浏览器交互,请在componentDidMount或其他生命周期函数中执行
 * 当render被调用的时候会检查this.props和this.state的变化并返回如下类型之一:
 * 1.React 元素
 * 2.数组或 fragments
 * 3.Portals
 * 4.字符串或数值类型
 * 5.布尔类型或 null。什么都不渲染
 */
```

- constructor()

```ts
/**
 * 如果不初始化state或不进行方法绑定,则不需要为React 实现构造函数
 * 通常情况下构造函数只处理:
 * 1.通过给this.state赋值对象来初始化state
 * 2.为事件处理函数绑定实例
 *
 * 只能在构造函数中直接为 this.state 赋值
 * 如需在其他方法中赋值，你应使用 this.setState() 替代。
 *
 *
 * 避免将 props 的值复制给 state！这是一个常见的错误：
 * 如此做毫无必要（你可以直接使用 this.props.color），
 * 同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。
 */

constructor(props) {
  // 在其他语句之前调用super(props)
  super(props);
  // 不要在这里调用 this.setState()
  this.state = { counter: 0 };
  this.handleClick = this.handleClick.bind(this);
}
```

- componentDidMount()

```ts
/**
 * componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用
 * 依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方
 *
 * 可以在componentDidMount()中添加订阅
 * 在componentWillUnmount() 里取消订阅
 *
 * 可以在 componentDidMount() 里直接调用 setState()
 * 将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前
 * 请谨慎使用该模式，因为它会导致性能问题
 */
```

- componentDidUpdate()

```ts
/**
 * componentDidUpdate() 会在更新后会被立即调用。首次渲染不会执行此方法。
 * 在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里 否则会导致死循环
 * 还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能
 *
 * 与getSnapshotBeforeUpdate()生命周期的关系
 * 如果组件实现了 getSnapshotBeforeUpdate() 生命周期（不常用），
 * 则它的返回值将作为 componentDidUpdate() 的第三个参数 “snapshot” 参数传递。否则此参数将为 undefined
 *
 * 与 shouldComponentUpdate()生命周期的关系
 * 如果 shouldComponentUpdate() 返回值为 false，则不会调用 componentDidUpdate()
 */

componentDidUpdate(prevProps) {
  // 典型用法（不要忘记比较 props）
  if (this.props.userID !== prevProps.userID) {
    this.fetchData(this.props.userID);
  }
}
```

- componentWillUnmount()

```ts
/**
 * componentWillUnmount() 会在组件卸载及销毁之前直接调用。
 * 此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等
 *
 * componentWillUnmount() 中不应调用 setState()，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。
 */
```

- shouldComponentUpdate()

```ts
/**
 * 根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响
 * 当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true
 * 首次渲染或使用 forceUpdate() 时不会调用该方法
 * 返回 false 并不会阻止子组件在 state 更改时重新渲染。
 *
 * 不建议在 shouldComponentUpdate() 中进行深层比较或使用 JSON.stringify()。这样非常影响效率，且会损害性能。
 *
 * 此方法仅作为性能优化的方式而存在
 * 考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()
 * PureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性
 */

shouldComponentUpdate(nextProps,nextState){
    if(nextProps.name !== this.props.name){
        return true
    }else{
        return false
    }
}
```

- static getDerivedStateFromProps()

```ts
/**
 * static getDerivedStateFromProps(props, state)
 * getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用
 * 它应返回一个对象来更新 state，如果返回 null 则不更新任何内容
 *
 * getDerivedStateFromProps 的存在只有一个目的：让组件在 props 变化时更新 state。
 * 该生命周期函数并不常用
 */
```

- getSnapshotBeforeUpdate()

```ts
/**
 * getSnapshotBeforeUpdate(prevProps, prevState)
 * getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用
 * 它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。
 * 此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。
 */

// 此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等
// 应返回 snapshot 的值（或 null）
class ScrollingList extends React.Component {
  constructor(props) {
    super(props);
    this.listRef = React.createRef();
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    // 我们是否在 list 中添加新的 items ？
    // 捕获滚动​​位置以便我们稍后调整滚动位置。
    if (prevProps.list.length < this.props.list.length) {
      const list = this.listRef.current;
      return list.scrollHeight - list.scrollTop;
    }
    return null;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，
    // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。
    //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）
    if (snapshot !== null) {
      const list = this.listRef.current;
      list.scrollTop = list.scrollHeight - snapshot;
    }
  }

  render() {
    return <div ref={this.listRef}>{/* ...contents... */}</div>;
  }
}
```

- 错误边界(Error boundaries)

```ts
/**
 * 它会在其子组件树中的任何位置捕获 JavaScript 错误，并记录这些错误，展示降级 UI 而不是崩溃的组件树
 * 仅使用 Error boundaries 组件来从意外异常中恢复的情况；不要将它们用于流程控制
 */

/**
 * static getDerivedStateFromError(error)
 * 此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state
 * getDerivedStateFromError() 会在渲染阶段调用，因此不允许出现副作用。 如遇此类情况，请改用 componentDidCatch()。
 */

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // 更新 state 使下一次渲染可以显降级 UI
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      // 你可以渲染任何自定义的降级  UI
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}

/**
 * componentDidCatch()
 * componentDidCatch(error, info)
 * componentDidCatch() 会在“提交”阶段被调用，因此允许执行副作用
 * 它应该用于记录错误之类的情况
 *
 * 推荐使用静态 getDerivedStateFromError() 来处理降级渲染
 * componentDidCatch 只用于记录错误信息
 */

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // 更新 state 使下一次渲染可以显示降级 UI
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    // "组件堆栈" 例子:
    //   in ComponentThatThrows (created by App)
    //   in ErrorBoundary (created by App)
    //   in div (created by App)
    //   in App
    logComponentStackToMyService(info.componentStack);
  }

  render() {
    if (this.state.hasError) {
      // 你可以渲染任何自定义的降级 UI
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}
```

## 过时的生命周期方法

- componentWillMount()

```ts
/**
 * componentWillMount() 在挂载之前被调用。它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染。
 * 此方法是服务端渲染唯一会调用的生命周期函数
 */
```

- componentWillReceiveProps()

```ts
/**
 * componentWillReceiveProps() 会在已挂载的组件接收新的 props 之前被调用
 * React 不会针对初始 props 调用 componentWillReceiveProps()。
 * 组件只会在组件的 props 更新时调用此方法。
 * 调用 this.setState() 通常不会触发componentWillReceiveProps()。
 */
```

- componentWillUpdate()

```ts
/**
 * componentWillUpdate(nextProps, nextState)
 * 当组件收到新的 props 或 state 时，会在渲染之前调用 componentWillUpdate()
 * 如果 shouldComponentUpdate() 返回 false，则不会调用 componentWillUpdate()
 * 不能此方法中调用 this.setState()
 */
```

## 可以在组件中调用的方法

- setState()

```ts
/**
 * setState(updater, [callback])
 * setState() 将始终执行重新渲染操作
 * setState() 将对组件 state 的更改排入队列，并通知 React 需要使用更新后的 state 重新渲染此组件及其子组件。
 */

this.setState({
  counter: state.counter + props.step,
});

this.setState((state, props) => {
  return { counter: state.counter + props.step };
});

// updater 的返回值会与 state 进行浅合并
// setState() 在合成事件和生命周期下是异步的,在原生事件下则是同步的,
// 并且在同一周期内会对多个 setState 进行批处理
Object.assign(
  previousState,
  {quantity: state.quantity + 1},
  {quantity: state.quantity + 1},
  ...
)

```

- forceUpdate()

```ts
/**
 * 如果 render() 方法依赖于其他数据，则可以调用 forceUpdate() 强制让组件重新渲染。
 * 调用 forceUpdate() 将致使组件调用 render() 方法，此操作会跳过该组件的 shouldComponentUpdate()。
 * 但其子组件会触发正常的生命周期方法，包括 shouldComponentUpdate() 方法。如果标记发生变化，React 仍将只更新 DOM。
 * 通常你应该避免使用 forceUpdate()，尽量在 render() 中使用 this.props 和 this.state。
 */
```

## class 属性

- defaultProps

```ts
/**
 * defaultProps 可以为 Class 组件添加默认 props。这一般用于 props 未赋值，但又不能为 null 的情况
 */

class CustomButton extends React.Component {
  // ...
}

CustomButton.defaultProps = {
  color: 'blue',
};
```

- displayName

```ts
/**
 * displayName 字符串多用于调试消息
 */
```
