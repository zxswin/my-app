## 基于 class 的动画和过渡

```html
<div id="demo">
  Push this button to do something you shouldn't be doing:<br />

  <div :class="{ shake: noActivated }">
    <button @click="noActivated = true">Click me</button>
    <span v-if="noActivated">Oh no!</span>
  </div>
</div>
```

```css
.shake {
  animation: shake 0.82s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  transform: translate3d(0, 0, 0);
  backface-visibility: hidden;
  perspective: 1000px;
}

@keyframes shake {
  10%,
  90% {
    transform: translate3d(-1px, 0, 0);
  }

  20%,
  80% {
    transform: translate3d(2px, 0, 0);
  }

  30%,
  50%,
  70% {
    transform: translate3d(-4px, 0, 0);
  }

  40%,
  60% {
    transform: translate3d(4px, 0, 0);
  }
}
```

```js
// 通过添加一个条件 class 来激活动画，而无需挂载组件。
const Demo = {
  data() {
    return {
      noActivated: false,
    };
  },
};

Vue.createApp(Demo).mount('#demo');
```

## 过渡与 Style 绑定

```html
<div id="demo">
  <div
    @mousemove="xCoordinate"
    :style="{ backgroundColor: `hsl(${x}, 80%, 50%)` }"
    class="movearea"
  >
    <h3>Move your mouse across the screen...</h3>
    <p>x: {{x}}</p>
  </div>
</div>
```

```css
.movearea {
  transition: 0.2s background-color ease;
}
```

```js
const Demo = {
  data() {
    return {
      x: 0,
    };
  },
  methods: {
    xCoordinate(e) {
      this.x = e.clientX;
    },
  },
};

Vue.createApp(Demo).mount('#demo');
```

## 性能

```js
// 尽可能对元素动画进行硬件加速，并使用不触发重绘的 property。
// 非常好的是，更改 transform 不会触发任何几何形状变化或绘制。这意味着该操作可能是由合成器线程在 GPU 的帮助下执行。
// opacity 属性的行为也类似。因此，他们是在 web 上做元素移动的理想选择。
```

- 硬件加速

```js
// perspective、backface-visibility 和 transform:translateZ(x) 等 property 将让浏览器知道你需要硬件加速。
```

```css
/* 
  如果要对一个元素进行硬件加速，可以应用以下任何一个 property (并不是需要全部，任意一个就可以)：
  许多像 GreenSock 这样的 JS 库都会默认你需要硬件加速，并在默认情况下应用，所以你不需要手动设置它们。
*/

.a {
  perspective: 1000px;
  backface-visibility: hidden;
  transform: translateZ(0);
}
```

## 缓动效果

```js
const ButtonApp = {
  data() {
    return {
      message: 'Hover Me!',
    };
  },
};

Vue.createApp(ButtonApp).mount('#app');
```

```html
<div id="app">
  <button class="button">{{ message }}</button>
</div>
```

```css
body {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 40px;
}

.button {
  background: #1b8f5a;
  transition: background 0.25s ease-in;
  border-radius: 4px;
  display: inline-block;
  border: none;
  padding: 0.75rem 1rem;
  margin: 0;
  text-decoration: none;
  color: #ffffff;
  font-family: sans-serif;
  font-size: 1rem;
  cursor: pointer;
  text-align: center;
  -webkit-appearance: none;
  -moz-appearance: none;
}

button:hover,
button:focus {
  transition: background 0.3s ease-out;
  background: #3eaf7c;
}

button:focus {
  outline: 1px solid #fff;
  outline-offset: -4px;
}
```

```css
.button {
  background: #1b8f5a;
  /* 应用于初始状态，因此此转换将应用于返回状态 */
  transition: background 0.25s ease-in;
}

.button:hover {
  background: #3eaf7c;
  /* 应用于悬停状态，因此在触发悬停时将应用此过渡 */
  transition: background 0.35s ease-out;
}
```

## CSS 中用来实现 bounce 的代码

```css
/* 
  CSS 允许你通过调整 cubic-bezier 函数的参数来修改缓动效果，
*/
@keyframes bounceInDown {
  from,
  60%,
  75%,
  90%,
  to {
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }

  0% {
    opacity: 0;
    transform: translate3d(0, -3000px, 0) scaleY(3);
  }

  60% {
    opacity: 1;
    transform: translate3d(0, 25px, 0) scaleY(0.9);
  }

  75% {
    transform: translate3d(0, -10px, 0) scaleY(0.95);
  }

  90% {
    transform: translate3d(0, 5px, 0) scaleY(0.985);
  }

  to {
    transform: translate3d(0, 0, 0);
  }
}

.bounceInDown {
  animation-name: bounceInDown;
}
```

```js
// 使用 GreenSock 实现相同的 bounce：
gsap.from(element, { duration: 1, ease: 'bounce.out', y: -500 });
```
