## 监听事件

```html
<!-- 用法为 v-on:click="methodName" 或使用快捷方式 @click="methodName" -->
<div id="basic-event">
  <button @click="counter += 1">Add 1</button>
  <p>The button above has been clicked {{ counter }} times.</p>
</div>
```

```js
Vue.createApp({
  data() {
    return {
      counter: 0,
    };
  },
}).mount('#basic-event');
```

## 事件处理方法

```html
<!-- v-on 还可以接收一个需要调用的方法名称。 -->
<div id="event-with-method">
  <!-- `greet` 是在下面定义的方法名 -->
  <button @click="greet">Greet</button>
</div>
```

```js
Vue.createApp({
  data() {
    return {
      name: 'Vue.js',
    };
  },
  methods: {
    greet(event) {
      // `methods` 内部的 `this` 指向当前活动实例
      alert('Hello ' + this.name + '!');
      // `event` 是原生 DOM event
      if (event) {
        alert(event.target.tagName);
      }
    },
  },
}).mount('#event-with-method');
```

## 内联处理器中的方法

```html
<!-- 除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法： -->
<div id="inline-handler">
  <button @click="say('hi')">Say hi</button>
  <button @click="say('what')">Say what</button>
</div>
```

```js
Vue.createApp({
  methods: {
    say(message) {
      alert(message);
    },
  },
}).mount('#inline-handler');
```

- 在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法

```html
<button @click="warn('Form cannot be submitted yet.', $event)">Submit</button>
```

```js
methods: {
  warn(message, event) {
    // 现在可以访问到原生事件
    if (event) {
      event.preventDefault()
    }
    alert(message)
  }
}
```

## 多事件处理器

```html
<!-- 这两个 one() 和 two() 将执行按钮点击事件 -->
<button @click="one($event), two($event)">Submit</button>
```

```js
methods: {
  one(event) {
    // 第一个事件处理器逻辑...
  },
  two(event) {
   // 第二个事件处理器逻辑...
  }
}
```

## 事件修饰符

```html
<!-- 
  .stop
  .prevent
  .capture
  .self
  .once
  .passive

  使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止元素本身及其子元素的点击的默认行为，而 @click.self.prevent 只会阻止对元素自身的点击的默认行为。
-->

<!-- 阻止单击事件继续冒泡 -->
<a @click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form @submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a @click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form @submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div @click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div @click.self="doThat">...</div>

<!-- 点击事件将只会触发一次 -->
<a @click.once="doThis"></a>

<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发，   -->
<!-- 而不会等待 `onScroll` 完成，                    -->
<!-- 以防止其中包含 `event.preventDefault()` 的情况  -->
<!-- .passive 会告诉浏览器你不想阻止事件的默认行为。 -->
<div @scroll.passive="onScroll">...</div>
```

## 按键修饰符

```html
<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->
<input @keyup.enter="submit" />

<!-- 处理函数只会在 $event.key 等于 'PageDown' 时被调用。 -->
<input @keyup.page-down="onPageDown" />

<!-- 
  Vue 为最常用的键提供了别名：
  .enter
  .tab
  .delete (捕获“删除”和“退格”键)
  .esc
  .space
  .up
  .down
  .left
  .right
 -->
```

## 系统修饰键

```html
<!-- 
  .ctrl
  .alt
  .shift
  .meta
-->

<!-- Alt + Enter -->
<input @keyup.alt.enter="clear" />

<!-- Ctrl + Click -->
<!-- 只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。 -->
<div @click.ctrl="doSomething">Do something</div>
```

## .exact 修饰符

```html
<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
<button @click.ctrl="onClick">A</button>

<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<button @click.ctrl.exact="onCtrlClick">A</button>

<!-- 没有任何系统修饰符被按下的时候才触发 -->
<button @click.exact="onClick">A</button>
```

## 鼠标按钮修饰符

```html
<!-- 
  这些修饰符会限制处理函数仅响应特定的鼠标按钮。
  .left
  .right
  .middle
-->
```
