## 声明响应式状态

```js
// 要为 JavaScript 对象创建响应式状态，可以使用 reactive 方法：
// reactive 相当于 Vue 2.x 中的 Vue.observable() API，为避免与 RxJS 中的 observables 混淆因此对其重命名。该 API 返回一个响应式的对象状态。该响应式转换是“深度转换”——它会影响传递对象的所有嵌套 property。

// Vue 中响应式状态的基本用例是我们可以在渲染期间使用它。因为依赖跟踪的关系，当响应式状态改变时视图会自动更新。

// 这就是 Vue 响应性系统的本质。当从组件中的 data() 返回一个对象时，它在内部交由 reactive() 使其成为响应式对象。模板会被编译成能够使用这些响应式 property 的渲染函数。

import { reactive } from 'vue';

// 响应式状态
const state = reactive({
  count: 0,
});
```

## 创建独立的响应式值作为 refs

```js
// ref 会返回一个可变的响应式对象，该对象作为一个响应式的引用维护着它内部的值，这就是 ref 名称的来源。该对象只包含一个名为 value 的 property：

import { ref } from 'vue';

const count = ref(0);
console.log(count.value); // 0

count.value++;
console.log(count.value); // 1
```

## Ref 解包

```js
// 当 ref 作为渲染上下文 (从 setup() 中返回的对象) 上的 property 返回并可以在模板中被访问时，它将自动浅层次解包内部值。只有访问嵌套的 ref 时需要在模板中添加 .value：
```

```html
<template>
  <div>
    <span>{{ count }}</span>
    <button @click="count ++">Increment count</button>
    <button @click="nested.count.value ++">Nested Increment count</button>
  </div>
</template>

<script>
  import { ref } from 'vue';
  export default {
    setup() {
      const count = ref(0);
      return {
        count,

        nested: {
          count,
        },
      };
    },
  };
</script>

<!-- 
  如果你不想要访问实际的对象实例，可将其用 reactive 包裹:
  nested: reactive({
    count
  })
-->
```

## 访问响应式对象

```js
// 当 ref 作为响应式对象的 property 被访问或更改时，为使其行为类似于普通 property，它会自动解包内部值：
const count = ref(0);
const state = reactive({
  count,
});

console.log(state.count); // 0

state.count = 1;
console.log(count.value); // 1

// 如果将新的 ref 赋值给现有 ref 的 property，将会替换旧的 ref：
const otherCount = ref(2);

state.count = otherCount;
console.log(state.count); // 2
console.log(count.value); // 1

// Ref 解包仅发生在被响应式 Object 嵌套的时候。当从 Array 或原生集合类型如 Map访问 ref 时，不会进行解包：
const books = reactive([ref('Vue 3 Guide')]);
// 这里需要 .value
console.log(books[0].value);

const map = reactive(new Map([['count', ref(0)]]));
// 这里需要 .value
console.log(map.get('count').value);
```

## 响应式状态解构

```js
// 我们需要将我们的响应式对象转换为一组 ref。这些 ref 将保留与源对象的响应式关联：
import { reactive, toRefs } from 'vue';

const book = reactive({
  author: 'Vue Team',
  year: '2020',
  title: 'Vue 3 Guide',
  description: 'You are reading this book right now ;)',
  price: 'free',
});

let { author, title } = toRefs(book);

title.value = 'Vue 3 Detailed Guide'; // 我们需要使用 .value 作为标题，现在是 ref
console.log(book.title); // 'Vue 3 Detailed Guide'
```

## 使用 readonly 防止更改响应式对象

```js
// 时我们想跟踪响应式对象 (ref 或 reactive) 的变化，但我们也希望防止在应用程序的某个位置更改它。例如，当我们有一个被 provide 的响应式对象时，我们不想让它在注入之后被改变。为此，我们可以基于原始对象创建一个只读的 proxy 对象：

import { reactive, readonly } from 'vue';
const original = reactive({ count: 0 });
const copy = readonly(original);
// 通过 original 修改 count，将会触发依赖 copy 的侦听器
original.count++;
// 通过 copy 修改 count，将导致失败并出现警告
copy.count++; // 警告: "Set operation on key 'count' failed: target is readonly."
```
