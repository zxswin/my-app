## Vue 的响应式

```html
<!-- 
  现在是时候深入了！Vue 最独特的特性之一，是其非侵入性的响应性系统。数据模型是被代理的 JavaScript 对象。而当你修改它们时，视图会进行更新。这让状态管理非常简单直观，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。
 -->
```

## Vue 如何知道哪些代码在执行

```js
// 维持一个执行副作用的栈
const runningEffects = [];

const createEffect = (fn) => {
  // 将传来的 fn 包裹在一个副作用函数中
  const effect = () => {
    runningEffects.push(effect);
    fn();
    runningEffects.pop();
  };

  // 立即自动执行副作用
  effect();
};

// 当我们的副作用被调用时，在调用 fn 之前，它会把自己推到 runningEffects 数组中。这个数组可以用来检查当前正在运行的副作用。

// 副作用是许多关键功能的起点。例如，组件的渲染和计算属性都在内部使用副作用。任何时候，只要有东西对数据变化做出奇妙的回应，你就可以肯定它已经被包裹在一个副作用中了。

// 虽然 Vue 的公开 API 不包括任何直接创建副作用的方法，但它确实暴露了一个叫做 watchEffect 的函数，它的行为很像我们例子中的 createEffect 函数。
```

## Vue 如何跟踪变化

```js
// 当我们从一个组件的 data 函数中返回一个普通的 JavaScript 对象时，Vue 会将该对象包裹在一个带有 get 和 set 处理程序的 Proxy 中。Proxy 是在 ES6 中引入的，它使 Vue 3 避免了 Vue 早期版本中存在的一些响应性问题。

// Proxy 是一个对象，它包装了另一个对象，并允许你拦截对该对象的任何交互。

const dinner = {
  meal: 'tacos',
};

const handler = {
  get(target, property) {
    console.log('intercepted!');
    return target[property];
  },
};

const proxy = new Proxy(dinner, handler);
console.log(proxy.meal);

// intercepted!
// tacos

// 使用 Proxy 的一个难点是 this 绑定。我们希望任何方法都绑定到这个 Proxy，而不是目标对象，这样我们也可以拦截它们。值得庆幸的是，ES6 引入了另一个名为 Reflect 的新特性，它允许我们以最小的代价消除了这个问题：

const dinner = {
  meal: 'tacos',
};

const handler = {
  get(target, property, receiver) {
    return Reflect.get(...arguments);
  },
};

const proxy = new Proxy(dinner, handler);
console.log(proxy.meal);

// tacos

// Proxy 实现响应性的第一步就是跟踪一个 property 何时被读取。我们在一个名为 track 的处理器函数中执行此操作，该函数可以传入 target 和 property 两个参数。

const dinner = {
  meal: 'tacos',
};

const handler = {
  get(target, property, receiver) {
    track(target, property);
    return Reflect.get(...arguments);
  },
};

const proxy = new Proxy(dinner, handler);
console.log(proxy.meal);

// tacos

// 最后，我们需要在 property 值更改时重新运行这个副作用。为此，我们需要在代理上使用一个 set 处理函数：
const dinner = {
  meal: 'tacos',
};

const handler = {
  get(target, property, receiver) {
    track(target, property);
    return Reflect.get(...arguments);
  },
  set(target, property, value, receiver) {
    trigger(target, property);
    return Reflect.set(...arguments);
  },
};

const proxy = new Proxy(dinner, handler);
console.log(proxy.meal);

// tacos

// 当一个值被读取时进行追踪：proxy 的 get 处理函数中 track 函数记录了该 property 和当前副作用。
// 当某个值改变时进行检测：在 proxy 上调用 set 处理函数。
// 重新运行代码来读取原始值：trigger 函数查找哪些副作用依赖于该 property 并执行它们。
```

## 完整的案例

```js
const vm = createApp({
  data() {
    return {
      val1: 2,
      val2: 3,
    };
  },
  computed: {
    sum() {
      return this.val1 + this.val2;
    },
  },
}).mount('#app');

console.log(vm.sum); // 5

vm.val1 = 3;

console.log(vm.sum); // 6
```

```js
// data 返回的对象将被包裹在响应式代理中，并存储为 this.$data。Property this.val1 和 this.val2 分别是 this.$data.val1 和 this.$data.val2 的别名，因此它们通过相同的代理。

// Vue 将把 sum 的函数包裹在一个副作用中。当我们试图访问 this.sum 时，它将运行该副作用来计算数值。包裹 $data 的响应式代理将会追踪到，当副作用运行时，property val1 和 val2 被读取了。

// 从 Vue 3 开始，我们的响应性现在可以在一个独立包中使用。将 $data 包裹在一个代理中的函数被称为 reactive。我们可以自己直接调用这个函数，允许我们在不需要使用组件的情况下将一个对象包裹在一个响应式代理中。

const proxy = reactive({
  val1: 2,
  val2: 3,
});
```

## 被代理的对象

```js
// ue 在内部跟踪所有已经被转成响应式的对象，所以它总是为同一个对象返回相同的代理。
// 当从一个响应式代理中访问一个嵌套对象时，该对象在被返回之前也被转换为一个代理：

const handler = {
  get(target, property, receiver) {
    track(target, property);
    const value = Reflect.get(...arguments);
    if (isObject(value)) {
      // 将嵌套对象包裹在自己的响应式代理中
      return reactive(value);
    } else {
      return value;
    }
  },
  // ...
};
```

## Proxy vs 原始标识

```js
// Proxy 的使用确实引入了一个需要注意的新警告：在身份比较方面，被代理对象与原始对象不相等 (===)。例如：
const obj = {};
const wrapped = new Proxy(obj, handlers);

console.log(obj === wrapped); // false

// 其他依赖严格等于比较的操作也会受到影响，例如 .includes() 或 .indexOf()。
// 这里的最佳实践是永远不要持有对原始对象的引用，而只使用响应式版本。

const obj = reactive({
  count: 0,
}); // 未引用原始

// 请注意，Vue 不会在 Proxy 中包裹数字或字符串等原始值，所以你仍然可以对这些值直接使用 === 来比较：

const obj = reactive({
  count: 0,
});

console.log(obj.count === 0); // true
```

## 如何让渲染响应变化

```js
// 一个组件的模板被编译成一个 render 函数。渲染函数创建 VNodes，描述该组件应该如何被渲染。它被包裹在一个副作用中，允许 Vue 在运行时跟踪被“触达”的 property。

// 一个 render 函数在概念上与一个 computed property 非常相似。Vue 并不确切地追踪依赖关系是如何被使用的，它只知道在函数运行的某个时间点上使用了这些依赖关系。如果这些 property 中的任何一个随后发生了变化，它将触发副作用再次运行，重新运行 render 函数以生成新的 VNodes。然后这些举动被用来对 DOM 进行必要的修改。
```
