## Prop 类型

- 以字符串数组形式列出的 prop

```js
// props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
```

- 每个 prop 都有指定的值类型

```js
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // 或任何其他构造函数
}
```

## 传递静态或动态的 Prop

- 给 prop 传入一个静态的值

```html
<blog-post title="My journey with Vue"></blog-post>
```

- prop 可以通过 v-bind 或简写 : 动态赋值

```html
<!-- 动态赋予一个变量的值 -->
<blog-post :title="post.title"></blog-post>

<!-- 动态赋予一个复杂表达式的值 -->
<blog-post :title="post.title + ' by ' + post.author.name"></blog-post>
```

## 传入一个数字

```html
<!-- 即便 `42` 是静态的，我们仍需通过 `v-bind` 来告诉 Vue     -->
<!-- 这是一个 JavaScript 表达式而不是一个字符串。             -->
<blog-post :likes="42"></blog-post>

<!-- 用一个变量进行动态赋值。-->
<blog-post :likes="post.likes"></blog-post>
```

## 传入一个布尔值

```html
<!-- 包含该 prop 没有值的情况在内，都意味着 `true`。  -->
<!-- 如果没有在 props 中把 is-published 的类型设置为 Boolean，
则这里的值为空字符串，而不是“true”。 -->
<blog-post is-published></blog-post>

<!-- 即便 `false` 是静态的，我们仍需通过 `v-bind` 来告诉 Vue  -->
<!-- 这是一个 JavaScript 表达式而不是一个字符串。  -->
<blog-post :is-published="false"></blog-post>

<!-- 用一个变量进行动态赋值。 -->
<blog-post :is-published="post.isPublished"></blog-post>
```

## 传入一个数组

```html
<!-- 即便数组是静态的，我们仍需通过 `v-bind` 来告诉 Vue  -->
<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->
<blog-post :comment-ids="[234, 266, 273]"></blog-post>

<!-- 用一个变量进行动态赋值。 -->
<blog-post :comment-ids="post.commentIds"></blog-post>
```

## 传入一个对象

```html
<!-- 即便对象是静态的，我们仍需通过 `v-bind` 来告诉 Vue -->
<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->
<blog-post
  :author="{
    name: 'Veronica',
    company: 'Veridian Dynamics'
  }"
></blog-post>

<!-- 用一个变量进行动态赋值。-->
<blog-post :author="post.author"></blog-post>
```

## 传入一个对象的所有 property

```js
post: {
  id: 1,
  title: 'My Journey with Vue'
}
```

```html
<!-- 下面的模板： -->
<blog-post v-bind="post"></blog-post>

<!-- 等价于： -->
<blog-post v-bind:id="post.id" v-bind:title="post.title"></blog-post>
```

## 单向数据流

```html
<!-- 
  注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态，且 Vue 无法为此向你发出警告。作为一个通用规则，应该避免修改任何 prop，包括对象和数组，因为这种做法无视了单向数据绑定，且可能会导致意料之外的结果。
-->
```

## Prop 验证

```js
// 注意 prop 会在一个组件实例创建之前进行验证，所以实例的 property (如 data、computed 等) 在 default 或 validator 函数中是不可用的。

app.component('my-component', {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 值会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true,
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100,
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组的默认值必须从一个工厂函数返回
      default() {
        return { message: 'hello' };
      },
    },
    // 自定义验证函数
    propF: {
      validator(value) {
        // 这个值必须与下列字符串中的其中一个相匹配
        return ['success', 'warning', 'danger'].includes(value);
      },
    },
    // 具有默认值的函数
    propG: {
      type: Function,
      // 与对象或数组的默认值不同，这不是一个工厂函数——这是一个用作默认值的函数
      default() {
        return 'Default function';
      },
    },
  },
});
```

## 类型检查

```html
<!-- 
  String
  Number
  Boolean
  Array
  Object
  Date
  Function
  Symbol
-->
```

- type 还可以是一个自定义的构造函数

```js
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

// 来验证 author prop 的值是否是通过 new Person 创建的。
app.component('blog-post', {
  props: {
    author: Person,
  },
});
```

## Prop 的大小写命名 (camelCase vs kebab-case)

```js
const app = Vue.createApp({});

app.component('blog-post', {
  // 在 JavaScript 中使用 camelCase
  props: ['postTitle'],
  template: '<h3>{{ postTitle }}</h3>',
});
```

```html
<!-- 
  HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名

  重申一次，如果你使用字符串模板，那么这个限制就不存在了。
 -->

<!-- 在 HTML 中使用 kebab-case -->
<blog-post post-title="hello!"></blog-post>
```
