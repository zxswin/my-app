## 可以解决的痛点

```js
// 有一些深度嵌套的组件，而深层的子组件只需要父组件的部分内容。在这种情况下，如果仍然将 prop 沿着组件链逐级传递下去，可能会很麻烦。

// 可以使用一对 provide 和 inject。无论组件层次结构有多深，父组件都可以作为其所有子组件的依赖提供者。这个特性有两个部分：父组件有一个 provide 选项来提供数据，子组件有一个 inject 选项来开始使用这些数据。
```

- 假设有一个组件的层级结构是这样子的

```bash
Root
└─ TodoList
   ├─ TodoItem
   └─ TodoListFooter
      ├─ ClearTodosButton
      └─ TodoListStatistics
```

```js
// 要将 todo-items 的长度直接传递给 TodoListStatistics，我们要将 prop 逐级传递下去：TodoList -> TodoListFooter -> TodoListStatistics。
```

- 通过 provide/inject 的解决方案

```js
// 将依赖注入看作是“长距离的 prop”，除了：

// 父组件不需要知道哪些子组件使用了它 provide 的 property
// 子组件不需要知道 inject 的 property 来自哪里

const app = Vue.createApp({});

app.component('todo-list', {
  data() {
    return {
      todos: ['Feed a cat', 'Buy tickets'],
    };
  },
  provide() {
    return {
      todoLength: this.todos.length,
    };
  },
  template: `
    <div>
      {{ todos.length }}
      <!-- 模板的其余部分 -->
    </div>
  `,
});

app.component('todo-list-statistics', {
  inject: ['user'],
  created() {
    console.log(`Injected property: ${this.user}`); // > 注入的 property: John Doe
  },
});
```

## 处理响应性

```js
// 默认情况下，provide/inject 绑定并不是响应式的。
// 可以通过传递一个 ref property 或 reactive 对象给 provide 来改变这种行为。
// 如果我们想对祖先组件中的更改做出响应，我们需要为 provide 的 todoLength 分配一个组合式 API computed property：

app.component('todo-list', {
  // ...
  provide() {
    return {
      todoLength: Vue.computed(() => this.todos.length),
    };
  },
});

app.component('todo-list-statistics', {
  inject: ['todoLength'],
  created() {
    console.log(`Injected property: ${this.todoLength.value}`); // > 注入的 property: 5
  },
});
```
