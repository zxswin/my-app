## 02 vue 基础

```js
// 什么是vue
// 1.构建用户界面
//    用vue往html页面中填充数据，非常的方便
// 2.框架
//   框架是一套现成的解决方案，程序员只能遵守框架的规范，去编写自己的业务功能!
//   要学习vue,就是在学习vue框架中规定的用法!
//   vue的指令、组件(是对UI结构的复用)、 路由、Vuex. vue组件库
//   只有把上面老师罗列的内容掌握以后，才有开发vue项目的能力!

// vue的两个特性
// 1.数据驱动视图:
//   数据的变化会驱动视图自动更新
//   好处:程序员只管把数据维护好，那么页面结构会被vue自动渲染出来!
// 2.双向数据绑定:
//   在网页中，form 表单负责采集数据，Ajax 负责提交数据。
//     js数据的变化，会被自动渲染到页面上
//     页面.上表单采集的数据发生变化的时候，会被vue自动获取到，并更新到js数据中
```

## 什么是 MVVM

```js
// MVVM是vue实现数据驱动视图和双向数据绑定的核心原理。MVVM指的是Model.View和ViewModel,
// 它把每个HTML页面都拆分成了这三个部分:
//   Model表示当前页面渲染时所依赖的数据源。
//   View表示当前页面所渲染的DOM结构。
//   ViewModel表示vue的实例，它是MVVM的核心。

// MVVM的工作原理
// ViewModel作为MVVM的核心，是它把当前页面的数据源(Model) 和页面的结构(View) 连接在了一起。
// 当数据源发生变化时，会被ViewModel监听到，VM会根据最新的数据源自动更新页面的结构
// 当表单元素的值发生变化时，也会被VM监听到，VM会把变化过后最新的值自动同步到Model数据源中
```

## 指令与过滤器

```js
// 1.指令的概念
// 指令(Directives) 是vue为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。

// vue中的指令按照不同的用途可以分为如下6大类:
// ① 内容渲染指令
// ② 属性绑定指令
// ③ 事件绑定指令
// ④ 双向绑定指令
// ⑤ 条件渲染指令
// ⑥ 列表渲染指令
```

## vue 指令

- 内容這染指令

```js
// 1. v-text指令的缺点:会覆盖元索内部原有的内容!
// 2. {{ }}插値表込式:在突隊幵岌中用的最多，只是内容的占位符，不会覆盖原有的内容!
// 3. v-htm1指令的作用:可以把帯有柝笠的字符串，渣染成真正的HTML内容!
```

- 属性绑定指令

```js
// 注意:插值表达式只能用在元索的内容节点中，不能用在元素的属性节点中!
//   ● 在vue中，可以使用v-bind:指令,为元索的属性动态绑定值;
//   ● 简写是英文的:
//   ● 在使用v-bind属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号，例如:
// <div :tit1e="'box' + index">这是一个div</div>
```

- 事件绑定

```js
// 1.v-on;简写是@
// 2.语法格式为:
// <button @c1ick=" add"> </button>

// methods: {
//   add() {
//   //如果在方法中要修改data 中的数据，可以通过this访问到
//   this.count += 1
//   }
// }

// 3. sevent的应用场景:如果默认的事件对象e被覆盖了，则可以手动传递一个$event。 例如:
// <button @c1ick="add(3, $event)"></button>

// methods: {
//   add(n, e) {
//     //如果在方法中要修改data 中的数据，可以通过this访问到
//     this.count += 1
//   }
// }
```

- 事件修饰符

```js
// 在事件处理函数中调用event.preventDefault()或event.stopPropagation()是非常常见的需求。因此,
// vue提供了事件修饰符的概念,来辅助程序员更方便的对事件的触发进行控制。常用的5个事件修饰符如下:
// .prevent 阻止默认行为(例如:阻止a连接的跳转、阻止表单的提交等)
// .stop 阻止事件冒泡
// .capture 以捕获模式触发当前的事件处理函数
// .once 绑定的事件只触发1次
// .self 只有在event.target是当前元素自身时触发事件处理函数

// .prevent
// <a @c1ick. prevent="xxx">链接</a>
// .stop
// <button @c1ick.stop="xxx">按钮</button>
```

- 按键修饰符

```js
// 在监听键盘事件时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符
```

- 双向绑定指令

```js
// vue提供了v-model双向数据绑定指令,用来辅助开发者在不操作DOM的前提下，快速获取表单的数据。

// 1. input输入框
//   type="radio"
//   type="checkbox"
//   type="Xxxx"
// 2. textarea
// 3. select
```

- v-model 指令的修饰符

```js
// 为了方便对用户输入的内容进行处理，vue 为v-model指令提供了3个修饰符，分别是:
// .number 自动将用户的输入值转为数值类型
// <input v-model.number="age" />
// .trim 自动过滤用户输入的首尾空白字符
// <input v-model.trim="msg" />
// .lazy 在"change"时而非"input" 时更新
// <input v-model.lazy="msg" />
```

- 条件渲染指令

```js
// 条件渲染指令用来辅助开发者按需控制DOM的显示与隐藏。条件渲染指令有如下两个，分别是:
// ● v-if
// ● v-show

// 1.v-show的原理是:动态为元素添加或移除display: none 样式，来实现元索的显示和隐藏
// 如果要频繁的切换元索的显示状态，用v-show性能会更好

// 2.v-if的原理是:每次动态创建或移除元素，实现元素的显示和隐藏
// 如果刚进入页面的时候，某些元索默认不需要被展示，而且后期这个元索很可能也不需要被展示出来，此时v-if性能更好

// v-else-if指令，顾名思义，充当v-if的"else-if块"，可以连续使用:
// 注意: v-else-if 指令必须配合v-if指令-起使用，否则它将不会被识别!
```

- 列表渲染指令

```js
// vue提供了v-for列表渲染指令,用来辅助开发者基于-一个数组来循环渲染-个列表结构。v-for 指令需要使
// 用item in items形式的特殊语法,其中:
// ● items 是待循环的数组
// ● item 是被循环的每一项

// key的注意事项
// ① key 的值只能是字符串或数字类型
// ② key 的值必须具有唯一性( 即: key 的值不能重复)
// ③ 建议把数据项id属性的值作为key的值(因为id属性的值具有唯- -性)
// ④ 使用index的值当作key的值没有任何意义( 因为index的值不具有唯一-性 )
// ⑤ 建议使用v-for指令时一定要 指定key的值( 既提升性能、又防止列表状态紊乱)
```

- 过滤器

```js
// 过滤器(ilters) 是vue为开发者提供的功能，常用于文本的格式化。过滤器可以用在两个地方:插值表达式 和v-bind属性绑定。
// 过滤器应该被添加在JavaScript表达式的尾部，由“管道符”进行调用

// 私有过滤器和全局过滤器
// 在filters节点下定义的过滤器，称为“私有过滤器”，因为它只能在当前vm实例所控制的el区域内使用。
// 如果希望在多个vue实例之间共享过滤器,则可以按照如下的格式定义全局过滤器:

// 连续调用多个过滤器
// 过滤器可以串联地进行调用

// 过滤器的本质是JavaScript函数，因此可以接收参数，格式如下:
// <!-- arg1和arg2 是传递给filterA的参数
// <p>{{ message| filterA(arg1, arg2) }}</p>
//过滤器处理函数的形参列表中:
// 第一个参数:永远都是”管道符”前面待处理的值
// 从第二个参数开始，才是调用过滤器时传递过来的arg1 和arg2 参数
Vue.filter('filterA, (msg, arg1, arg2) => {
//过滤器的代码逻辑...
})

// 过滤器的注意点
// 1.要定义到filters节点下，本质是-个函数
// 2.在过滤器函数中，-定要有return值
// 3.在过滤器的形参中，可以获取到管道符"前面待处理的那个值
// 4.如果全局过滤器和私有过滤器名字一致， 此时按照“就近原则"，调用的是“私有过滤器”

```

## watch 侦听器

```js
// 1.什么是watch侦听器
// watch侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作。
const vm = new Vue({
  el: '#app',
  data: { username: '' },
  watch: {
    // 监听usernam值的变化
    // newVal 是"变化后的新值",oldVal 是变化后的旧值
    username(newVal, oldVal) {
      console.log(newVal, oldVal);
    },
  },
});

// 侦听器的格式
// 1.方法格式的侦听器
//   缺点: 无法在刚进入页面的时候，自动触发! ! !
//   缺点2: 如果侦听的是一个对象， 如果对象中的属性发生了变化，不会触发侦听器! !
// 2.对象格式的侦听器
//   好处: 可以通过immediate选项，让侦听器自动触发! ! !
//   好处: 可以通过deep选项，让侦听器深度监听对象中每个属性的变化! ! !
```

## 什么是计算属性

```js
// 什么是计算属性
// 计算属性指的是通过一系列运算之后,最终得到一一个属性值。
// 这个动态计算出来的属性值可以被模板结构或methods方法使用

// 特点:
// 1.定义的时候，要被定义为“方法”
// 2.在使用计算属性的时候，当普通的属性使用即可
// 好处:
// 1.实现了代码的复用
// 2.只要计算属性中依赖的数据源变化了,则计算属性会自动重新求值!
```

## axios 的基本使用

```js
// axios是一个专注于网络请求的库!
// 发起GET请求
// 发起POST请求
```

## vue2 和 vue3 的区别

```js
// 过滤器仅在vue 2.x和1.x中受支持,在vue 3.x的版本中剔除了过滤器相关的功能。
```
