## 测试 Mutation

```js
// mutations.js
export const mutations = {
  increment: (state) => state.count++,
};
```

```js
// mutations.spec.js
import { expect } from 'chai';
import { mutations } from './store';

// 解构 `mutations`
const { increment } = mutations;

describe('mutations', () => {
  it('INCREMENT', () => {
    // 模拟状态
    const state = { count: 0 };
    // 应用 mutation
    increment(state);
    // 断言结果
    expect(state.count).to.equal(1);
  });
});
```

## 测试 Action

```js
// Action 应对起来略微棘手，因为它们可能需要调用外部的 API。当测试 action 的时候，我们需要增加一个 mocking 服务层——例如，我们可以把 API 调用抽象成服务，然后在测试文件中用 mock 服务回应 API 调用。为了便于解决 mock 依赖，可以用 webpack 和 inject-loader 打包测试文件。

// actions.js
import shop from '../api/shop';

export const getAllProducts = ({ commit }) => {
  commit('REQUEST_PRODUCTS');
  shop.getProducts((products) => {
    commit('RECEIVE_PRODUCTS', products);
  });
};
```

```js
// actions.spec.js

// 使用 require 语法处理内联 loaders。
// inject-loader 返回一个允许我们注入 mock 依赖的模块工厂
import { expect } from 'chai';
const actionsInjector = require('inject-loader!./actions');

// 使用 mocks 创建模块
const actions = actionsInjector({
  '../api/shop': {
    getProducts(cb) {
      setTimeout(() => {
        cb([
          /* mocked response */
        ]);
      }, 100);
    },
  },
});

// 用指定的 mutations 测试 action 的辅助函数
const testAction = (action, args, state, expectedMutations, done) => {
  let count = 0;

  // 模拟提交
  const commit = (type, payload) => {
    const mutation = expectedMutations[count];

    try {
      expect(mutation.type).to.equal(type);
      expect(mutation.payload).to.deep.equal(payload);
    } catch (error) {
      done(error);
    }

    count++;
    if (count >= expectedMutations.length) {
      done();
    }
  };

  // 用模拟的 store 和参数调用 action
  action({ commit, state }, ...args);

  // 检查是否没有 mutation 被 dispatch
  if (expectedMutations.length === 0) {
    expect(count).to.equal(0);
    done();
  }
};

describe('actions', () => {
  it('getAllProducts', (done) => {
    testAction(
      actions.getAllProducts,
      null,
      {},
      [
        { type: 'REQUEST_PRODUCTS' },
        {
          type: 'RECEIVE_PRODUCTS',
          payload: {
            /* mocked response */
          },
        },
      ],
      done
    );
  });
});
```

```js
// 如果在测试环境下有可用的 spy (比如通过 Sinon.JS)，你可以使用它们替换辅助函数 testAction：
describe('actions', () => {
  it('getAllProducts', () => {
    const commit = sinon.spy();
    const state = {};

    actions.getAllProducts({ commit, state });

    expect(commit.args).to.deep.equal([
      ['REQUEST_PRODUCTS'],
      [
        'RECEIVE_PRODUCTS',
        {
          /* mocked response */
        },
      ],
    ]);
  });
});
```

## 测试 Getter

```js
// getters.js
export const getters = {
  filteredProducts(state, { filterCategory }) {
    return state.products.filter((product) => {
      return product.category === filterCategory;
    });
  },
};
```

```js
// getters.spec.js
import { expect } from 'chai';
import { getters } from './getters';

describe('getters', () => {
  it('filteredProducts', () => {
    // 模拟状态
    const state = {
      products: [
        { id: 1, title: 'Apple', category: 'fruit' },
        { id: 2, title: 'Orange', category: 'fruit' },
        { id: 3, title: 'Carrot', category: 'vegetable' },
      ],
    };
    // 模拟 getter
    const filterCategory = 'fruit';

    // 获取 getter 的结果
    const result = getters.filteredProducts(state, { filterCategory });

    // 断言结果
    expect(result).to.deep.equal([
      { id: 1, title: 'Apple', category: 'fruit' },
      { id: 2, title: 'Orange', category: 'fruit' },
    ]);
  });
});
```

## 执行测试

- 在 Node 中执行测试

```js
// webpack.config.js
module.exports = {
  entry: './test.js',
  output: {
    path: __dirname,
    filename: 'test-bundle.js',
  },
  module: {
    loaders: [
      {
        test: /\.js$/,
        loader: 'babel-loader',
        exclude: /node_modules/,
      },
    ],
  },
};
// 然后：

// webpack
// mocha test-bundle.js
```

- 在浏览器中测试

```js
// 安装 mocha-loader。
// 把上述 webpack 配置中的 entry 改成 'mocha-loader!babel-loader!./test.js'。
// 用以上配置启动 webpack-dev-server。
// 访问 localhost:8080/webpack-dev-server/test-bundle。
```

## 热重载

```js
// 使用 webpack 的 Hot Module Replacement API，Vuex 支持在开发过程中热重载 mutation、module、action 和 getter。
```

```js
// 对于 mutation 和模块，你需要使用 store.hotUpdate() 方法：
// store.js
import { createStore } from 'vuex'
import mutations from './mutations'
import moduleA from './modules/a'

const state = { ... }

const store = createStore({
  state,
  mutations,
  modules: {
    a: moduleA
  }
})

if (module.hot) {
  // 使 action 和 mutation 成为可热重载模块
  module.hot.accept(['./mutations', './modules/a'], () => {
    // 获取更新后的模块
    // 因为 babel 6 的模块编译格式问题，这里需要加上 `.default`
    const newMutations = require('./mutations').default
    const newModuleA = require('./modules/a').default
    // 加载新模块
    store.hotUpdate({
      mutations: newMutations,
      modules: {
        a: newModuleA
      }
    })
  })
}
```

## 动态模块热重载

```js
// 如果你仅使用模块，你可以使用 require.context 来动态地加载或热重载所有的模块。

// store.js
import { createStore } from 'vuex';

// 加载所有模块。
function loadModules() {
  const context = require.context('./modules', false, /([a-z_]+)\.js$/i);

  const modules = context
    .keys()
    .map((key) => ({ key, name: key.match(/([a-z_]+)\.js$/i)[1] }))
    .reduce(
      (modules, { key, name }) => ({
        ...modules,
        [name]: context(key).default,
      }),
      {}
    );

  return { context, modules };
}

const { context, modules } = loadModules();

const store = new createStore({
  modules,
});

if (module.hot) {
  // 在任何模块发生改变时进行热重载。
  module.hot.accept(context.id, () => {
    const { modules } = loadModules();

    store.hotUpdate({
      modules,
    });
  });
}
```
