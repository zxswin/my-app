## 插槽简单例子

```html
<navigation-link url="/profile"> Your Profile </navigation-link>

<!-- <navigation-link> 的模板中可能会写为： -->
<!-- <slot></slot> 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML： -->
<a v-bind:href="url" class="nav-link">
  <slot></slot>
</a>

<!-- 
  如果 <navigation-link> 的 template 中没有包含一个 <slot> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。
 -->
```

## 编译作用域

```html
<!-- 
  插槽跟模板的其它地方一样可以访问相同的实例 property (也就是相同的“作用域”)，而不能访问 <navigation-link> 的作用域。例如 url 是访问不到的：
  父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。
 -->
<navigation-link url="/profile"> Logged in as {{ user.name }} </navigation-link>
```

## 后备内容

```html
<!-- 
  将“Submit”作为后备内容，我们可以将它放在 <slot> 标签内：
  现在当我在一个父级组件中使用 <submit-button> 并且不提供任何插槽内容时：
  后备内容“Submit”将会被渲染：
 -->
<button type="submit">
  <slot>Submit</slot>
</button>
```

## 具名插槽

```html
<!-- 
  一个不带 name 的 <slot> 出口会带有隐含的名字“default”。
 -->

<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>

<!-- 
  在向具名插槽提供内容的时候，我们可以在一个 <template> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：
-->

<base-layout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <template v-slot:footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>

<!-- 
  果你希望更明确一些，仍然可以在一个 <template> 中包裹默认插槽的内容：
-->
<base-layout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <template v-slot:default>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </template>

  <template v-slot:footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
```

## 作用域插槽

```html
<!-- 
  让插槽内容能够访问子组件中才有的数据是很有用的
 -->

<!-- 子组件中 -->
<span>
  <slot v-bind:user="user"> {{ user.lastName }} </slot>
</span>

<!-- 父组件中 -->
<current-user>
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>
</current-user>
```

## 独占默认插槽的缩写语法

```html
<!-- 原始写法 -->
<current-user v-slot:default="slotProps">
  {{ slotProps.user.firstName }}
</current-user>

<!-- 不带参数的 v-slot 被假定对应默认插槽： -->
<current-user v-slot="slotProps"> {{ slotProps.user.firstName }} </current-user>

<!-- 注意默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确： -->
<!-- 无效，会导致警告 -->
<current-user v-slot="slotProps">
  {{ slotProps.user.firstName }}
  <template v-slot:other="otherSlotProps">
    slotProps is NOT available here
  </template>
</current-user>

<!-- 只要出现多个插槽，请始终为所有的插槽使用完整的基于 <template> 的语法： -->
<current-user>
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>

  <template v-slot:other="otherSlotProps"> ... </template>
</current-user>
```

## 解构插槽 Prop

```html
<current-user v-slot="{ user }"> {{ user.firstName }} </current-user>

<!-- 将 user 重命名为 person： -->
<current-user v-slot="{ user: person }"> {{ person.firstName }} </current-user>

<!-- 可以定义后备内容，用于插槽 prop 是 undefined 的情形： -->

<current-user v-slot="{ user = { firstName: 'Guest' } }">
  {{ user.firstName }}
</current-user>
```

## 动态插槽名

```html
<base-layout>
  <template v-slot:[dynamicSlotName]> ... </template>
</base-layout>
```

## 具名插槽的缩写

```html
<!-- 即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header -->
<base-layout>
  <template #header>
    <h1>Here might be a page title</h1>
  </template>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <template #footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>

<!-- 和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的： -->
<!-- 这样会触发一个警告 -->
<current-user #="{ user }"> {{ user.firstName }} </current-user>

<!-- 如果你希望使用缩写的话，你必须始终以明确插槽名取而代之： -->
<current-user #default="{ user }"> {{ user.firstName }} </current-user>
```

## 其它示例

```html
<!-- 我们可以将每个 todo 作为父级组件的插槽，以此通过父级组件对其进行控制，然后将 todo 作为一个插槽 prop 进行绑定： -->

<ul>
  <li v-for="todo in filteredTodos" v-bind:key="todo.id">
    <!--
    我们为每个 todo 准备了一个插槽，
    将 `todo` 对象作为一个插槽的 prop 传入。
    -->
    <slot name="todo" v-bind:todo="todo">
      <!-- 后备内容 -->
      {{ todo.text }}
    </slot>
  </li>
</ul>
<!-- 现在当我们使用 <todo-list> 组件的时候，我们可以选择为 todo 定义一个不一样的 <template> 作为替代方案，并且可以从子组件获取数据： -->

<todo-list v-bind:todos="todos">
  <template v-slot:todo="{ todo }">
    <span v-if="todo.isComplete">✓</span>
    {{ todo.text }}
  </template>
</todo-list>
```
