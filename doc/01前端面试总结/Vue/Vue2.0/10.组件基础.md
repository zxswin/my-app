## 一个简单的组件例子

- 定义一个组件

```js
// 定义一个名为 button-counter 的新组件
// 过 Vue.component 全局注册的
Vue.component('button-counter', {
  // 一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：
  // 如果 Vue 没有这条规则，则实例之间的数据会相互影响
  data: function () {
    return {
      count: 0,
    };
  },
  template:
    '<button v-on:click="count++">You clicked me {{ count }} times.</button>',
});
```

- 组件的使用

```html
<!-- 
  因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项
 -->
<div id="components-demo">
  <button-counter></button-counter>
</div>
```

```js
new Vue({ el: '#components-demo' });
```

## 组件的复用

```js
<div id="components-demo">
  <button-counter></button-counter>
  <button-counter></button-counter>
  <button-counter></button-counter>
</div>
```

## 通过 Prop 向子组件传递数据

```js
Vue.component('blog-post', {
  props: ['title'],
  template: '<h3>{{ title }}</h3>',
});
```

```html
<blog-post title="My journey with Vue"></blog-post>
<blog-post title="Blogging with Vue"></blog-post>
<blog-post title="Why Vue is so fun"></blog-post>
```

- 一个动态渲染的问题

```js
new Vue({
  el: '#blog-post-demo',
  data: {
    posts: [
      { id: 1, title: 'My journey with Vue' },
      { id: 2, title: 'Blogging with Vue' },
      { id: 3, title: 'Why Vue is so fun' },
    ],
  },
});
```

```html
<blog-post
  v-for="post in posts"
  v-bind:key="post.id"
  v-bind:title="post.title"
></blog-post>
```

## 单个根元素

```js
Vue.component('blog-post', {
  props: ['post'],
  template: `
    <div class="blog-post">
      <h3>{{ post.title }}</h3>
      <div v-html="post.content"></div>
    </div>
  `,
});
```

```html
<blog-post
  v-for="post in posts"
  v-bind:key="post.id"
  v-bind:post="post"
></blog-post>
```

## 监听子组件事件

```js
// 子组件可以通过调用内建的 $emit 方法并传入事件名称来触发一个事件：
Vue.component('blog-post', {
  props: ['post'],
  template: `
    <div class="blog-post">
      <h3>{{ post.title }}</h3>
      <button v-on:click="$emit('enlarge-text')">
        Enlarge text
      </button>
      <div v-html="post.content"></div>
    </div>
  `,
});
```

```html
<!-- 父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件： -->
<blog-posts
  v-on:enlarge-text="postFontSize += 0.1"
></blog-post>
```

- 使用事件抛出一个值(参数的传递)

```html
<!-- 在子组件中 -->
<button v-on:click="$emit('enlarge-text', 0.1)">Enlarge text</button>
```

```html
<!-- 在父组件中 -->
<blog-post v-on:enlarge-text="onEnlargeText"></blog-post>
```

```js
methods: {
  onEnlargeText: function (enlargeAmount) {
    this.postFontSize += enlargeAmount
  }
}
```

## 在组件上使用 v-model

- 普通控件的 v-model

```html
<input v-model="searchText" />

<!-- 等价于： -->

<input
  v-bind:value="searchText"
  v-on:input="searchText = $event.target.value"
/>
```

- 自定义组件的 v-model

```html
<!-- 自定义事件也可以用于创建支持 v-model 的自定义输入组件。 -->
Vue.component('custom-input', { props: ['value'], template: `
<input v-bind:value="value" v-on:input="$emit('input', $event.target.value)" />
` })

<!-- 使用 -->
<custom-input v-model="searchText"></custom-input>
```

## 通过插槽分发内容

```html
Vue.component('alert-box', { template: `
<div class="demo-alert-box">
  <strong>Error!</strong>
  <slot></slot>
</div>
` })
```

```js
<alert-box>Something bad happened.</alert-box>
```

## 动态组件

```html
<!-- 在不同组件之间进行动态切换 -->
<!-- 组件会在 `currentTabComponent` 改变时改变 -->

<!-- 
  currentTabComponent 可以包括
  已注册组件的名字，或
  一个组件的选项对象
-->
<component v-bind:is="currentTabComponent"></component>
```

## 解析 DOM 模板时的注意事项

```html
<table>
  <blog-post-row></blog-post-row>
</table>
<!-- 
  这个自定义组件 <blog-post-row> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。
  幸好这个特殊的 is attribute 给了我们一个变通的办法：
 -->

<table>
  <tr is="blog-post-row"></tr>
</table>

<!-- 
  需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的：
  字符串 (例如：template: '...')
  单文件组件 (.vue)
  <script type="text/x-template"> 
-->
```
