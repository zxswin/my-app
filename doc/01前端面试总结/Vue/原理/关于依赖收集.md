## 关于依赖收集

- 总结

```ts
/**
 * 依赖收集：通过自然地使用变量，来完成依赖的收集，
 * 当变量改变时，根据收集的依赖判断是否需要触发回调。
 *
 *
 * 采用Proxy/Object.defineProperty将数据对象转变成可观察的观察目标；
 * 观察者通过函数表达其属性与观察目标属性间的关系，并可给定一个回调函数处理关系结果；
 * 通过依赖收集器完成观察对象与观察者的连接；
 * 观察目标属性的任何变更都将自动告知观察者并触发相应回调函数
 */
```

## 一个简单的依赖收集的实现(基于 Object.defineProperty)

```ts
class Dep {
  constructor() {
    this.deps = new Set();
  }

  depend() {
    if (Dep.target) {
      this.deps.add(Dep.target);
    }
  }

  notify() {
    this.deps.forEach((dep) => {
      dep();
    });
  }
}

Dep.target = null;

class Observable {
  constructor(obj) {
    return this.walk(obj);
  }

  walk(obj) {
    const keys = Object.keys(obj);
    keys.forEach((key) => {
      this.defineReactive(obj, key, obj[key]);
    });
    return obj;
  }

  defineReactive(obj, key, val) {
    const dep = new Dep();
    if (Array.isArray(obj[key])) {
      // Array添加push的钩子
      Object.defineProperty(obj[key], 'push', {
        value() {
          this[this.length] = arguments[0];
          dep.notify();
        },
      });
      Object.defineProperty(obj, key, {
        get() {
          dep.depend();
          return val;
        },
      });
    } else {
      Object.defineProperty(obj, key, {
        get() {
          dep.depend();
          return val;
        },
        set(newVal) {
          val = newVal;
          dep.notify();
        },
      });
    }
  }
}

class Watcher {
  constructor(obj, key, cb, onComputedUpdate) {
    this.obj = obj;
    this.key = key;
    this.cb = cb;
    this.onComputedUpdate = onComputedUpdate;
    return this.defineComputed();
  }

  defineComputed() {
    const self = this;
    const onDepUpdated = () => {
      const val = self.cb();
      this.onComputedUpdate(val);
    };

    Object.defineProperty(self.obj, self.key, {
      get() {
        Dep.target = onDepUpdated;
        const val = self.cb();
        Dep.target = null;
        return val;
      },
      set() {
        console.error('计算属性无法被赋值！');
      },
    });
  }
}

const hero = new Observable({
  name: '赵云',
  hp: 3000,
  sp: 150,
  equipment: ['马', '矛'],
});

new Watcher(
  hero,
  'health',
  () => {
    return hero.hp > 2000 ? '强壮' : '良好';
  },
  (val) => {
    console.log(`英雄的健康状况是：${val}`);
  }
);

new Watcher(
  hero,
  'job',
  () => {
    return hero.sp < 3000 ? '武将' : '谋士';
  },
  (val) => {
    console.log(`英雄的职业是：${val}`);
  }
);

new Watcher(
  hero,
  'weapon',
  () => {
    return hero.equipment;
  },
  (val) => {
    console.log(`英雄的武器是：${val}`);
  }
);

console.log(`英雄初始健康状况：${hero.health}`);
// -> 英雄初始健康状况：强壮

console.log(`英雄初始职业：${hero.job}`);
// -> 英雄初始职业：武将

console.log(`英雄初始武器：${hero.weapon}`);
// -> 英雄初始武器：马,矛

hero.name = '诸葛亮';
console.log(`英雄的名字是：${hero.name}`);
// -> 英雄的名字是：诸葛亮

hero.hp = 1000;
// -> 英雄的健康状况是：良好

hero.sp = 4000;
// -> 英雄的职业是：谋士

hero.equipment.push('羽扇');
// -> 英雄的武器是：马,矛,羽扇
```

## 一个简单的依赖收集的实现(基于 Proxy 实现方式)

```ts
class Observable {
  constructor(obj) {
    return this._createProxy(obj);
  }

  _createProxy(obj) {
    const dep = new Dep();
    const handler = {
      get(target, key, receiver) {
        // console.log(`我的${key}属性被读取了！`);
        // 加入观察者队列
        dep.depend(key);
        return Reflect.get(target, key, receiver);
      },
      set(target, key, value, receiver) {
        console.log(`我的${key}属性被修改为${value}了！`);
        //内部调用对应的 Reflect 方法
        const result = Reflect.set(target, key, value, receiver);
        //执行观察者队列
        dep.notify(key);
        return result;
      },
    };
    return new Proxy(obj, handler);
  }
}

class Watcher {
  constructor(obj, key, callback, onComputedUpdate) {
    this.obj = obj;
    this.key = key;
    this.callback = callback;
    this.onComputedUpdate = onComputedUpdate;
    return this._defineComputed();
  }

  _defineComputed() {
    const self = this;
    const onDepUpdated = () => {
      const val = self.callback();
      this.onComputedUpdate(val);
    };

    const handler = {
      get(target, key, receiver) {
        console.log(`我的${key}属性被读取了！`);
        Dep.target = onDepUpdated;
        const val = self.callback();
        Dep.target = null;
        return val;
      },
      set() {
        console.error('计算属性无法被赋值！');
      },
    };
    return new Proxy(this.obj, handler);
  }
}

class Dep {
  constructor() {
    this.deps = new Set();
  }

  depend(key) {
    if (Dep.target) {
      this.deps.add({
        key,
        target: Dep.target,
      });
    }
  }

  notify(key) {
    this.deps.forEach((dep) => {
      if (dep.key === key) {
        dep.target();
      }
    });
  }
}

Dep.target = null;
```

## 异步优化方案

```ts
/**
 * 当连续对观察目标的同一个属性进行操作时，会多次执行回调函数，
 * 在实际使用中会造成性能损耗或重复刷新页面等问题。
 */
const autoRun = function (handler) {
  handler();
};

class Dep {
  constructor() {
    this.deps = new Set();
  }

  depend(key) {
    if (Dep.target) {
      this.deps.add({
        key,
        target: Dep.target,
      });
    }
  }

  async notify(key) {
    this.deps.forEach((dep) => {
      if (dep.key === key && dep.target) {
        dep.target();
      }
    });
    await Dep.computeArray.clear(); // 微任务执行清空Set操作
  }
}

Dep.target = null;
Dep.computeArray = new Set();

class Observable {
  constructor(obj) {
    return this._createProxy(obj);
  }

  _createProxy(obj) {
    const dep = new Dep();
    const handler = {
      get(target, key, receiver) {
        // console.log(`我的${key}属性被读取了！`);
        // 加入观察者队列
        dep.depend(key);
        return Reflect.get(target, key, receiver);
      },
      set(target, key, value, receiver) {
        console.log(`我的${key}属性被修改为${value}了！`);
        //内部调用对应的 Reflect 方法
        const result = Reflect.set(target, key, value, receiver);
        //执行观察者队列
        dep.notify(key);
        return result;
      },
    };
    return new Proxy(obj, handler);
  }
}

class Watcher {
  constructor(obj, key, callback, onComputedUpdate) {
    this.obj = obj;
    this.key = key;
    this.callback = callback;
    this.onComputedUpdate = onComputedUpdate;
    this.idx = 0;
    return this._defineComputed();
  }

  _defineComputed() {
    const self = this;
    const onDepUpdated = async (key) => {
      await console.log('wait');
      // 判断是否已执行过相同回调函数
      if (!Dep.computeArray.has(key)) {
        Dep.computeArray.add(key);
        const val = self.callback();
        this.onComputedUpdate(val);
      }
    };

    const handler = {
      get(target, key, receiver) {
        console.log(`我的${key}属性被读取了！`);
        Dep.target = () => {
          onDepUpdated(key);
        };
        const val = self.callback();
        Dep.target = null;
        return val;
      },
      set() {
        console.error('计算属性无法被赋值！');
      },
    };

    return new Proxy(this.obj, handler);
  }
}
```

## 单词

```pug
equipment 装备
```
