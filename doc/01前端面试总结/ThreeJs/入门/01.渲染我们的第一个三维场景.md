## 渲染我们的第一个三维场景

```html
<div id="webgl-box"></div>
```

```js
// 导入 three.js 包
import * as THREE from 'three';

// 定义场景
const scene = new THREE.Scene();
// 定义摄像机
const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
// 定义渲染器
const renderer = new THREE.WebGLRenderer();
// 定义场景的颜色为黑色
renderer.setClearColor(0x000000);
// 定义场景大小为整个窗口
renderer.setSize(window.innerWidth, window.innerHeight);

// 创建一个粗细为20的坐标轴
const axes = new THREE.AxesHelper(20);
scene.add(axes);

// 创建一个宽为60，高为20的的平面。
const planeGeometry = new THREE.PlaneGeometry(60, 20);
// 设置平面的材质
const planeMaterial = new THREE.MeshBasicMaterial({
  color: 0xaaaaaa,
});
// 赋值到Mesh
const plane = new THREE.Mesh(planeGeometry, planeMaterial);
// 设置平面位置和旋转
plane.rotation.x = -0.5 * Math.PI;
plane.position.set(15, 0, 0);
// 将平面添加到场景中
scene.add(plane);

const cubeGeometry = new THREE.BoxGeometry(4, 4, 4);
const cubeMaterial = new THREE.MeshBasicMaterial({
  color: 0xff0000,
  wireframe: true, // 物体将不会被渲染为实体
});
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
cube.position.set(-4, 3, 0);
scene.add(cube);

const sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
const sphereMaterial = new THREE.MeshBasicMaterial({
  color: 0x7777ff,
  wireframe: true,
});
const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
sphere.position.set(20, 4, 2);
scene.add(sphere);

// 设置摄像机的位置
camera.position.set(-30, 40, 30);
// 摄像机指向场景中心
camera.lookAt(scene.position);
// 将渲染的结果加入到div中
document.querySelector('#webgl-box').appendChild(renderer.domElement);

renderer.render(scene, camera);
```

## 代码解析

- code1

```js
// 在代码中，我们定义了场景、摄像机、渲染器。

// 场景（scene）：是一个容器，用于保存、跟踪所需要渲染的物体和使用的光源，场景是渲染物体的基础。
// 摄像机（camera）：摄像机能够决定我们看什么。
// 渲染器（renderer）：渲染器会根据摄像机的角度来计算场景在浏览器中渲染成什么样子，最后使用电脑显卡来渲染场景。

// 定义场景
const scene = new THREE.Scene();
// 定义摄像机
const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
// 定义渲染器
const renderer = new THREE.WebGLRenderer();
// 定义场景的颜色为黑色
renderer.setClearColor(0x000000);
// 定义场景大小为整个窗口
renderer.setSize(window.innerWidth, window.innerHeight);
```

- code2:

```js
// AxesHelper 用于创建坐标轴，坐标轴十分有用，可以在我们开发中用作参考，不会两眼一抹黑全靠感觉做。

// 创建一个粗细为20的坐标轴
const axes = new THREE.AxesHelper(20);
scene.add(axes);
```

- code3:

```js
// 我们一般使用PlaneGeometry来创建平面，创建一个平面需要两步：首先使用 PlaneGeometry 传参 来定义平面的大小，然后通过材质类 MeshBasicMaterial来定义平面的样式，在这里我们定义了它的颜色。然后将它们组合到Mesh中并赋值给平面向量，并为它设置位置和旋转角度。最后将平面添加到场景中。

// 创建一个宽为60，高为20的的平面。
const planeGeometry = new THREE.PlaneGeometry(60, 20);
// 设置平面的材质
const planeMaterial = new THREE.MeshBasicMaterial({
  color: 0xaaaaaa,
});
// 赋值到Mesh
const plane = new THREE.Mesh(planeGeometry, planeMaterial);
// 设置平面位置和旋转
plane.rotation.x = -0.5 * Math.PI;
plane.position.set(15, 0, 0);
// 将平面添加到场景中
scene.add(plane);
```

- code4:

```js
const cubeGeometry = new THREE.BoxGeometry(4, 4, 4);
const cubeMaterial = new THREE.MeshBasicMaterial({
  color: 0xff0000,
  wireframe: true, // 物体将不会被渲染为实体
});
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
cube.position.set(-4, 3, 0);
scene.add(cube);
```

- code5:

```js
// camera.position.set 使用 x, y, z位置属性来设置摄像机的位置。
// 使用lookAt将摄像机指向场景中心，默认状态下，摄像机指向(0, 0, 0)。
// 最后将渲染结果加入到dom中。

// 用同样的方式，把方块和球体都添加到场景中。

// 设置摄像机的位置
camera.position.set(-30, 40, 30);
// 摄像机指向场景中心
camera.lookAt(scene.position);
// 将渲染的结果加入到div中
document.querySelector('#webgl-box').appendChild(renderer.domElement);

renderer.render(scene, camera);
```
