# ThreeJs 中的材质

## 1. 材质简介与说明

```js
// 经过前边的学习，我们了解到，材质 + Geometry = Mesh。

// 材质就像物体的皮肤，决定了几何体的外表。例如，材质可以定义一个几何体看起来像金属还是木板，是否透明，什么颜色等，然后添加到Mesh中才可以添加到场景中进行渲染。本章，将会带领大家熟悉Three.js中API提供的所有材质，你也会学会运用这些材质，制作精美的三维物体。
```

```js
// MeshBasicMaterial（基础材质）	基础材质，可显示几何体线框，可赋予简单的颜色
// MeshDepthMaterial（网格深度材质）	一种按深度绘制几何体的材质。深度基于相机远近平面。白色最近，黑色最远。
// MeshNormalMaterial（网格法向材质）	一种把法向量映射到RGB颜色的材质。
// MeshLambertMaterial（网格Lambert材质）	一种非光泽表面的材质，没有镜面高光。用于创建暗淡的、不光亮的物体。
// MeshPhongMaterial（网格Phong材质）	一种用于具有镜面高光的光泽表面的材质。
// MeshStandardMaterial（网格标准材质）	一种基于物理的标准材质，使用Metallic-Roughness工作流程。它可以计算表面与光线的正确互动关系，从而使渲染出来的物体更加真实。
// MeshPhysicalMaterial（网格物体材质）	MeshStandardMaterial的扩展，能够更好地控制反射率。
// MeshToonMaterial（网格卡通材质）	MeshPhongMaterial卡通着色的扩展。
// ShadowMaterial（阴影材质）	此材质可以接收阴影，但在其他方面完全透明。
// ShaderMaterial（着色器材质）	允许使用自定义着色器材质，直接控制顶点的放置方式和像素的着色方式。
// LineBasicMaterial（直线基础材质）	一种用于绘制线框样式几何体的材质。可用THREE.Line几何体，创建着色的直线。
// LineDashedMaterial（虚线材质）	一种用于绘制虚线样式几何体的材质。
```

```js
// 材质的基类为 THREE.Material，它内部定义材质的共有属性，这些属性如果归类的话，可以分为三类：

// 基础属性：控制物体不透明度、是否可用、自定义名称或者ID等
// 融合属性：物体如何与背景融合
// 高级属性：控制底层WEBGL上下文对象渲染物体的方式，大多数情况我们不会使用这些属性。
```

## 材质的基础属性

```js
// id	标识符
// uuid	唯一通用识别码
// name	自定义材质名称
// opacity（不透明度）	在0.0 - 1.0的范围内的浮点数，表明材质的透明度。值0.0表示完全透明，1.0表示完全不透明。
// 如果材质的transparent属性未设置为true，则材质将保持完全不透明，此值仅影响其颜色。 默认值为1.0。
// transparent（是否透明）	定义此材质是否透明。这对渲染有影响，因为透明对象需要特殊处理，并在非透明对象之后渲染。
// 设置为true时，通过设置材质的opacity属性来控制材质透明的程度。默认值为false。
// overdraw（过度描绘）	当使用THREE.CanvasRender时，多边形会被渲染的稍微大些，当使用这个渲染器渲染的物体有间隙时，可以设置为true。
// visible（是否可见）	此材质是否可见。默认为true。
// side（侧面）	定义将要渲染哪一面 - 正面，背面或两者。 默认为THREE.FrontSide。其他选项有THREE.BackSide和THREE.DoubleSide。
// needsUpdate（是否更新）	指定需要重新编译材质。
// 实例化新材质时，此属性自动设置为true。
// colorWrite（是否输出颜色）	为false时，具有该材质的物体不会被真正绘制到场景。该物体不可见，其它物体被遮挡的部分也不可见。
// flatShading（平面着色）	定义材质是否使用平面着色进行渲染。默认值为false。
// lights（光照）	材质是否受到光照的影响。默认为true。
// premultipliedAlpha（预计算Alpha混合）	是否预乘alpha（透明度）值，默认false
// dithering（抖动）	是否启用颜色抖动模式。该模式可以一定程度减少颜色不均匀问题，默认false
// shadowSide（投影面）	定义投影的面。设置时，可以是THREE.FrontSide, THREE.BackSide, 或Materials。默认值为 null。
// 如果为null， 则面投射阴影确定如下：THREE.FrontSide 背面THREE.BackSide 前面THREE.DoubleSide 双面
// vertexColors（顶点颜色）	可以为物体的每一个顶点指定特有颜色。是否使用顶点着色。默认值为THREE.NoColors。 其他选项有THREE.VertexColors 和 THREE.FaceColors。
// fog（雾）	材质是否受雾影响。默认为true。
```

## 材质的融合属性

```js
// blending（融合）	决定物体材质如何与背景融合，一般融合模式为THREE.NormalBlending，这种模式下只显示材质的上层。
// blendSrc（融合源）	混合源。默认值为THREE.SrcAlphaFactor。
// blendSrcAlpha（融合源透明度）	blendSrc的透明度。 默认值为 null。
// blendDst（融合目标）	定义了融合时使用何种背景（目标），默认为THREE.OneMinusSrcAlphaFactor，其含义是目标也使用源的alpha通道进行融合，只是使用的值为1（源的aloha通道值）。
// blendDstAlpha（融合目标透明度）	为blendDst的指定透明度，默认为null。
// blendEquation（融合公式）	使用混合时所采用的混合方程式。默认值为使它们相加（AddEquation），也可以创建自定义融合模式。
```

## 材质的高级属性

```js
// 材质的高级属性大多数在内部使用，用来控制WEBGL渲染场景时的细节。通常我们不会使用它们，这里只做了解，不会去讲解。

// depthTest	是否在渲染此材质时启用深度测试。默认为 true。
// depthWrite	渲染此材质是否对深度缓冲区有任何影响。默认为true。
// 在绘制2D叠加时，将多个事物分层在一起而不创建z-index时，禁用深度写入会很有用。
// depthFunc	使用何种深度函数。默认为LessEqualDepth。
// polygonOffset、polygonOffsetFactor、polygonOffsetUnits	是否使用多边形偏移。默认值为false。
// 设置多边形偏移系数。默认值为0。设置多边形偏移单位。默认值为0。
// alphaTest	设置运行alphaTest时要使用的alpha值。如果不透明度低于此值，则不会渲染材质。默认值为0。
// precision	重写此材质渲染器的默认精度。可以是"highp", "mediump" 或 "lowp"。默认值为null。
```

## 简单的网格材质

```js
// 我们先从简单的网格材质说起：MeshBasicMaterial、MeshDepthMaterial、MeshNormalMaterial。
```

- 2.1. THREE.MeshBasicMaterial

```js
// THREE.MeshBasicMaterial是一种非常简单的材质，该材质不用考虑场景中的光照影响。使用该材质的网格会被渲染成简单的平面图多边形，而且可以显示几何体的线框。

// 特有属性：

// color（颜色）	设置材质颜色
// wireframe（线框）	将几何体渲染为线框。默认值为false（即渲染为平面多边形）。
// wireframeLinewidth（线框宽）	控制线框宽度。默认值为1。
// wireframeLinecap（线框线段端点）	定义线两端的外观。可选值为 'butt'，'round' 和 'square'。默认为'round'。
// wireframeLinejoin（线框端线段连接点）	定义线连接节点的样式。可选值为 'round', 'bevel' 和 'miter'。默认值为 'round'。
```

```js
// 用正方体做一下演示
// 添加正方体
const cubeGeometry = new THREE.BoxGeometry(4, 4, 4);
const cubeMaterial = new THREE.MeshBasicMaterial({
  color: 0xff0000,
  wireframe: true,
  wireframeLinewidth: 2,
});
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
cube.position.set(0, 0, 0);
scene.add(cube);
```

- 2.2. THREE.MeshDepthMaterial

```js
// 这种材质的物体，其外观不是由光照或者某个材质属性决定的，而是由物体到摄像机的就离决定的。
// 该材质通常可以与其它材质结合使用，从而创作出逐渐消失的效果。

// 该材质的属性有：
// wireFrame	是否显示线框
// wireFrameLineWidth	指定线框的宽度（只对CanvasRenderer有效）
// 当几何体使用该材质后，会基于摄像机的距离为物体上色，效果如下：

// 我们可以设置场景中的每个物体都使用该材质。

const scene = new THREE.Scene();
scene.overrideMaterial = new THREE.MeshDepthMaterial();
```

- 2.3. 联合材质

```js
// 我们看THREE.MeshDepthMaterial时发现，该材质没有任何设置物体颜色的属性，只能由材质默认属性渲染。但是，我们可以通过联合材质来创建出新效果，这便是材质融合。

// 使用联合材质，我们就可以很方便的为一个物体添加多个材质啦~

mport * as SceneUtils from 'three/examples/jsm/utils/SceneUtils'
...
// 定义摄像机
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 50, 110)
  camera.position.set(-50, 40, 50)
  camera.lookAt(scene.position)
...
// 定义联合材质生成正方体
const cubeGeometry = new THREE.BoxGeometry(4, 4, 4)
  const cubeMaterial = new THREE.MeshDepthMaterial()
  const colorMaterial = new THREE.MeshBasicMaterial({
    'color': 0x00ff00,
    'transparent': true,
    'blending': THREE.MultiplyBlending // 指定融合模式
  })
  // eslint-disable-next-line new-cap
  const cube = new SceneUtils.createMultiMaterialObject(cubeGeometry, [cubeMaterial, colorMaterial])
  scene.add(cube)
```

- 2.4. THREE.MeshNormalMaterial

```js
// THREE.MashNormalMaterial 是一种法向量材质，该材质拥有的属性同 THREE.MeshDepthMaterial 相同。

// 法向量，是指与面垂直的向量，它可以有助于决定光的反射，有助于将纹理映射到三维模型，并提供如何计算光照、阴影和为表面像素着色的信息。幸运的使，Three.js库已经为我们处理了这些向量的运算，而且在库内部使用，无需我们来操心。

// 看如下案例，不管小球如何旋转，颜色分布都是保持不变的，因为小球每一面的颜色都是由该面向外指向的法向量计算得到的。

// 添加球体
const sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
const sphereMaterial = new THREE.MeshNormalMaterial({
  flatShading: true, // 方便我们看到每个面的颜色
});
const spheraMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(spheraMesh);
```

```js
// 接下来，我们来显示出法向量箭头：
import { VertexNormalsHelper } from 'three/examples/jsm/helpers/VertexNormalsHelper.js';
// 添加球体
const sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
const sphereMaterial = new THREE.MeshNormalMaterial({
  flatShading: true,
});
const spheraMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
const vnh = new VertexNormalsHelper(spheraMesh, 5);
scene.add(vnh);
```

## 2.5. 在单个几何体上使用多种材质

```js
// 目前为止，我们渲染的每一个案例，只是用单种材质。其实，我们是有办法去使用多种材质的。

// 例如，在一个立方体中，有12个面（three.js只作用于三角形，所以每个面由两个三角形构成，一共12个三角形，所以也称为12个面），我们可以单独为这些面设置自己的材质。

// 我们定义了一个数组中存了6个材质，传入THREE.Mesh，那么，程序会自动为每两个面添加一个材质的。
// 添加正方体
const cubeMaterial01 = new THREE.MeshBasicMaterial({
  color: 'red',
});
const cubeMaterial02 = new THREE.MeshBasicMaterial({
  color: 'green',
});
const cubeMaterial03 = new THREE.MeshBasicMaterial({
  color: 'blue',
});
const cubeMaterial04 = new THREE.MeshBasicMaterial({
  color: 'pink',
});
const cubeMaterial05 = new THREE.MeshBasicMaterial({
  color: 'orange',
});
const cubeMaterial06 = new THREE.MeshBasicMaterial({
  color: 'write',
});
const materialArr = [
  cubeMaterial01,
  cubeMaterial02,
  cubeMaterial03,
  cubeMaterial04,
  cubeMaterial05,
  cubeMaterial06,
];
const cubeGeometry = new THREE.BoxGeometry(4, 4, 4);
const cube = new THREE.Mesh(cubeGeometry, materialArr);
cube.position.set(0, 0, 0);
scene.add(cube);
```

## 3. 高级材质

- 3.1. THREE.MeshLambertMaterial

```js
// 这种材质通常用来创造一个暗淡的并不光亮的表面，用法非常简单，并且会对场景中的光源做出反应。

// 自有属性如下：
// 名称	描述
// color（颜色）	材质的环境色。
// emissice（自发光）	材质的自发光颜色。该属性不会使物体成为光源，但是它的颜色也不会受其他光源的影响，默认值为黑色。
// 该材质也支持线框效果，所以，我们可以用来描绘一个具有光线效果的线框物体。

// 添加球体
const sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
const sphereMaterial = new THREE.MeshLambertMaterial({
  color: 0x7777ff, // 本身的颜色
  emissive: 'orange', // 自发光的颜色
  wireframe: true, // 显示框线
});
const spheraMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(spheraMesh);
```

- 3.2. THREE.MeshPhongMaterial

```js
// 该材质可以创建一种光亮的材质。属性与THREE.MeshLambertMaterial基本一样，它即可以模拟塑料质感，也可以模拟金属质感。

// color（颜色）	材质的环境光，它会与环境光相乘，默认是白色。
// emissive（自发光）	材质的自发光颜色。该属性不会使物体成为光源，但是它的颜色也不会受其他光源的影响，默认值为黑色。
// specular（高光颜色）	指定材质的光亮程度及高光部分的颜色，如果它的颜色与color一致，会显示出金属的效果，设置成灰色(grey)，则更像塑料。
// shiness（高光度）	指定物体表面镜面高光部分的轮廓清晰程度，越光滑的表面，高光部分越清晰，反之越模糊。该属性默认值为30。

// 添加球体
const sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
const sphereMaterial = new THREE.MeshPhongMaterial({
  color: 0x7777ff, // 本身的颜色
  specular: 0x7777ff, // 高光颜色
});
const spheraMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(spheraMesh);
```

- 3.3. THREE.MeshStandardMaterial

```js
// 该材质可以使用更加正确的物理计算决定物体表面如何与场景中的光源互动，可以更好的表现金属质感和塑料质感。

// metaIness（金属感程度）	0代表完全塑料质感。1代表完全金属质感。默认0.5
// roughness（粗糙程度）	控制物体表面的粗糙程度。默认0.5，0时产生镜面反射，1时产生漫反射。

// 添加球体
const sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
const sphereMaterial = new THREE.MeshStandardMaterial({
  color: 0x7777ff, // 本身的颜色
  metalness: 0, // 金属感程度
  roughness: 0, // 粗糙程度
});
const spheraMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(spheraMesh);
```

- 3.4. THREE.MeshPhysicalMaterial

```js
// 该材质与THREE.MeshStandardMaterial非常相似，但是提供了对反光度的更多控制属性。

// clearCoat（清漆）	清漆效果的明显成都，从0.0到1.0。默认值为0.0。
// clearCoatRoughness（清漆粗糙度）	与clearCoat配合使用，从0.0到1.0。默认值为0.0。
// reflectivity（反光度）	控制非金属表面反光度，从0.0到1.0。默认值为0.5。当metalness（金属感程度）为1或者接近1时该属性作用很小。

// 添加球体
const sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
const sphereMaterial = new THREE.MeshPhysicalMaterial({
  color: 0x7777ff, // 本身的颜色
  metalness: 0.5, // 金属感程度
  roughness: 0, // 粗糙程度
  learCoat: 0.5, // 清漆度
  reflectivity: 0.7, // 反光度
});
const spheraMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(spheraMesh);
```

- 3.5. THREE.ShaderMaterial

```js
// THREE.ShaderMaterial是最通用最复杂的材质之一，通过它，可以定制着色器，直接在WebGL环境下运行。

// wireframe	是否渲染成线框。
// wireframeLinewidth	定义线框宽度
// linewidth	定义描绘线的宽度
// shading	定义如何着色，可选属性有 THREE.SmoothSjading和THREE.FlatShading
// vertexColors	为每个顶点定义不同颜色
// fog	是否接受雾化效果影响。
```

- 高级属性

```js
// fragmentShader	这个着色器定义每个传入像素的颜色，需要传入像素着色器字符串。
// vertexShader	允许你修改每一个传入顶点的位置，需要传入顶点着色器程序字符串。
// uniforms	通过这个属性可以向你的着色器发信息，信息会发给每一个顶点的片段。
// attributes	该属性可以修改每个顶点和片段。通常用来传递位置数据和法向量数据。如果要用这个属性，那么需要你为几何体中每个顶点提供信息。
// defines	转换成 #define 代码片段。这些片段可以用来设置着色器中的一些额外的全局变量。
// lights	定义光照属性是否传递给着色器，默认false

// 定义顶点着色器程序
const vertShader = `
    uniform float time;
    varying vec2 vUv;


    void main()
    {
    vec3 posChanged = position;
    posChanged.x = posChanged.x*(abs(sin(time*1.0)));
    posChanged.y = posChanged.y*(abs(cos(time*1.0)));
    posChanged.z = posChanged.z*(abs(sin(time*1.0)));
    //gl_Position = projectionMatrix * modelViewMatrix * vec4(position*(abs(sin(time)/2.0)+0.5),1.0);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(posChanged,1.0);
    }
  `;
// 定义像素着色器程序
const fragShader1 = `
    precision highp float;
    uniform float time;
    uniform float alpha;
    uniform vec2 resolution;
    varying vec2 vUv;

    void main2(void)
    {
    vec2 position = vUv;
    float red = 1.0;
    float green = 0.25 + sin(time) * 0.25;
    float blue = 0.0;
    vec3 rgb = vec3(red, green, blue);
    vec4 color = vec4(rgb, alpha);
    gl_FragColor = color;
    }

    #define PI 3.14159
    #define TWO_PI (PI*2.0)
    #define N 68.5

    void main(void)
    {
    vec2 center = (gl_FragCoord.xy);
    center.x=-10.12*sin(time/200.0);
    center.y=-10.12*cos(time/200.0);

    vec2 v = (gl_FragCoord.xy - resolution/20.0) / min(resolution.y,resolution.x) * 15.0;
    v.x=v.x-10.0;
    v.y=v.y-200.0;
    float col = 0.0;

    for(float i = 0.0; i < N; i++)
    {
    float a = i * (TWO_PI/N) * 61.95;
    col += cos(TWO_PI*(v.y * cos(a) + v.x * sin(a) + sin(time*0.004)*100.0 ));
    }

    col /= 5.0;

    gl_FragColor = vec4(col*1.0, -col*1.0,-col*4.0, 1.0);
    }
  `;
const fragShader2 = `
    uniform float time;
    uniform vec2 resolution;

    // 2013-03-30 by @hintz

    #define CGFloat float
    #define M_PI 3.14159265359

    vec3 hsvtorgb(float h, float s, float v)
    {
    float c = v * s;
    h = mod((h * 6.0), 6.0);
    float x = c * (1.0 - abs(mod(h, 2.0) - 1.0));
    vec3 color;

    if (0.0 <= h && h < 1.0)
    {
    color = vec3(c, x, 0.0);
    }
    else if (1.0 <= h && h < 2.0)
    {
    color = vec3(x, c, 0.0);
    }
    else if (2.0 <= h && h < 3.0)
    {
    color = vec3(0.0, c, x);
    }
    else if (3.0 <= h && h < 4.0)
    {
    color = vec3(0.0, x, c);
    }
    else if (4.0 <= h && h < 5.0)
    {
    color = vec3(x, 0.0, c);
    }
    else if (5.0 <= h && h < 6.0)
    {
    color = vec3(c, 0.0, x);
    }
    else
    {
    color = vec3(0.0);
    }

    color += v - c;

    return color;
    }

    void main(void)
    {

    vec2 position = (gl_FragCoord.xy - 0.5 * resolution) / resolution.y;
    float x = position.x;
    float y = position.y;

    CGFloat a = atan(x, y);

    CGFloat d = sqrt(x*x+y*y);
    CGFloat d0 = 0.5*(sin(d-time)+1.5)*d;
    CGFloat d1 = 5.0;

    CGFloat u = mod(a*d1+sin(d*10.0+time), M_PI*2.0)/M_PI*0.5 - 0.5;
    CGFloat v = mod(pow(d0*4.0, 0.75),1.0) - 0.5;

    CGFloat dd = sqrt(u*u+v*v);

    CGFloat aa = atan(u, v);

    CGFloat uu = mod(aa*3.0+3.0*cos(dd*30.0-time), M_PI*2.0)/M_PI*0.5 - 0.5;
    // CGFloat vv = mod(dd*4.0,1.0) - 0.5;

    CGFloat d2 = sqrt(uu*uu+v*v)*1.5;

    gl_FragColor = vec4( hsvtorgb(dd+time*0.5/d1, sin(dd*time), d2), 1.0 );
    }
  `;
// 根据着色器生成材质
// eslint-disable-next-line no-shadow
function createMaterial(vertShader, fragShader) {
  var uniforms = {
    time: {
      type: 'f',
      value: 0.2,
    },
    scale: {
      type: 'f',
      value: 0.2,
    },
    alpha: {
      type: 'f',
      value: 0.6,
    },
    resolution: {
      type: 'v2',
      value: new THREE.Vector2(),
    },
  };

  uniforms.resolution.value.x = window.innerWidth;
  uniforms.resolution.value.y = window.innerHeight;

  const meshMaterial = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vertShader,
    fragmentShader: fragShader,
    transparent: true,
  });
  return meshMaterial;
}
// 生成材质
const cubeMaterial01 = createMaterial(vertShader, fragShader1);
const cubeMaterial02 = createMaterial(vertShader, fragShader2);
const cubeMaterial03 = createMaterial(vertShader, fragShader1);
const cubeMaterial04 = createMaterial(vertShader, fragShader2);
const cubeMaterial05 = createMaterial(vertShader, fragShader1);
const cubeMaterial06 = createMaterial(vertShader, fragShader2);
const materialArr = [
  cubeMaterial01,
  cubeMaterial02,
  cubeMaterial03,
  cubeMaterial04,
  cubeMaterial05,
  cubeMaterial06,
];
const cubeGeometry = new THREE.BoxGeometry(4, 4, 4);
const cube = new THREE.Mesh(cubeGeometry, materialArr);
cube.position.set(0, 0, 0);
scene.add(cube);
```

## 线性几何体材质

- 4.1. THREE.LineBasicMaterial

```js
// color	定义线的颜色。
// lineWidth	线段宽度
// lineCap	定义线两端的样式。可选值为 'butt', 'round' 和 'square'。默认值为 'round'。(2D属性，无法3D渲染)
// lineJoin	定义线连接节点的样式。可选值为 'round', 'bevel' 和 'miter'。默认值为 'round'。(2D属性，无法3D渲染)
// vertexColors	将这个属性设置成THREE.VertexColors值，就可以为每个顶点指定一个颜色

// 定义线
// 材质
const lineMaterial = new THREE.LineBasicMaterial({ color: 'pink' });
// 声明几何体
const geometry = new THREE.BufferGeometry();
geometry.attributes.position = new THREE.BufferAttribute(
  new Float32Array([-10, 0, 0, 0, 10, 0]),
  3
);
const line = new THREE.Line(geometry, lineMaterial);
scene.add(line);
```

- 4.2. THREE.LineDashedMaterial

```js
// 该材质属性与THREE.LineBasicMaterial相同，知识多出了几个额外属性。
// scale	缩放dashSize和gapSize。如果scale小于1，dashSize和gapSize会增大。反之会减小。
// dashSize	虚线段的长度。
// gapSize	虚线段的间隔。

// 定义线
// 材质
const lineMaterial = new THREE.LineDashedMaterial({
  color: 'pink',
  dashSize: 0.1,
  gapSize: 0.1,
  scale: 0.1,
});
// 声明几何体
const geometry = new THREE.BufferGeometry();
geometry.attributes.position = new THREE.BufferAttribute(
  new Float32Array([-10, 0, 0, 0, 10, 0]),
  3
);
const line = new THREE.Line(geometry, lineMaterial);
line.computeLineDistances(); //不可或缺的，若无，则线段不能显示为虚线
scene.add(line);
```
