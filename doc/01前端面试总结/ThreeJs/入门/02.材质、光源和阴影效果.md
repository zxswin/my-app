## 材质、光源和阴影效果

```js
// 导入 three.js 包
import * as THREE from 'three';

// 定义场景
const scene = new THREE.Scene();
// 定义摄像机
const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
// 定义渲染器
const renderer = new THREE.WebGLRenderer();
// 定义场景的颜色为黑色
renderer.setClearColor(0x000000);
// 定义场景大小为整个窗口
renderer.setSize(window.innerWidth, window.innerHeight);
// 启动渲染阴影效果
renderer.shadowMap.enabled = true;
// 创建一个粗细为20的坐标轴
const axes = new THREE.AxesHelper(20);
scene.add(axes);

// 添加光源
const spotLight = new THREE.SpotLight(0xffffff);
spotLight.position.set(-40, 40, -15);
spotLight.castShadow = true;
spotLight.shadow.mapSize = new THREE.Vector2(1024, 1024);
spotLight.shadow.camera.far = 130;
spotLight.shadow.camera.near = 40;
scene.add(spotLight);

// 创建一个宽为60，高为20的的平面。
const planeGeometry = new THREE.PlaneGeometry(60, 20);
// 设置平面的材质
const planeMaterial = new THREE.MeshLambertMaterial({
  color: 0xffffff,
});
// 赋值到Mesh
const plane = new THREE.Mesh(planeGeometry, planeMaterial);
// 设置平面位置和旋转
plane.rotation.x = -0.5 * Math.PI;
plane.position.set(15, 0, 0);
// 设置地面为投影面
plane.receiveShadow = true;
// 将平面添加到场景中
scene.add(plane);

// 创建一个立方体
const cubeGeometry = new THREE.BoxGeometry(4, 4, 4);
const cubeMaterial = new THREE.MeshLambertMaterial({
  color: 0xff0000,
});
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
cube.position.set(-4, 3, 0);
// 开启投影
cube.castShadow = true;
scene.add(cube);

// 创建一个球体
const sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
const sphereMaterial = new THREE.MeshLambertMaterial({
  color: 0x7777ff,
});
const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
sphere.position.set(20, 4, 2);
// 开启投影
sphere.castShadow = true;
scene.add(sphere);

// 设置摄像机的位置
camera.position.set(-30, 40, 30);
// 摄像机指向场景中心
camera.lookAt(scene.position);
// 将渲染的结果加入到div中
document.querySelector('#webgl-box').appendChild(renderer.domElement);

renderer.render(scene, camera);
```

## 代码分析：

- code1:

```js
// THREE.SpotLight 可以定义光源，并从位置(-40,40,-15)照射到场景中。
// spotLight.castShadow设置为true，光源的阴影功能将被启用。此外，spotLight.shadow.camera.far、spotLight.shadow.camera.near、spotLight.shadow.mapSize 这三个属性用来控制阴影的精密程度。
// 最后，将该光源添加到场景中。
// 光源有很多种，在这里我只是展示了SpotLight这个基础的光源

const spotLight = new THREE.SpotLight(0xffffff);
spotLight.position.set(-40, 40, -15);
spotLight.castShadow = true;
spotLight.shadow.mapSize = new THREE.Vector2(1024, 1024);
spotLight.shadow.camera.far = 130;
spotLight.shadow.camera.near = 40;
scene.add(spotLight);
```

- code2:

```js
// 不同的材质，对光源的反应也是不一样的。再上一章中，我们使用的是基本材质 MeshBasicMaterial，该材质对光源不会产生任何反应，所以，在本章节案例中，我们把所有物体的材质都替换为 MeshLambertMaterial。

// 设置平面的材质
const planeMaterial = new THREE.MeshLambertMaterial({
  color: 0xffffff,
});

// 设置立方体的材质
const cubeMaterial = new THREE.MeshLambertMaterial({
  color: 0xff0000,
});

// 设置球体的材质
const sphereMaterial = new THREE.MeshLambertMaterial({
  color: 0x7777ff,
});
```

- code3:

```js
// 默认情况下，Three.js 是不会开启阴影渲染的，因为该效果会使用大量的资源进行计算，因此，我们在创建渲染器后，需要设置属性 renderer.shadowMap.enabled 为 true 来手动启动渲染器对阴影的渲染能力。

// 定义渲染器
const renderer = new THREE.WebGLRenderer();
// 定义场景的颜色为黑色
renderer.setClearColor(0x000000);
// 定义场景大小为整个窗口
renderer.setSize(window.innerWidth, window.innerHeight);
// 启动渲染阴影效果
renderer.shadowMap.enabled = true;
```

- code4:

```js
// 我们启动渲染器渲染投影后，是依然不够的，我们还需要指定哪个物体投射阴影，那个物体去接受阴影。
// 在上边的案例中，plane.receiveShadow 设置为 true，表示我们把平面plane设置为接受阴影的物体。
// cube.castShadow =true、sphere.castShadow =true，表示我们把立方体和球体设置为投射阴影的物体。

// 创建一个宽为60，高为20的的平面。
// 设置地面为投影面
plane.receiveShadow = true;
// 将平面添加到场景中
scene.add(plane);
// 创建一个立方体
// 开启投影
cube.castShadow = true;
scene.add(cube);
// 创建一个球体
// 开启投影
sphere.castShadow = true;
scene.add(sphere);
```
