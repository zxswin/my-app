## Three.js 动画、移动摄像机、变形和骨骼动画、外部模型动画

```js
// 基础动画
// 移动摄像机
// 变形和骨骼动画
// 使用外部模型创建动画
```

## 1. 基础动画

```js
// 在之前的章节中，我们使用H5的requestAnimationFrame()来循环渲染场景来实现动画
// requestAnimationFrame()可以保证合适的时间触发renderScence方法，一般为 60次/秒。

// 在H5普及之前，我们使用 setInterval、setTimerout来指定时间间隔触发动画，但是这两个方法有个缺点，就是在切换标签后，依然执行，无形之中就会浪费资源，占用CPU使用率。

// 使用requestAnimationFrame，浏览器会在合适的时机执行我们的动画，该方法实现的动画更加平滑，对CPU和GPU友好，也不用担心渲染时机的问题。

function renderScence() {
  requestAnimationFrame(renderScence);
  renderer.render(scene, camera);
}
renderScence();
```

## 简单动画

```js
// 你可以通过物体的旋转、缩放、位置、材质、顶点、面等任何你能想到的属性来实现动画。

// three.js会在下一次render循环中渲染修改后的属性。

// 在前边章节我们有一个案例，我们修改了网格的属性，然后three.js就会进行处理：

let step = 0; // 定义小球弹跳速度
function renderScence() {
  // 定义小球的弹跳动画
  step += 0.04;
  sphere.position.x = 20 + 10 * Math.cos(step);
  sphere.position.y = 2 + 10 * Math.abs(Math.sin(step));

  requestAnimationFrame(renderScence);
  renderer.render(scene, camera);
}
renderScence();
```

## 1.2 选择对象

```js
// 如何用鼠标选择场景中的对象，虽然该知识点和动画没几毛钱关系，但是，有助于我们系统的了解本章内容。
// 创建一个立方体
const cubeMaterial = new MeshNormalMaterial();
const cubeGeometry = new BoxGeometry(10, 10, 10);
const cubeMesh = new Mesh(cubeGeometry, cubeMaterial);
scene.add(cubeMesh);
// 定义点击事件
document.addEventListener('click', (event) => {
  // 获取屏幕坐标
  let vector = new THREE.Vector3(
    (event.clientX / window.innerWidth) * 2 - 1,
    -(event.clientY / window.innerHeight) * 2 + 1,
    0.5
  );
  // 将屏幕坐标转换为three.js场景坐标（鼠标点击位坐标置转三维坐标）
  vector = vector.unproject(camera);

  // 摄像机位置向场景发射“光线”
  const raycaster = new THREE.Raycaster(
    camera.position,
    vector.sub(camera.position).normalize()
  );
  // 判断指定的对象中哪些被该光线照射到了
  const intersects = raycaster.intersectObjects([cubeMesh]);

  if (intersects.length > 0) {
    // 旋转网格(mesh)
    console.log(intersects[0]);
    intersects[0].object.rotation.x += (10 * Math.PI) / 180;
    intersects[0].object.rotation.y += (10 * Math.PI) / 180;
    intersects[0].object.rotation.z += (10 * Math.PI) / 180;
  }
});
```

```js
// 如上案例：

// 我们运用了 let vector =newTHREE.Vector3(event.clientX / window.innerWidth *2-1,-(event.clientY / window.innerHeight)*2+1,0.5) 获取屏幕像素坐标。
// 我们用 vector.unproject(camera) 将像素坐标转为三维坐标。
// 我们用 const raycaster =newTHREE.Raycaster(camera.position, vector.sub(camera.position).normalize())从摄像机发射光线。
// 我们用 raycaster.intersectObjects([cubeMesh]) 获取被鼠标选中的物体。
```

```js
//  console.log(intersects[0]) 打印结果：
// face和faceIndex 指的是网格中被选中的面。
// distance是从摄像机到被点击对象的距离。
// point指网格中哪个点被点击了。
// uv指的是点击位置的2D纹理的uv值（下一章会具体介绍）。
```

## 使用 Tween.js 实现动画

```js
// 通过Tween，您还可以指定属性值是如何变化的，是线性的、指数的还是其它方式。
// 属性在指定时间内完成变化的被称为缓动（easing），在Tween.js 中您可以使用easing()实现缓动效果。


const tween = new TWEEN.Tween({'x': 10}).to({'x': 3}, 1000)
    .easing(TWEEN.Easing.Elastic.InOut)
    .onUpdate(() => {
      // update the mesh
    }).start()

...
function renderScence () {
    TWEEN.update()
    requestAnimationFrame(renderScence)
  }
  renderScence()
```

```js
let cubePos = { x: 0 };
const cubeMaterial = new MeshNormalMaterial();
const cubeGeometry = new BoxGeometry(10, 10, 10);
const cubeMesh = new Mesh(cubeGeometry, cubeMaterial);
cubeMesh.position.x = cubePos.x;
scene.add(cubeMesh);
const upDataFn = () => {
  cubeMesh.position.x = cubePos.x;
};
const tween = new TWEEN.Tween(cubePos).to({ x: 50 }, 2000);
tween.easing(TWEEN.Easing.Elastic.InOut);
tween.onUpdate(upDataFn);

// 衔接另一个动画
const tweenBack = new TWEEN.Tween(cubePos).to({ x: 0 }, 2000);
tweenBack.easing(TWEEN.Easing.Elastic.InOut);
tweenBack.onUpdate(upDataFn);
tween.chain(tweenBack);
tweenBack.chain(tween);
tween.start();

// 帧率动画
function renderScence() {
  trackballControls.update(clock);
  TWEEN.update();
  requestAnimationFrame(renderScence);
  renderer.render(scene, camera);
}
renderScence();
```

## 2. 使用摄像机

```js
// Three.js提供了一些摄像机控件，使用这些控件可以控制场景中的摄像机。这些控件放置在Three.js的发布包中。
// three/examples/jsm/controls

// FirstPersonControls（第一视角控制器）	该控制器类似于第一视角射击游戏中的摄像机。使用键盘控制移动，使用鼠标转动。
// FlyControls（飞行控制器）	飞行模拟控制器，用键盘鼠标控制摄像机移动。
// RollControls（翻滚控制器）	该控制器是飞行控制器的简化版，允许绕着z轴旋转。
// TrackBallControls（轨迹球控制器）	最常用的控制器，你可以用鼠标（或者控制球）来轻松移动、平移和缩放场景。注意，OrtographicCamera摄像机专用控制器为 OrtographicTrack BallControls。
// OrbitControls（轨道控制器）	该控制器可以在特定场景中模拟轨道中的卫星，你可以使用鼠标键盘在场景中游走。

// 还有一个特殊的控件 DragControl，它与其它摄像机控制器不同，该控件可以拖动场景中的物体而不是摄像机。
// 除了使用控制器，你还可以使用修改 position 属性移动摄像机，空过lookAt()方法改变摄像机的朝向。
```

## 2.1 轨迹球控制器

```js
// 使用TrackBallControls，我们先要找到它的包，并导入到代码中。
// import { TrackballControls } from 'three/examples/jsm/controls/TrackballControls'
```

```js
// 完成后，我们就可以对场景进行如下操作了：

// 按住鼠标左键，拖动：摄像机在场景中旋转和翻滚
// 转动鼠标滚轮：放大和缩小
// 按住鼠标中键，拖动：放大和缩小
// 按住鼠标右键，拖动：摄像机在场景中平移

// 导入包后，我们就可以创建控制器，并把它绑定到摄像机上。
// 摄像机轨迹控制器
const trackballControls = new TrackballControls(camera, renderer.domElement);
trackballControls.rotateSpeed = 1.0;
trackballControls.zoomSpeed = 1.0;
trackballControls.panSpeed = 1.0;

const clock = new THREE.Clock();
// 帧率动画
function renderScence() {
  // 计算此次调用距离上次调用间隔的时间
  const detail = clock.getDelta();
  // 更新摄像机的位置，为了保证平滑，我们必须传入精确的时间 detail
  trackballControls.update(detail);
  TWEEN.update();
  requestAnimationFrame(renderScence);
  renderer.render(scene, camera);
}
renderScence();
```

## 2.2 飞行控制

```js
// 完成后，我们就可以对场景进行如下操作了：

// 按住鼠标左键和中键 / W：向前移动
// 按住鼠标右键 / S：向后移动
// 移动鼠标：向四周看
// A：向左移动
// D：向右移动
// R：向上移动
// F向下移动
// 上、下、左、右：向上、下、左、右看
// G：向左翻滚
// E：向右翻滚

// 我们讲解飞行控制（FlyControls）。使用该控件，您何以实现摄像机像飞行模拟器一样场景总飞翔。
// 同样，先导入文件：

import { FlyControls } from 'three/examples/jsm/controls/FlyControls';
// 然后配置绑定到摄像机：

// 飞行控制器
const flyControls = new FlyControls(camera, renderer.domElement);
flyControls.movementSpeed = 25;
flyControls.rollSpeed = Math.PI / 24;
flyControls.autoForward = true;
flyControls.dragToLook = true;

const clock = new THREE.Clock();
// 帧率动画
function renderScence() {
  // 计算此次调用距离上次调用间隔的时间
  const detail = clock.getDelta();
  // 更新摄像机的位置，为了保证平滑，我们必须传入精确的时间 detail
  flyControls.update(detail);
  TWEEN.update();
  requestAnimationFrame(renderScence);
  renderer.render(scene, camera);
}
renderScence();
```

## 2.3 第一视角控制器

```js
// 顾名思义，通过第一视角控制器（FirstPersonControls）你可以像第一人称射击游戏那样控制摄像机。

// 同样，先导入文件：

import { FirstPersonControls } from 'three/examples/jsm/controls/FirstPersonControls';

// 注意，firstPersonControls.lon =-150 、firstPersonControls.lat =120 是定义场景初次渲染时摄像机所指向的位置的。

// 完成后，我们就可以对场景进行如下操作了：

// 移动鼠标：向四周看
// 上、下、左、右：向上、下、左、右移动
// W、A、S、D：向前左后右移动
// R：向上移动
// F：向下移动
// Q：停止移动

// 然后配置绑定到摄像机：

const firstPersonControls = new FirstPersonControls(
  camera,
  renderer.domElement
);
firstPersonControls.lookSpeed = 0.4;
firstPersonControls.movementSpeed = 20;
firstPersonControls.lookVertical = true;
firstPersonControls.constrainVertical = true;
firstPersonControls.verticalMin = 1.0;
firstPersonControls.verticalMax = 2.0;
firstPersonControls.lon = -150;
firstPersonControls.lat = 120;

const clock = new THREE.Clock();
// 帧率动画
function renderScence() {
  // 计算此次调用距离上次调用间隔的时间
  const detail = clock.getDelta();
  // 更新摄像机的位置，为了保证平滑，我们必须传入精确的时间 detail
  firstPersonControls.update(detail);
  TWEEN.update();
  requestAnimationFrame(renderScence);
  renderer.render(scene, camera);
}
renderScence();
```

## 2.4 轨道控制器

```js
// 轨道控制器（OrbitControls）可以控制场景中的对象围绕场景中心旋转和平移。

// 同样，先导入文件：

import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
// 然后配置绑定到摄像机：

const orbitControls = new OrbitControls(camera, renderer.domElement);
orbitControls.autoRotate = true;

const clock = new THREE.Clock();
// 帧率动画
function renderScence() {
  // 计算此次调用距离上次调用间隔的时间
  const detail = clock.getDelta();
  // 更新摄像机的位置，为了保证平滑，我们必须传入精确的时间 detail
  orbitControls.update(detail);
  requestAnimationFrame(renderScence);
  renderer.render(scene, camera);
}
renderScence();
// 完成后，我们就可以对场景进行如下操作了：

// 按住鼠标左键并移动：摄像机围绕场景中心旋转
// 上、下、左、右：在场景中平移
// 转动鼠标滑轮或按住中键并移动：放大和缩小
// 按住鼠标右键并移动：在场景中平移
```

## 3. 变形动画和骨骼动画

```js
// 你使用外部软件创建动画时，通常有两种定义动画的方式：

// 变形动画：使用变形动画，你将要定义网格变形之后的状态，或者说，关键位置。对于变形目标，所有顶点位置都会被存储下来。你需要做的就是将所有顶点从一个位置移动到另外一个定义好的关键位置，并重复该过程。
// 骨骼动画：另一种替代方式是骨骼动画。使用骨骼动画你需要定义骨骼，也就是网格的骨头，并将顶点绑定到特定的骨头上。然后你移动一块骨头时，任何与其相连的骨头都会做相应的移动，同时骨头上绑定到顶点也会随之移动。网格的变形也是基于骨头的位置、移动和缩放实现的。
// Three.js这两种模式都支持，但是相比而言，变形动画能够获得更好的效果，也更容易制作和导出数据。
```

## 3.1 用外部模型和变形目标创建动画

```js
// 变形目标是实现动画的最直接方式。你可以为所有顶点定义一些列关键位置（关键帧），然后让three.js将这些顶点从一个位置移动到另一个位置。但是这种方式缺点非常明显，那就是如果对于大型网格和大型动画时，模型会变得非常的臃肿，因为每个关键帧位置，所有顶点位置都需要重复存储一遍。

// three.js提供了三个核心动画类：

// THREE.AnimationClip：当具有动画数据的模型被加载后，获得的模型对象往往具有一个名为animations的成员对象。该对象包含了一个THREE.AnimationClip对象集合。一个模型所包含的THREE.AnimationClip对象通常保存有某种特定类型的动画数据，或者是该模型能够执行的某种动作。例如，加载一个小鸟的模型，它可能包含两个THREE.AnimationClip对象，一个是拍打翅膀的动作，另一个是张嘴闭嘴的动作。
// THREE.AnimationMixer：THREE.AnimationMixer对象用于控制多个THREE.AnimationClip对象，确保这些动画在适当的时间发生，使动画同步或者控制从一个动画过渡到另一个动画。
// THREE.AnimationAction：当THREE.AnimationMixer对象添加一个THREE.AnimationClip对象时，调用者将会获得一个THREE.AnimationAction。很多动画控制功能是通过THREE.AnimationAction来调用的，而THREE.AnimationMixer本身并没有提供很全面的接口。除了添加动画外，THREE.AnimationAction对象也可以随时从THREE.AnimationMixe获取。
```

## 使用外部模型创建动画

```js
// 加载器返回的result对象包含 animations对象，animations为AnimationClip对象集合，这正对应了我们上边列出的知识点。

// 加载模型
let mixer = null;
const loader = new GLTFLoader();
loader.load('../img/Rampaging T-Rex.glb', (result) => {
  // AnimationMixer对象控制一个或者多个动画，这里我们控制第一个动画
  // 该对象接收一个AnimationClip，返回一个 AnimationAction
  mixer = new THREE.AnimationMixer(result.scene.children[0]);
  // AnimationAction 控制动画执行  设置动画时长10秒 并开始执行
  mixer.clipAction(result.animations[0]).setDuration(10).play();
  scene.add(result.scene);
});

// 帧率动画
function renderScence() {
  const delta = clock.getDelta();
  // 告诉混合器本次渲染和上次渲染动画的时间差，使动画更流畅
  if (mixer) {
    mixer.update(delta);
  }
  trackballControls.update(clock);
  requestAnimationFrame(renderScence);
  renderer.render(scene, camera);
}
renderScence();
```

## 变形目标创建动画

```js
// 我们在前边使用了自带动画的模型，因此可以直接加载模型并播放动画。
// 接下来，我们将使用morphAttributes手动来形变一个立方体。
// 该方式可以指定变形对象，然后我们可以过渡的从本体变形为目标形态。
// 将立方体的尺寸从 （2,2,2） 变为 （2,20,2）。

// 创建立方体
const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
const cubeMaterial = new THREE.MeshLambertMaterial({
  color: 0xff0000,
});
// 存储了几何体 morphTargets(变形目标) 的细节信息
cubeGeometry.morphAttributes.position = [];

// 形变目标1：尺寸为 2,20,2 的立方体
const cubeGeometry1 = new THREE.BoxGeometry(2, 20, 2);

// 赋值形变目标数组
cubeGeometry.morphAttributes.position[0] = cubeGeometry1.attributes.position;

const meshCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
scene.add(meshCube);

// 帧率动画
let index = 0;
let flag = true;
function renderScence() {
  if (flag) {
    index += 0.01;
    if (index > 1) {
      flag = false;
    }
  }
  if (!flag) {
    index -= 0.01;
    if (index <= 0) {
      flag = true;
    }
  }
  //（值一般在0-1范围内）的数组，指定应用了多少变形
  meshCube.morphTargetInfluences[0] = index;
  trackballControls.update(clock);
  requestAnimationFrame(renderScence);
  renderer.render(scene, camera);
}
renderScence();
```

## 帧动画 KeyframeTrack

```js
// name：关键帧轨道(KeyframeTrack)的标识符
// times：关键帧的时间数组, 被内部转化为Float32Array
// values：与时间数组中的时间点相关的值组成的数组, 被内部转化为Float32Array
// interpolation：使用的插值类型（离散的，线性，平滑），默认是InterpolateLinear线性，是一个常量。详情请见动画常量（Animation Constants）
// 例如：让一个几何体cubeGeometry在10秒内从向量Vector3(0, 0, 0)平滑过渡到Vector3(100, 0, 0)，那么可以通过KeyframeTrack来创建帧动画对象。

// 创建立方体
const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
const cubeMaterial = new THREE.MeshLambertMaterial({
  color: 0xff0000,
});
const meshCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
meshCube.name = 'CUBE';
scene.add(meshCube);

const times = [0, 10]; // 时间序列
const values = [0, 0, 0, 40, 0, 0]; // 过渡的值

// 0 - 10 秒内的位置变化
const posKeyFramTrack = new THREE.KeyframeTrack('.position', times, values);

// 通过THREE.AnimationClip对象对动画进行剪辑
// name, 持续时间, KeyframeTrack<>
const trackArr = [posKeyFramTrack];
const clip = new THREE.AnimationClip('CUBE-ANUMATION', 10, trackArr);

// 通过THREE.AnimationMixer混合器，通过KeyframeTrack以及剪辑器AnimationClip对象，
// 仅仅构成动画的数据基础，实际的动画播放需要通过AnimationMixer来控制，AnimationMixer就想一个动画控制台，
// 它可以同时控制多个动画，以及合并它们
const mixer = new THREE.AnimationMixer(meshCube);
const action = mixer.clipAction(clip);

// 通过 action 控制动画播放
action.timeScale = 5; // 调整播放速度 默认1
// 设置动画循环
// 默认值有：
// THREE.LoopOnce - 只执行一次
// THREE.LoopRepeat - 重复次数为repetitions的值, 且每次循环结束时候将回到起始动作开始下一次循环。
// THREE.LoopPingPong - 重复次数为repetitions的值, 且像乒乓球一样在起始点与结束点之间来回循环。
action.setLoop(THREE.LoopPingPong).play();

// 事件
// 可以通过给AnimationMixer播放器添加loop和finished事件来获取动画一个循环一个动画结束时的回调
mixer.addEventListener('loop', function (e) {
  console.log('帧动画循环回调：', e);
});
mixer.addEventListener('finished', function (e) {
  console.log('帧动画结束回调：', e);
});

// 帧率动画
function renderScence() {
  trackballControls.update(clock);
  mixer.update(clock.getDelta());
  requestAnimationFrame(renderScence);
  renderer.render(scene, camera);
}
renderScence();
```
