## Three.js 几何体的组合与合并和外部模型的加载

```js
// 今天，我们开启新的知识点，用一种全新的方式来创建高级几何体和网格：

// 组合和合并
// 从外部加载
// 学完本章知识点后，你将拥有以下技能：

// 你可以分组创建网格，更加方便有效的维护几何体。
// 你可以合并网格，提高渲染效率。
// 你可以加载外部更加炫酷的几何模型。
```

## 1. 几何体对象的组合

```js
// 当你创建多个网格对象时，你可以用 THREE.Group将它们放到一个组中进行管理。
// 当几何体被放置到组中时，你可以对组进行旋转、平移、缩放操作，这样，组中的所有对象会同时发生变化！
// 但是请注意，旋转时，旋转中心会是组的中心点。
// 当然，你也可以对组中单独的某个对象进行操作，但是需要注意的是，所有定位、旋转、变形，都是相对于父对象的。
// 如下，我们创建了一个组，组的中心点默认为（0, 0, 0），组中有一个球体和一个正方体，球体相对组中心点距离为-20，我们让这个组围绕y轴旋转，就是如上效果了。

function createMesh(geom) {
  // assign two materials
  const meshMaterial = new THREE.MeshNormalMaterial();
  meshMaterial.side = THREE.DoubleSide;
  const wireFrameMat = new THREE.MeshBasicMaterial({
    transparency: true,
    opacity: 0.5,
    wireframeLinewidth: 0.5,
  });
  wireFrameMat.wireframe = true;
  // create a multimaterial
  const mesh = SceneUtils.createMultiMaterialObject(geom, [
    meshMaterial,
    wireFrameMat,
  ]);
  return mesh;
}
const sphereGeometry = new THREE.SphereGeometry(5, 10, 10);
const cubeGeometry = new THREE.BoxGeometry(6, 6, 6);
const sphere = createMesh(sphereGeometry);
sphere.position.x = -20;
const cube = createMesh(cubeGeometry);
const group = new THREE.Group();
group.add(sphere);
group.add(cube);
scene.add(group);

// 帧率动画
// 动画
function renderScence() {
  trackballControls.update(clock);
  requestAnimationFrame(renderScence);
  group.rotation.y += 0.04;
  renderer.render(scene, camera);
}
renderScence();
```

## 2. 多个网格合并成一个网格

```js
// 多数情况下，我上边学的 组，可以管理大量网格。但是当对象特别多时，性能就会到达瓶颈。

// 因此，我们可以使用网格合并的方式，来提高性能。但是有个缺陷，合并后的网格就没法操作单个网格进行旋转、移动操作了。

// 我们可以使用 mergeBufferGeometries 来实现多个mesh合并为一个mesh，且可以使用多个Material。

// 如下，我们将一个球体和一个正方体合并：

 import { mergeBufferGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils'
  ...
  const meshMaterial = new THREE.MeshNormalMaterial()
  const cubeGeometry1 = new THREE.BoxGeometry(6, 6, 6)
  const cubeGeometry2 = new THREE.SphereGeometry(4, 20, 20)
  let geometryArray = [cubeGeometry1, cubeGeometry2] // 需要合并的模型数组
  let materialArray = [meshMaterial, meshMaterial] // 材质数组，对应模型下标
  // 合并模型
  let merged = mergeBufferGeometries(geometryArray, true)
  let mergeMesh = new THREE.Mesh(merged, materialArray)
  scene.add(mergeMesh)
```

```js
// 还有一种合并网格的方式，非常的灵活，我们可以在编码时改变几何体的位置。

const material = new THREE.MeshNormalMaterial({ color: '#ff0000' });
function addCube() {
  var geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
  var mesh = new THREE.Mesh(geometry, material);
  mesh.position.x = Math.random() * 4 - 2;
  mesh.position.y = Math.random() * 4 - 2;
  mesh.position.z = Math.random() * 4 + 2;
  return mesh;
}
const geos = [];
for (let i = 0; i < 20; i++) {
  const obj = addCube();
  obj.updateMatrix(); // 更新投影矩阵，不更新各mesh位置会不正确
  // 更新后的矩阵，重新转换为几何体，此时，几何体位置才正确
  const newGeometry = obj.geometry.applyMatrix4(obj.matrix);
  geos.push(newGeometry);
}
const bufferGeometry = mergeBufferGeometries(geos);
scene.add(new THREE.Mesh(bufferGeometry, material));
```

## 从外部资源加载几何体

```js
// three.js可以读取几种三维文本文件格式，并从中导出几何体网格，支持的文件格式如下：

// JSON	Three.js自己的JSON文件格式，你可以用它来声明你的几何体和场景，尽管它不正式，但是非常方便你去复用复杂的场景和几何体。
// OBJ或MTL	OBJ是一种简单的三维文件格式，由Wavefront Technologies创建。它是使用最广泛的三维文件格式，用来定义对象的几何体。
// MTL文件常同OBJ文件一起使用。在一个MTL文件中，用OBJ文件定义对象的材质 。Three.js还有一个可定制的OBJ导出器，叫作OBJExporter.js，可以用来将Three.js中的模型导出到一个OBJ文件。
// Collada	Collada是一种用基于XML的格式定义的数字内容的格式，也是一种被广泛使用的格式，差不多三维软件和渲染引擎都支持这种格式。
// STL	STL是STereoLithphy （立体成型术） 的缩写，广泛用于快速成型。如三维打印机的模型文件通常是STL文件。Three.js还有一个可定制的STL导出器，叫作STLExporter.js，可以用来将Three.js中的模型导出到一个STL文件。
// CTM	CTM是由openCTM一种文件格式，可以用来压缩格式存储三维网格的三角形面。
// VTK	VTK是由Visualization Toolkit创建一种文件格式，用来指定顶点和面。
// VYK有两种格式：二进制和基于文本的ASCII。three.js只基于ASCII格式。
// AWD	种用于三维场景的二进制格式，通常与http://away3d.com 引擎一起使用。这个加载程序不支持压缩的AWD文件。
// Assimp	Open asset import library （也称为 Assimp ） 是一种导入各种三维模型格式的标准方法。
// VRML	VRML是Virtual Reality Modeling Language的缩写，这是一种基于文本的格式，允许定义三维对象和世界。
// Babylon	是一个三维JavaScript游戏库，它以自己内部格式存储模型。
```

```js
// PDB	由Protein Data bank（蛋白质数据银行）创建，用于定义蛋白质的形状。
// PLY	这种格式的全称是多边形（Polygon）文件格式，通常用来保存三维扫描仪的信息。
// TDS	Autodesk 3DS 格式。
// 3MF	3MF是3D打印的标准格式。
// AMF	AMF是另一种3D打印的标准格式，但是目前已停止开发。
// PlayCanvas	PlayCanvas是一款基于WebGL的开源游戏引擎，three.js可以加载基于该引擎的模型并在场景中使用。
// Draco	Draco格式可以高效的保存几何体和点云。
// PRWM	PRWM 全称 Packed Raw WenGL Model (WebGL 模型原始数据包)。这是一种专注于高效存储和解析3D几何体的格式。
// GCODE	GCODE是计算机程序与3D打印机和CNC机器通信的标准模式之一。打印模型时，计算机可以想3D打印机发送GCODE命令来控制打印机。
// NRRD	NRRD是一种存储体素数据的文件格式。它可以用于保存CT扫描数据。
// SVG	SVG是一种矢量图形的标准格式，它可以被three.js加载器加载成THREE.Path对象。该对象可以被拉伸成为3D几何体，或者也可以被当作2D几何体来渲染。
```

## 3.1 以 Three.js 的 JSON 格式保存和加载

```js
// 你可以在两种情形下使用three.js的JSON文件格式：用它来保存和加载单个THREE.Mesh，或者用它来保存和加载整个场景。

// 保存THREE.Mesh为JSON数据

// 我们可以用 mesh.toJSON() 来获取THREE.Mesh的JSON数据。

const meshMaterial = new THREE.MeshNormalMaterial();
const cubeGeometry = new THREE.BoxGeometry(6, 6, 6);
const mesh = new THREE.Mesh(cubeGeometry, meshMaterial);
scene.add(mesh);
const meshJSON = mesh.toJSON();
console.log(meshJSON);
```

- 加载 JSON 数据为 THREE.Mesh

```js
// 将JSON数据加载为网格，只需要THREE.ObjectLoader加载这个数据即可。
// 如果你想加载外部文件，可以使用 newTHREE.ObjectLoader().load(url)

const loader = new THREE.ObjectLoader();
const loadMesh = loader.parse(meshJSON);
loadMesh.position.x = -10;
scene.add(loadMesh);
```

- 保存和加载场景

```js
// 保存场景

// scene.toJson()
// 加载场景

// const loader = new THREE.ObjectLoader()
// loader.parse(sceneJSON)
// 清空场景

// scene.clear()
```

## 3.2 使用 Blender

```js
// 很多三维软件都可以创建复杂的网格，其中有一款开源软件叫 Blender，three.js有一个Blender导出器，可以在此软件中直接将文件导出为three.js识别的JSON格式，在three.js中使用THREE.JSONLoader导入展示模型。

// 因为新版Three.js不再支持THREE.JSONLoader，所以这里不做讲解，我们大多用的还是加载OBJ等模型，大家知道与这么个事就行，万一用到了，可以降级引擎版本，找一下THREE.JSONLoader的用法，很简单的。
```

## 3.3 OBJ 和 MTL 格式

```js
// OBJ和MTL是相互配合的两种格式，经常一起使用。OBJ定义几何体，而MTL用来定义所用的材质。OBJ和MTL都是文本格式。

// 使用 OBJLoader 加载OBJ模型：
 import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader'
  ...
  // 加载OBJ模型
  const loader = new OBJLoader()
  const material = new THREE.MeshNormalMaterial()
  loader.load('../img/pinecone/pinecone.obj', obj => {
    let object = obj
    object.scale.set(30,30,30)
    object.children.forEach(child => {
      child.material = material
    })
    object.rotation.x = 1
    object.rotation.y = 0.3
    scene.add(object)
  })
```

## 使用 OBJLoader 和 MTLLoader 加载 OBJ 模型并直接赋予材质：

```js
// 使用之前，我们需要注意，mtl文件需要用相对路径引用纹理，而不是绝对路径。

// 我们使用MTLLoader加载mtl材质文件，通过setMaterials方法将材质指定给OBJLoader 对象，然后用OBJLoader 加载模型。

import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader'
  import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader'
  ...
  const mtlloader = new MTLLoader()
  mtlloader.setPath('../img/butterfly/')
  mtlloader.load('butterfly.mtl', material => {
    const loader = new OBJLoader()
    loader.setMaterials(material)
    loader.load('../img/butterfly/butterfly.obj', obj => {
      obj.scale.set(100, 100, 100)
      // 修复蝴蝶翅膀不显示的问题
      obj.children[4].material.opacity = 0.9
      obj.children[4].depthTest = false
      obj.children[4].side = THREE.DoubleSide

      obj.children[5].material.opacity = 0.9
      obj.children[5].depthTest = false
      obj.children[5].side = THREE.DoubleSide
      scene.add(obj)
    })
  })
```

## 3.4 加载 Collada 模型

```js
// Collada模型（扩展名为.dae）是一种非常通用的、用来定义场景和模型以及动画的文件格式。Collada模型中不仅定义了几何体，也定义了材质，甚至还可以定义光源。

// 加载Collada模型的步骤和OBJ MTL几乎一样，首先需要加载器：

import { ColladaLoader } from 'three/examples/jsm/loaders/ColladaLoader';
const loader = new ColladaLoader();
loader.load('../img/medieval/Medieval_building.DAE', (result) => {
  // 该组用来重新存放模型网格，方便我们加入到自己的场景
  const meshGroup = new THREE.Group();
  // 获取模型中的场景数据
  const scenceGroup = result.scene;
  // 遍历模型中的对象（scenceGroup.children中包含了网格、灯光等对象）
  scenceGroup.children.forEach((child) => {
    // 剔除模型中的非网格数据，并对网格开启阴影效果
    if (child instanceof THREE.Mesh) {
      child.receiveShadow = true;
      child.castShadow = true;
      meshGroup.add(child);
    } else {
      scenceGroup.remove(child);
    }
  });
  meshGroup.rotation.x = (-90 * Math.PI) / 180; // 让模型沿Z轴旋转负90度
  meshGroup.scale.set(6, 6, 6);
  scene.add(meshGroup);
});
```

## 3.5 加载其他格式的模型

```js
// 加载glb

// 推荐大家一个好玩的东西，win10系统自带 3D查看器，里边有好多好玩的模型，大家导出后就是 .glb 格式，我们可以用three.js加载到浏览器观看。

import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'
...
const loader = new GLTFLoader()
loader.load('../img/Rampaging T-Rex.glb', result => {
  scene.add(result.scene)
})
```

```js
// 加载stl
// 该格式的模型会被加载器解析为一个BufferGeometry，我们按照geometry加载它即可。

import { STLLoader } from 'three/examples/jsm/loaders/STLLoader'
...
function createMesh(geom) {
    // assign two materials
    const meshMaterial = new THREE.MeshNormalMaterial()
    meshMaterial.side = THREE.DoubleSide
    const wireFrameMat = new THREE.MeshBasicMaterial({
      'wireframeLinewidth': 0.5,
      'wireframe': true
    })
    wireFrameMat.wireframe = true
    // create a multimaterial
    const mesh = SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat])
    return mesh
  }
const loader = new STLLoader()
  loader.load('../img/SolidHead_2_lowPoly_42k.stl', result => {
    const bufferGeometry = result
    const mesh = createMesh(bufferGeometry)
    mesh.scale.set(0.2, 0.2, 0.2)
    mesh.rotation.x = -90 * Math.PI / 180
    mesh.translateX(-10)
    scene.add(mesh)
  })
```

```js
// 其它格式我们就不一一列举了，大家记住，加载完模型后，打印一下，看看加载器为我们返回了什么格式的数据，都返回了哪些对象，一般情况就是 灯光、场景、动画、网格 的各种组合，大家可以直接取geometry渲染成粒子，反正怎么用就尽情的发挥你的聪明才智吧，我们根据实际情况进行渲染即可~
```
