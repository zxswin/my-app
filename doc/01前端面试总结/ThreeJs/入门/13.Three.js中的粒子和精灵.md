## Three.js 中的粒子和精灵

```js
// 使用THREE.SpriteMaterial创建样式化例子。
// 使用THREE.Points创建一个粒子集合。
// 使用现有的几何创建一个THREE.Points对象。
// 让THREE.Points对象动起来。
// 使用纹理对每一个粒子进行样式化。
// 使用画布通过THREE.SpriteMaterial 对粒子进行样式化。
```

## 初识粒子

- 1.1 THREE.Sprite。

```js
// 我们可以使用THREE.Sprite来手工创建粒子，它需要传入唯一的参数 材质（THREE.SpriteMaterial或者THREE.SpriteCanvasMaterial）。

// THREE.Sprite与THREE.Mesh一样，都是THREE.Object3D的子类，所以说，THREE.Sprite可以使用THREE.Mesh所能使用的大部分属性，你可以用来定义其位置、缩放 等属性。

function createSprites() {
  for (let x = -15; x < 15; x++) {
    for (let y = -15; y < 15; y++) {
      const material = new THREE.SpriteMaterial({
        color: Math.random() * 0xffffff,
      });
      const sprite = new THREE.Sprite(material);
      sprite.position.set(x * 4, y * 4, 0);
      scene.add(sprite);
    }
  }
}
createSprites();
```

- 1.2 THREE.Points

```js
// 虽然，我们使用THREE.Sprite可以很容易创造粒子，但是当你创造大量的THREE.Sprite时，你会遇到严重的性能问题，因为每个THREE.Sprite对象都需要去管理。而此时，THREE.Points的用处就来了，我们只需要单个THREE.Points对象，就能统一管理大量粒子。

function createPoints() {
  const gemo = new THREE.BufferGeometry();
  const material = new THREE.PointsMaterial({
    size: 2,
    vertexColors: true,
    color: 0xffffff,
  });
  let veticsFloat32Array = [];
  let veticsColors = [];
  for (let x = -15; x < 15; x++) {
    for (let y = -15; y < 15; y++) {
      veticsFloat32Array.push(x * 4, y * 4, 0);
      // 生成随机颜色
      const randomColor = new THREE.Color(
        '#' + ((Math.random() * 0xffffff) << 0).toString(16)
      );
      veticsColors.push(randomColor.r, randomColor.g, randomColor.b);
    }
  }
  const vertices = new THREE.Float32BufferAttribute(veticsFloat32Array, 3);
  const colors = new THREE.Float32BufferAttribute(veticsColors, 3);
  gemo.attributes.position = vertices;
  gemo.attributes.color = colors;

  const cloud = new THREE.Points(gemo, material);
  scene.add(cloud);
}
createPoints();
```

```js
// 上边的案例，我们用到了THREE.PointsMaterial来设置材质，使用THREE.BufferGeometry来创建几何体（我们有时也会用THREE.BoxGeometry等，但是不常用，也不推荐用实体几何来创建粒子），然后组装到THREE.Points中。
```

```js
// THREE.PointsMaterial 对象所有可设置的属性如下：

// color	粒子系统所有粒子的颜色。
// map	可以在例子中应用某种材质，例如，粒子制作雪花效果，后边我将会讲到。
// size	指定粒子大小，默认1
// sizeAnnutation	如果该属性为false，那么所有粒子都将拥有相同尺寸，无论距离多远。如果true，粒子大小将取决于摄像机的远近。
// vertexColors	一般来说，THREE.Points中的粒子颜色都是相同的。如果该属性设置为THREE.VertexColors，并且几何体数组中的颜色也有值，那么会使用数组中定义的颜色值。默认THREE.NoColors
// opacity	定义粒子不透明底，默认1完全不透明，与transparent配合使用
// transparent	如果设置为true，那么opacity生效
// blending	指定粒子渲染时的融合程度
// fog	是否受场景中的雾化效果影响，默认true
```

## 2. 使用 HTML5 Canvas 样式化粒子

```js
// 在Three.js中，我们支持使用HTML5画布的方式来样式化粒子。你可以使用 THREE.CanvasRenderer和THREE.WebGLRenderer来使用Canvas样式化粒子。
```

- 2.1 使用 THREE.CanvasRenderer 来样式化粒子

```js
// 通过THREE.SpriteCanvasMaterial，你可以将Canvas画布的输出结果作为粒子的纹理。
// 这种材质是专门为THREE.CanvasRenderer创造的，而且你只有使用该种渲染器才有效。

// THREE.SpriteCanvasMaterial相关属性：

// color	指定粒子颜色。根据指定的混合模式，影响画布图片的颜色。
// program	指定一个函数，以canvas上下文为参数。当粒子渲染时，该函数会被调用。输出结果将被渲染为粒子。
// opacity	定义粒子不透明底，默认1完全不透明，与transparent配合使用
// transparent	如果设置为true，那么opacity生效
// blending	指定粒子渲染时的融合模式
// rotation	该属性允许你旋转画布的内容。通常需要将该属性设置为PI，以正确对齐画布的内容。请注意，该属性不能传入到材质的构造函数，而是需要明确的设置。
```

```js
// 请注意，新版three.js将不再支持THREE.SpriteCanvasMaterial材质以及THREE.CanvasRenderer渲染器，我们重点还是要掌握下一个方式 —— WebGLRenderer。
function createCanvasSprites () {
    const material = new THREE.SpriteCanvasMaterial({
      'program': cxt => {
        // 此处写入canvas代码
        cxt.fillStyle = 'red'
        ...
        cxt.beginPath()
        cxt.fill()
      }
    })
    material.rotation = Math.PI
    const range = 500
    for (let i = 0; i < 1000; i++) {
      const sprite = new THREE.Sprite(material)
      sprite.position = new THREE.Vector3(Math.random() * range - range / 2, Math.random() * range - range / 2, Math.random() * range - range / 2)
      sprite.scale.set(0.1, 0.1, 0.1)
      scene.add(sprite)
    }
  }
```

- 2.2 在 WebGLRenderer 中使用 HTML5 画布

```js
// 如果我们想要在WebGLRenderer中使用Canvas画布，可以采用两种不同的方式，可以使用 THREE.PointsMaterial创建THREE.Points对象，或者使用THREE.Sprite和THREE.SpriteMaterial的map属性。

function createCanvasSprites() {
  const createGhostTexture = () => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    // the body
    ctx.translate(-81, -84);

    ctx.fillStyle = 'orange';
    ctx.beginPath();
    ctx.moveTo(83, 116);
    ctx.lineTo(83, 102);
    ctx.bezierCurveTo(83, 94, 89, 88, 97, 88);
    ctx.bezierCurveTo(105, 88, 111, 94, 111, 102);
    ctx.lineTo(111, 116);
    ctx.lineTo(106.333, 111.333);
    ctx.lineTo(101.666, 116);
    ctx.lineTo(97, 111.333);
    ctx.lineTo(92.333, 116);
    ctx.lineTo(87.666, 111.333);
    ctx.lineTo(83, 116);
    ctx.fill();

    // the eyes
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.moveTo(91, 96);
    ctx.bezierCurveTo(88, 96, 87, 99, 87, 101);
    ctx.bezierCurveTo(87, 103, 88, 106, 91, 106);
    ctx.bezierCurveTo(94, 106, 95, 103, 95, 101);
    ctx.bezierCurveTo(95, 99, 94, 96, 91, 96);
    ctx.moveTo(103, 96);
    ctx.bezierCurveTo(100, 96, 99, 99, 99, 101);
    ctx.bezierCurveTo(99, 103, 100, 106, 103, 106);
    ctx.bezierCurveTo(106, 106, 107, 103, 107, 101);
    ctx.bezierCurveTo(107, 99, 106, 96, 103, 96);
    ctx.fill();

    // the pupils
    ctx.fillStyle = 'blue';
    ctx.beginPath();
    ctx.arc(101, 102, 2, 0, Math.PI * 2, true);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(89, 102, 2, 0, Math.PI * 2, true);
    ctx.fill();

    const texture = new THREE.Texture(canvas);
    texture.needsUpdate = true;
    return texture;
  };
  const createCloud = (size, transparent, opacity, sizeAttenuation, color) => {
    const geom = new THREE.BufferGeometry();
    const material = new THREE.PointsMaterial({
      size: size,
      transparent: transparent,
      opacity: opacity,
      map: createGhostTexture(),
      sizeAttenuation: sizeAttenuation,
      color: color,
    });
    let veticsFloat32Array = [];
    const range = 500;
    for (let i = 0; i < 1000; i++) {
      const particle = new THREE.Vector3(
        Math.random() * range - range / 2,
        Math.random() * range - range / 2,
        Math.random() * range - range / 2
      );
      veticsFloat32Array.push(particle.x, particle.y, particle.z);
    }
    const vertices = new THREE.Float32BufferAttribute(veticsFloat32Array, 3);
    geom.attributes.position = vertices;
    const cloud = new THREE.Points(geom, material);
    scene.add(cloud);
  };
  createCloud(20, true, 0.6, true, 0xffffff);
}
createCanvasSprites();
```

## 3. 使用纹理样式化粒子

```js
// 使用图像样式化粒子还有一种更为直接的方法，你可以使用 THREE.TextureLoader().load()函数将图像加载为THREE.Texture对象，然后将THREE.Texture分配给材质的map属性。

/* 纹理美化粒子 */
// 加载纹理图片
const texture = new THREE.TextureLoader().load(
  '../img/assets/particles/raindrop-3.png'
);
// 定义材质
const material = new THREE.PointsMaterial({
  size: 20,
  transparent: true,
  opacity: 0.6,
  map: texture,
  sizeAttenuation: true,
  color: 0xffffff,
  // 该融合模式表示，在画新像素时背景像素的颜色会被添加到新像素上。
  // 在本案例中，意味着黑色背景不会被加载出来，我们也可以把纹理背景定义为透明色，也会有类似效果。
  blending: THREE.AdditiveBlending,
  depthTest: false, // 解决贴图黑边的问题
  depthWrite: false, // 保证粒子之间不会互相影响
});
// 定义几何体
const geom = new THREE.BufferGeometry();
let veticsFloat32Array = [];
const range = 500;
for (let i = 0; i < 1000; i++) {
  const particle = new THREE.Vector3(
    Math.random() * range - range / 2,
    Math.random() * range - range / 2,
    Math.random() * range - range / 2
  );
  veticsFloat32Array.push(...particle.toArray());
}
// 初始化渲染粒子雨滴
function initRain(vetics) {
  const vertices = new THREE.Float32BufferAttribute(vetics, 3);
  geom.attributes.position = vertices;
  const cloud = new THREE.Points(geom, material);
  scene.add(cloud);
  return cloud;
}

// 帧率动画
const speed = 1;
let cloud = null;
// 初始化雨滴
cloud = initRain(veticsFloat32Array);
// 动画
function renderScence() {
  trackballControls.update(clock);
  requestAnimationFrame(renderScence);
  if (cloud) {
    scene.remove(cloud);
  }
  let rainPositionArray = Array.from(cloud.geometry.attributes.position.array);
  for (let i = 0; i < rainPositionArray.length; i += 3) {
    rainPositionArray[i + 1] -= speed;
    if (rainPositionArray[i + 1] < 0) {
      rainPositionArray[i + 1] = Math.random() * range - range / 2;
    }
  }
  cloud = initRain(rainPositionArray);
  // console.log(vs)
  renderer.render(scene, camera);
}
renderScence();
```

## 4. 使用精灵贴图

```js
// 我们在 THREE.WebGLRender中使用一个THREE.Sprite对象渲染单个粒子。这些精灵在三维世界对的某个地方，方向永远面对着摄像机，并且它们的尺寸取决于距离摄像机的远近。本章，我们将展示另一种使用THREE.Spriite对象的方法。我们将展示如何使用THREE.Sprite和额外的THREE.OrthographicCamera为你的三维内容创建一个类似于平视显示器的层。我们还会展示如何使用精灵贴图选择THREE.Sprite对象的图像。

import * as THREE from 'three'
// 导入dat.gui
import { GUI } from '../libs/data.gui'
...
const getTexture = () => {
    return new THREE.TextureLoader().load('../img/assets/particles/sprite-sheet.png')
  }
  function createSprite (size, transparent, opacity, color, spriteNumber) {
    const spriteMaterial = new THREE.SpriteMaterial({
      'opacity': opacity,
      'color': color,
      'transparent': transparent,
      'map': getTexture(),
      'blending': THREE.AdditiveBlending,
      'depthTest': false
    })
    // 我们加载的是一行五张的sprite纹理图片
    spriteMaterial.map.offset = new THREE.Vector2(0.2 * spriteNumber, 0)
    spriteMaterial.map.repeat = new THREE.Vector2(1 / 5, 1)

    const sprite = new THREE.Sprite(spriteMaterial)
    sprite.scale.set(size, size, size)
    sprite.name = 'sprite-obj'
    // sprite.position.set(100, 50, -10)
    scene.add(sprite)
    return sprite
  }

  // 保存希望被GUI改变的属性
  let controls = {
    'spriteNumber': 0
  }
  // 实例化GUI
  let sprite = null
  const gui = new GUI()
  const contSpriteNumber = gui.add(controls, 'spriteNumber', [0, 1, 2, 3, 4])
  contSpriteNumber.listen()
  contSpriteNumber.onChange(() => {
    if (sprite) {
      scene.remove(sprite)
    }
    sprite = createSprite(4, true, 0.8, 0xffffff, controls.spriteNumber)
  })
  sprite = createSprite(4, true, 0.8, 0xffffff, 0)
```

```js
import * as THREE from 'three'
// 导入dat.gui
import { GUI } from '../libs/data.gui'
...
const getTexture = () => {
    return new THREE.TextureLoader().load('../img/assets/particles/sprite-sheet.png')
  }
  function createSprite (size, transparent, opacity, color, spriteNumber) {
    const spriteMaterial = new THREE.SpriteMaterial({
      'opacity': opacity,
      'color': color,
      'transparent': transparent,
      'map': getTexture(),
      'blending': THREE.AdditiveBlending,
      'depthTest': false
    })
    // 我们加载的是一行五张的sprite纹理图片
    spriteMaterial.map.offset = new THREE.Vector2(0.2 * spriteNumber, 0)
    spriteMaterial.map.repeat = new THREE.Vector2(1 / 5, 1)

    const sprite = new THREE.Sprite(spriteMaterial)
    sprite.scale.set(size, size, size)
    sprite.name = 'sprite-obj'
    // sprite.position.set(100, 50, -10)
    scene.add(sprite)
    return sprite
  }

  // 保存希望被GUI改变的属性
  let controls = {
    'spriteNumber': 0
  }
  // 实例化GUI
  let sprite = null
  const gui = new GUI()
  const contSpriteNumber = gui.add(controls, 'spriteNumber', [0, 1, 2, 3, 4])
  contSpriteNumber.listen()
  contSpriteNumber.onChange(() => {
    if (sprite) {
      scene.remove(sprite)
    }
    sprite = createSprite(4, true, 0.8, 0xffffff, controls.spriteNumber)
  })
  sprite = createSprite(4, true, 0.8, 0xffffff, 0)
```

## 5. 从高级几何体创建 THREE.Points

```js
// 如果我们提供一个复杂的几何体，我们可以基于这个几何体的顶点创建一个THREE.Points对象。
// 接下来，我们创建一个立方体，然后给它转换为粒子，并用canvas做一个发光的纹理材质。

// 创建canvas纹理
function generateSprite() {
  const canvas = document.createElement('canvas');
  canvas.width = 16;
  canvas.height = 16;

  const context = canvas.getContext('2d');
  const gradient = context.createRadialGradient(
    canvas.width / 2,
    canvas.height / 2,
    0,
    canvas.width / 2,
    canvas.height / 2,
    canvas.width / 2
  );
  gradient.addColorStop(0, 'rgba(255,255,255,1)');
  gradient.addColorStop(0.2, 'rgba(0,255,255,1)');
  gradient.addColorStop(0.4, 'rgba(0,0,64,1)');
  gradient.addColorStop(1, 'rgba(0,0,0,1)');

  context.fillStyle = gradient;
  context.fillRect(0, 0, canvas.width, canvas.height);

  const texture = new THREE.Texture(canvas);
  texture.needsUpdate = true;
  return texture;
}
// 创建立方体
const boxGeometry = new THREE.BoxGeometry(10, 10, 10, 6, 6, 6);
// 创建粒子材质
const material = new THREE.PointsMaterial({
  color: 0xffffff,
  size: 3,
  transparent: true,
  blending: THREE.AdditiveBlending,
  map: generateSprite(),
  depthWrite: false,
});
// 创建粒子
const cloud = new THREE.Points(boxGeometry, material);
scene.add(cloud);
```
