## Three.js 中的高级几何

```js
// 使用高级几何体，例如：THREE.ConvexGeometry、THREE.LatheGeometry和THREE.TubeGeometry。
// 如何使用THREE.ExtrudeGeometry从二维图形创建三维图形。
// 使用THREE.ParamtericGeometry通过基础方程创建自定义几何图形。
// 使用THREE.TextGeometry创建三维文字效果。
```

## 1. THREE.ConvexGeometry

```js
// 我们正在空间中随机创建若干个点，传入THREE.ConvexGeometry中，那么它就会根据这些点，生成一个三维图形，这个三维图形，就是这些点能够生成的最小的三维图形。

import { ConvexGeometry } from 'three/examples/jsm/geometries/ConvexGeometry';
// 随机生成20个点
function generatePoints() {
  const points = [];
  for (let i = 0; i < 20; i++) {
    const x = -15 + Math.round(Math.random() * 30);
    const y = -15 + Math.round(Math.random() * 30);
    const z = -15 + Math.round(Math.random() * 30);
    points.push(new THREE.Vector3(x, y, z));
  }
  const spGroup = new THREE.Object3D();
  const material = new THREE.MeshBasicMaterial({
    color: 'red', // 材质颜色
  });
  points.forEach((point) => {
    const spGeom = new THREE.SphereGeometry(0.2);
    const spMesh = new THREE.Mesh(spGeom, material);
    spMesh.position.copy(point);
    spGroup.add(spMesh);
  });
  scene.add(spGroup);
  return points;
}
const points = generatePoints();
// 使用 THREE.ConvexGeometry 生成几何体
const convexMaterial = new THREE.MeshLambertMaterial({
  color: 'blue', // 材质颜色
});
const convexGeometry = new ConvexGeometry(points);
const convexMesh = new THREE.Mesh(convexGeometry, convexMaterial);
scene.add(convexMesh);
```

## 2. THREE.LatheGeometry

```js
// THREE.LatheGeometry允许你从一条光滑的曲线创建图形。这条曲线由多个点定义，我们称之为“样曲线”，并绕着物体的中心Z轴旋转，你把曲线勾勒成什么形状，那么THREE.LatheGeometry就可以生成什么样的面。

// THREE.LatheGeometry支持以下属性：

// points	是	构成样曲线的点集合。
// segments	否	创建图形时使用的分段数目，越高越光滑。
// phiStart	否	图形从圆的何处开始。范围 0-2 * PI。
// phiLength	否	图形创建的完整程度，默认为 2 * PI

// 我们先生成一个由60个点生成的样曲线：
function generatePoints() {
  const points = [];
  const count = 60;
  const height = 5;
  for (let i = 0; i < count; i++) {
    points.push(
      new THREE.Vector3(
        (Math.sin(i * 0.2) + Math.cos(i * 0.3)) * height + 12,
        i - count + count / 2,
        0
      )
    );
  }
  const spGroup = new THREE.Object3D();
  const material = new THREE.MeshBasicMaterial({
    color: 'red', // 材质颜色
  });
  points.forEach((point) => {
    const spGeom = new THREE.SphereGeometry(0.2);
    const spMesh = new THREE.Mesh(spGeom, material);
    spMesh.position.copy(point);
    spGroup.add(spMesh);
  });
  scene.add(spGroup);
  return points;
}
const points = generatePoints();
const latheGeomtry = new THREE.LatheGeometry(points, 30);
//  实例化一个法向量的材质
const meshMaterial = new THREE.MeshNormalMaterial();
meshMaterial.side = THREE.DoubleSide; //设置两面都可见
const wireFrameMat = new THREE.MeshBasicMaterial();
wireFrameMat.wireframe = true; //把材质渲染成线框

// 将两种材质都赋给几何体
const mesh = SceneUtils.createMultiMaterialObject(latheGeomtry, [
  meshMaterial,
  wireFrameMat,
]);
scene.add(mesh);
```

## 3. THREE.ExtrudeGeometry

```js
// 通过 THREE.ExtrudeGeometry 你可以从一个二维图形创建出一个三维图形。

// 在前边（十二、Three.js中的常用几何体），我们学习过用THREE.Shape()创建一个二维图形，THREE.ExtrudeGeometry同样可以通过THREE.Shape()将二维图形改变成三维图形。

// 用法很简单：

// const gemo = new THREE.ExtrudeGeometry(shapes, option)
```

```js
// amount	否	该属性指定图形可以拉多高（深度）。默认值为100
// bevelThickness	否	该属性指定斜角的深度。斜角是前后面和拉伸体之间的倒角。该值定义斜角进入图形的深度。默认值为6
// bevelSize	否	该属性指定斜角的高度。这个高度将被加到图形的正常高度上。默认值为bevelThickness - 2
// bevelSegments	否	该属性定义斜角的分段数。分段数越多，曲线越平滑。默认值为3
// bevelEnabled	否	如果这个属性设为true，就会有斜角。默认值为true
// curveSegments	否	该属性指定拉伸体沿深度方向分成多少段。默认值为1。值越大，单个面越多
// steps	否	该属性指定拉伸体沿深度方向分成多少段。默认值为1。值越大，单个面越多。
// extrudePath	否	该属性指定图形沿着什么路径（THREE.CurvePath）拉伸。如果没有指定，则图形沿着z轴拉伸
// uvGenerator	否	当你给材质使用纹理时，UV映射确定纹理的哪一部分用于特定的面。使用UVGenerator属性，你可以传入自己的对象，该对象将为传入的图形创建的面创建UV设置。如果没有指定，则使用THREE.ExtrudeGeometry.WorldUVGenerator

// 自定义二维图形
function drawShape() {
  // create a basic shape
  const shape = new THREE.Shape();

  // startpoint
  shape.moveTo(10, 10);

  // straight line upwards
  shape.lineTo(10, 40);

  // the top of the figure, curve to the right
  shape.bezierCurveTo(15, 25, 25, 25, 30, 40);

  // spline back down
  shape.splineThru([
    new THREE.Vector2(32, 30),
    new THREE.Vector2(28, 20),
    new THREE.Vector2(30, 10),
  ]);

  // curve at the bottom
  shape.quadraticCurveTo(20, 15, 10, 10);

  // add 'eye' hole one
  const hole1 = new THREE.Path();
  hole1.absellipse(16, 24, 2, 3, 0, Math.PI * 2, true);
  shape.holes.push(hole1);

  // add 'eye hole 2'
  const hole2 = new THREE.Path();
  hole2.absellipse(23, 24, 2, 3, 0, Math.PI * 2, true);
  shape.holes.push(hole2);

  // add 'mouth'
  const hole3 = new THREE.Path();
  hole3.absarc(20, 16, 2, 0, Math.PI, true);
  shape.holes.push(hole3);

  // return the shape
  return shape;
}
const extrudeGeometry = new THREE.ExtrudeGeometry(drawShape());
//  实例化一个法向量的材质
const meshMaterial = new THREE.MeshNormalMaterial({
  flatShading: true, // 方便我们看到每个面的颜色
  side: THREE.DoubleSide,
});
const mesh = new THREE.Mesh(extrudeGeometry, meshMaterial);
scene.add(mesh);
```

## 4. THREE.TubeGeometry

```js
// 该几何体可以实现沿着一条三维样条线拉伸出根管。

// 我们先创建一个三维样条线，和上边的案例一样。

// 然后借助THREE.TubeGeometry生成根管。

function generatePoints() {
  const points = [];
  const count = 20;
  for (let i = 0; i < count; i++) {
    points.push(new THREE.Vector3(Math.sin(i) + 12, i - count + count / 2, 0));
  }
  const spGroup = new THREE.Object3D();
  const material = new THREE.MeshBasicMaterial({
    color: 'red', // 材质颜色
  });
  points.forEach((point) => {
    const spGeom = new THREE.SphereGeometry(0.2);
    const spMesh = new THREE.Mesh(spGeom, material);
    spMesh.position.copy(point);
    spGroup.add(spMesh);
  });
  scene.add(spGroup);
  return points;
}
const points = generatePoints();
const tubeGeometry = new THREE.TubeGeometry(
  new THREE.CatmullRomCurve3(points),
  20,
  1,
  20
);
const meshMaterial = new THREE.MeshNormalMaterial({
  flatShading: true, // 方便我们看到每个面的颜色
  side: THREE.DoubleSide,
});
const mesh = new THREE.Mesh(tubeGeometry, meshMaterial);
scene.add(mesh);
```

## 5. THREE.ParametricGeometry

```js
// THREE.ParametricGeometry可以让你创建基于等式的几何体。

// function	是	该属性为一个函数，该函数以u、v值作为参数定义每个顶点的位置。返回值为THREE.Vector3
// slices	是	该属性定义u值应该分成多少份
// stacks	是	该属性定义v值应该分成多少份

// 用法：
// const geometry = new THREE.ParametricGeometry(function, slices, stacks)
```

```js
// function 是一个回调函数，会循环去调用这个函数。函数中参数为 u, v。u和v的范围是0-1。例如，当我们要创建一个宽为width，高为height的基础平面，那么函数可以这样定义：

const planeFn = function (u, v, target) {
  const result = target || new THREE.Vector3();
  const x = u * 10;
  const y = 0;
  const z = v * 10;
  return result.set(x, y, z);
};

import { ParametricGeometry } from 'three/examples/jsm/geometries/ParametricGeometry';

const planeFn = function (u, v, target) {
  const result = target || new THREE.Vector3();
  const x = u * 10;
  const y = 0;
  const z = v * 10;
  return result.set(x, y, z);
};
const planeGeometry = new ParametricGeometry(planeFn, 10, 10);
const meshMaterial = new THREE.MeshNormalMaterial({
  flatShading: true, // 方便我们看到每个面的颜色
  side: THREE.DoubleSide,
});
const wireFrameMat = new THREE.MeshBasicMaterial();
wireFrameMat.wireframe = true; //把材质渲染成线框

// 将两种材质都赋给几何体
const mesh = SceneUtils.createMultiMaterialObject(planeGeometry, [
  meshMaterial,
  wireFrameMat,
]);
scene.add(mesh);
```

```js
const planeFn = function (u, v, target) {
  const result = target || new THREE.Vector3();
  const x = Math.sin(u) * 50;
  const z = Math.sin(v / 2) * 2 * 50;
  const y = (Math.sin(u * 4 * Math.PI) + Math.cos(v * 2 * Math.PI)) * 2.8;
  return result.set(x, y, z);
};
const planeGeometry = new ParametricGeometry(planeFn, 100, 100);
const meshMaterial = new THREE.MeshNormalMaterial({
  flatShading: true, // 方便我们看到每个面的颜色
  side: THREE.DoubleSide,
});
const wireFrameMat = new THREE.MeshBasicMaterial();
wireFrameMat.wireframe = true; //把材质渲染成线框

// 将两种材质都赋给几何体
const mesh = SceneUtils.createMultiMaterialObject(planeGeometry, [
  meshMaterial,
  wireFrameMat,
]);
scene.add(mesh);
```

## 6. 创建三维文本

```js
// 首先，我们需要用到THREE.FontLoader类加载字体，在调用THREE.FontLoader.load()方法时，除了提供字体名称外，还提供了一个回调函数，用于接收创建好的字体对象。

// 我们用THREE.TextGeometry(text, options)来创建文本对象，其需要传option配置项。
```

```js
// size	否	该属性指定文本的大小。默认值为100
// height	否	该属性指定拉伸的长度（深度）。默认值为50
// font	是	指定字体名称
// weight	否	该属性指定字体的粗细。可选值包括normal和bold。默认值为normal
// bevelThickness	否	该属性指定斜角的深度。斜角是前后面和拉伸体之间的倒角。该值定义斜角进入图形的深度。默认值为10。
// bevelSize	否	该属性指定斜角的高度。默认值为8
// bevelSegments	否	该属性定义斜角的分段数。分段数越多，斜角越平滑。默认值为3
// bevelEnabled	否	如果这个属性设置为true，就会有斜角。默认值为false
// curveSegments	否	该属性指定拉伸图形时曲线分成多少段。分段数越多，曲线越平滑。默认值为4
// steps	否	该属性指定拉伸体被分成多少段。默认值为1
// uvGenerato	否	当你给材质使用纹理时，UV映射确定纹理的哪一部分用于特定的面。使用uvGenerator属性，你可以传入自己的对象，该对象将为传入的图形创建的面创建UV设置。如果没有指定，则使用THREE.ExtrudeGeometry.WorldUVGenerator

import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry'
import { FontLoader } from 'three/examples/jsm/loaders/fontloader'
...
// 加载文字
  new FontLoader().load('../../../node_modules/three/examples/fonts/gentilis_bold.typeface.json', loadedFont => {
    const textGeometry = new TextGeometry('HELLO, THREE.JS', {
      'font': loadedFont,
      'size': 12,
      'height': 10
    })
    const meshMaterial = new THREE.MeshNormalMaterial({
      'flatShading': true, // 方便我们看到每个面的颜色
      'side': THREE.DoubleSide
    })
    const wireFrameMat = new THREE.MeshBasicMaterial()
    wireFrameMat.wireframe = true //把材质渲染成线框

    // 将两种材质都赋给几何体
    const mesh = SceneUtils.createMultiMaterialObject(textGeometry, [meshMaterial, wireFrameMat])
    mesh.position.x = -30
    scene.add(mesh)
  })
```

## 使用二元操作几何网格

```js
// 本章，我们将会看到一种特别的方式创建几何体。

// 在前边章节中，我们只能使用three.js为我们提供的几种有限的几何体来创建图形，仅仅如此而已，受限很大。

// 本章，我们将使用几种不同的几何体经过结合产生新的几何体！

// 为了实现这种功能，我们需要引入Three.js的扩展库 —— ThreeBSP。

// 这个扩展库提供了三个函数：
// intersect（相交）—— 使用该函数可以基于两个现有几何体的重合的部分定义此几何体的形状
// union（联合）—— 使用该函数可以将两个几何体联合起来创建出一个新的几何体
// subtract（相减）—— 使用该函数可以在第一个几何体中移除两个几何体重叠的部分来创建新的几何体
// 对比起，因为暂时没有找到支持最新版three.js的 ThreeBSP，所以最后一个知识点暂时不写了。

// 新版的 three.js 删除了 THREE.Geometry 类，网上的ThreeBSP将不再兼容新版 three.js，如果大家对模型布尔运算感兴趣，可以降级three.js版本，引用ThreeBSP 玩玩。

import * as THREE from 'three';
const ThreeBSP = require('three-js-csg')(THREE);
```
