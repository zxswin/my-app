## 加载和使用纹理

## 1. 将纹理应用于材质

```js
// 在three.js中可以使用纹理实现不同的效果，你可以使用它们来定义网格的颜色，也可以利用它们来定义高光，凹凸和反光，现在，我们先从最基础的用法讲起：使用纹理为网格的每个像素指定颜色。
```

- 加载纹理，并应用到网格

```js
// 纹理的基础用法是作为贴图被添加到材质上，当你使用这种材质创建网格时，网格的颜色则来源于纹理。
// 你可以使用如下方式加载纹理：

// 加载纹理
const textureLoader = new THREE.TextureLoader();
textureLoader.load('img/textures/general/metal-rust.jpg');

// 我们使用 THREE.TextureLoader从指定位置加载纹理图片，图片格式可以实 JPG、GIP、PNG、JPEG。后边我们还会讲解加载其它格式的纹理。请注意，纹理加载时异步的，如果纹理没加载完时，你会看到物体没有贴图，所以，你可以使用如下方式，为加载添加回调函数：

const textureLoader = new THREE.TextureLoader();
textureLoader.load(
  'img/textures/general/metal-rust.jpg',
  onLoadFunction,
  onProgressFunction,
  onErrorFunction
);
```

```js
// 你可以使用任何尺寸的图片作为纹理，但是为了最好的效果，这里建议您使用长宽大小为2的次方的正方形图片。例如 256 X 256、512 X 512、1024 X 1024的图片最合适。

// 因为纹理需要放大或者缩小，因此纹理像素不会一对一的映射到面的像素上。因此，WebGL和Three.js提供了不同的选项，你可以设置magFilter属性来指定纹理如何放大，设置minFilter来设置如何缩小。

// THREE.NearestFilter	这个过滤器会将纹理上最近的像素颜色应用于面上。放大时会导致方块化，缩小时会丢失很多细节。
// THREE.LinearFilter	这个过滤器比较高级，最终的颜色会以周围四个像素值来决定的，这样缩小时虽然仍会丢失一些细节，但是放大时会平滑很多，方块化也比较少见。
```

```js
// 除了上述值，我们还可以使用 mipmap。mipmap是把纹理按照2倍数进行缩小。这些图片是在加载纹理时创建的，可以用于生成比较光滑的过滤效果。所以如果你有一个正方体形纹理，只需要几步就可以达到更好的过滤效果。mipmap的纹理过滤模式如下：

// THREE.NearesMipMapNearesFilter	选择最邻近的mip层，并执行前表中最邻近的过滤，虽然放大时仍然有方格化，但是缩小时效果会好很多。
// THREE.NearestMipMapLinearFilter	选择最邻近的两个mip层，并分别在这两个mip层上运行最邻近过滤获取两个中间值，最后将这两个中间值传递到线性过滤器中获取最终值。
// THREE.LinearMipMapNearestFilter	选择最邻近的mip层，并执行前表中的线性过滤。
// THREE.LinearMipMapLinearFilter	选择最邻近的两个mip层，并分别在这两个mip层上运行线性过滤获取两个中间值，最后将这两个中间值传递到线性过滤器中获取最终值。
```

```js
// 如果没有定义magFiler和minFilter的属性值，会默认使用 THREE.LinearFilter作为magFiler的默认值，THREE.LinearMipMapLinearFilter作为minFilter属性的默认值。

// 如你所见，纹理可以很好的贴合到图形上，这个效果是three.js在创建几何时，通过UV贴图实现的。基于UV贴图，我们可以告诉渲染器将纹理的哪部分应用到指定的面上，稍后我们将会详细讲解UV贴图的相关知识。

// 加载纹理
const textureLoader = new THREE.TextureLoader();
const texture1 = textureLoader.load('img/textures/general/metal-rust.jpg');
const texture2 = textureLoader.load('img/textures/general/wood-2.jpg');
// 加载网格
const cubeMaterial = new THREE.MeshLambertMaterial({
  map: texture1,
});
const sphereMaterial = new THREE.MeshLambertMaterial({
  map: texture2,
});

const cubeGeometry = new THREE.BoxGeometry(10, 10, 10);
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

const sphereGeometry = new THREE.SphereGeometry(10, 30, 30);
const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
sphere.position.x = 20;
scene.add(cube);
scene.add(sphere);
```

- 使用凹凸贴图创建褶皱

```js
const cubeMaterial = new THREE.MeshStandardMaterial({
  map: new THREE.TextureLoader().load('img/textures/stone/stone.jpg'),
  // 用于创建凹凸贴图的纹理。黑色和白色值映射到与光照相关的感知深度。
  // 凹凸实际上不会影响对象的几何形状，只影响光照。如果定义了法线贴图，则将忽略该贴图。
  bumpMap: new THREE.TextureLoader().load('img/textures/stone/stone-bump.jpg'),
  // 材质与金属的相似度。非金属材质，如木材或石材，使用0.0，金属使用1.0，通常没有中间值。
  // 默认值为0.5。0.0到1.0之间的值可用于生锈金属的外观。如果还提供了metalnessMap，则两个值相乘。
  metalness: 0.2,
  // 材质的粗糙程度。0.0表示平滑的镜面反射，1.0表示完全漫反射。默认值为0.5。如果还提供roughnessMap，则两个值相乘。
  roughness: 0.07,
});

// 如上，bumpMap属性便是设置凹凸贴图，我们还可以通过 bumpScale来设置凹凸高度（负数则为深度）。

// 这里的凹凸贴图是一个灰度图，当然你也可以使用彩色图。像素的密集程度定义的是凹凸的高度，但是凹凸图只包含像素的相对高度，没有任何倾斜的方向信息。所以使用凹凸图所表达的深度信息优先，想要表现更多，我们可以使用法向贴图。
```

- 使用法向贴图创建更加细致的凹凸和褶皱

```js
// 法线贴图保存的不是高度信息，而是法向量的方向。简单来讲，使用法向量贴图只需要使用很少的顶点和面就可以创造出细节很丰富的模型。
// r如上，右侧的图形细节更加丰富，并且对光源的反射也更加自然。在这里，我们使用到了法向贴图：

const cubeMaterial = new THREE.MeshStandardMaterial({
  map: new THREE.TextureLoader().load('img/textures/general/plaster.jpg'),
  normalMap: new THREE.TextureLoader().load(
    'img/textures/general/plaster-normal.jpg'
  ),
  metalness: 0.2,
  roughness: 0.07,
});

// 法向贴图使用方式和凹凸贴图是一样的。我们还可以设置normalScale属性为 mat.normalScale.set(1, 1)来指定凹凸程度，通过这两个参数，你可以沿着X轴和Y轴进行缩放，但是最好的方式是将它们的值设置成一样。需要注意的是，如果设置成负数，那么高度就会反转。

// 使用法向贴图需要使用Blender或者Photoshop这样的特殊工具，这些工具可以将高分辨率的效果图或者纹理作为输入来创建法向贴图。感兴趣的可以去查查Photoshop制作法向贴图，制作较为简单。
```

```js
// 使用位移贴图来改变顶点位置
// 法向贴图和凹凸贴图都只能在物体表面形成一种凹凸不平的假象，而位移贴图能够根据贴图的内容，真正的改变模型的形状。

function createSphere(material) {
  const sphereGeometry = new THREE.SphereGeometry(6, 180, 180);
  const mesh = new THREE.Mesh(sphereGeometry, material);
  return mesh;
}
const texture = new THREE.TextureLoader().load('img/textures/w_d.png');
const displacementTexture = new THREE.TextureLoader().load(
  'img/textures/w_c.png'
);
const material = new THREE.MeshStandardMaterial({
  map: texture,
  displacementMap: displacementTexture,
  metalness: 0.02,
  roughness: 0.07,
  color: 0xffffff,
  // 位移贴图对网格的影响程度（黑色是无位移，白色是最大位移）。如果没有设置位移贴图，则不会应用此值。默认值为1。
  displacementScale: 1,
});
const sphere = createSphere(material);
scene.add(sphere);
```

- 金属光泽度贴图和粗糙度贴图

```js
// 在前边我们使用的材质 MeshStandardMaterial —— 可以用于生成闪亮的金属质感表面，也可以通过调整粗糙度来生成木制或者塑料质感的表面。实际上通过仔细的调节该材质的 metalness 和 roughness 属性，我们就可以生成大多数所需的质感。两个属性除了可以通过数字来设置外，也可以通过纹理贴图来设置。如果想要在粗糙的物体表面显示一些闪亮的局部，则可以用 metaInessMap属性设置一张金属质感贴图。如果想要设置粗糙的局部，可以使用roughnessMap来设置纹理。如果两个值同时存在，那么实际值就是它们的乘积。

const urls = [
  'img/textures/cubemap/car/right.png',
  'img/textures/cubemap/car/left.png',
  'img/textures/cubemap/car/top.png',
  'img/textures/cubemap/car/bottom.png',
  'img/textures/cubemap/car/front.png',
  'img/textures/cubemap/car/back.png',
];
// 定顺序: pos-x, neg-x, pos-y, neg-y, pos-z, neg-z.
const cubeLoader = new THREE.CubeTextureLoader();
scene.background = cubeLoader.load(urls);
const sphere = new THREE.SphereGeometry(8, 50, 50);
const cubeMaterial = new THREE.MeshStandardMaterial({
  envMap: scene.background,
  color: 0xffffff,
  metalness: 1,
  roughness: 0.5,
});
const textureLoader = new THREE.TextureLoader();
const cubeMaterialWithMetalMap = cubeMaterial.clone();
cubeMaterialWithMetalMap.metalnessMap = textureLoader.load(
  'img/textures/engraved/roughness-map.jpg'
);

const cubeMaterialWithRoughnessMap = cubeMaterial.clone();
cubeMaterialWithRoughnessMap.roughnessMap = textureLoader.load(
  'img/textures/engraved/roughness-map.jpg'
);

const cube1 = new THREE.Mesh(sphere, cubeMaterialWithMetalMap);
cube1.position.x = -10;
cube1.rotation.y = (1 / 3) * Math.PI;

const cube2 = new THREE.Mesh(sphere, cubeMaterialWithRoughnessMap);
cube2.position.x = 10;
cube2.rotation.y = (-1 / 3) * Math.PI;

scene.add(cube1);
scene.add(cube2);
```

- Alpha 贴图

```js
// 该贴图用于控制物体表面的透明度，贴图中的黑色代表该部分表面完全透明，纯白色代表完全不透明。
function createSphere(material) {
  const sphereGeometry = new THREE.SphereGeometry(20, 100, 100);
  const mesh = new THREE.Mesh(sphereGeometry, material);
  return mesh;
}
const alphaTexture = new THREE.TextureLoader().load(
  'img/textures/alpha/partial-transparency.png'
);
const material = new THREE.MeshStandardMaterial({
  alphaMap: alphaTexture,
  side: THREE.DoubleSide, // 可以透过球看到另一面
  metalness: 0.02,
  roughness: 0.07,
  color: 0xffffff,
  alphaTest: 0.5,
});
material.alphaMap.wrapS = THREE.RepeatWrapping;
material.alphaMap.wrapT = THREE.RepeatWrapping;
material.alphaMap.repeat.set(8, 8);
const sphere = createSphere(material);
sphere.position.y = 10;
scene.add(sphere);
```

- 自发光贴图

```js
// 自发光贴图是控制模型表面实现自发光效果的纹理贴图。

// 自发光贴图只能影响物体本身，对其周围物体不会产品影响。
const textureLoader = new THREE.TextureLoader();
const cubeMaterial = new THREE.MeshStandardMaterial({
  emissive: 0xffffff,
  emissiveMap: textureLoader.load('img/textures/emissive/lava.png'),
  normalMap: textureLoader.load('img/textures/emissive/lava-normals.png'),
  // 'metalnessMap': textureLoader.load('img/textures/emissive/lava-smoothness.png'),
  metalness: 1,
  roughness: 0.4,
  normalScale: new THREE.Vector2(4, 4),
});
const sphere = createSphere(cubeMaterial);
scene.add(sphere);
```

- 高光贴图

```js
// 若是想使用高光贴图，我们不得不使用THREE.MeshPhongMaterial材质，高光贴图用于指定物体表面中哪个部分比较闪亮，或者哪个部分相对黯淡，这与THREE.MeshStandardMaterial材质的金属光泽度贴图和粗糙度贴图作用接近。

// 下面我们用高光贴图做个3D地图，闪亮的部分做海面暗淡的部分做陆地。

const textureLoader = new THREE.TextureLoader();
const cubeMaterial = new THREE.MeshPhongMaterial({
  map: textureLoader.load('img/textures/earth/Earth.png'),
  normalMap: textureLoader.load('img/textures/earth/EarthNormal.png'),
  specularMap: textureLoader.load('img/textures/earth/EarthSpec.png'),
  normalScale: new THREE.Vector2(6, 6),
  specular: 'red', // 高光颜色
  shininess: 50, // 闪亮程度
});
const sphere = createSphere(cubeMaterial);
scene.add(sphere);
```

## 2. 纹理的高级用途

```js
// 自定义UV映射
// 我们有如下贴图，我们要将它左下角 1/4 处 作为贴图贴到立方体的一个面上。

// 该贴图四个角坐标分别为 0,1 1,1 0,0 1,0

// 那么，它左下角四分之一处的坐标即为：

// 0, 0.5,
// 0.5, 0.5,
// 0, 0,
// 0.5, 0

// 我们为BufferGeometry添加uv数据：

// 一般情况，uv贴图会在建模时就设置好，不需要我们在代码中调整，因为这是非常复杂的工作。

const texture = new THREE.TextureLoader().load(
  'img/textures/uv/ash_uvgrid01.jpg'
);
const material = new THREE.MeshStandardMaterial({
  map: texture,
});
const uvs = new Float32Array([0, 0.5, 0.5, 0.5, 0, 0, 0.5, 0]);
const boxGeo = new THREE.BoxGeometry(10, 10, 10);
boxGeo.attributes.uv = new THREE.BufferAttribute(uvs, 2);
const mesh = new THREE.Mesh(boxGeo, material);
scene.add(mesh);
```

- 重复纹理

```js
// three.js会在每个图形上都展示完整的纹理，但是有些时候，你不想让纹理布遍整个几何体，而是让纹理重复。

// 在实现效果之前，需要保证将纹理的包裹属性设置为 THREE.RepeatWrapping，如下所示：

// cube.material.map.wrapS = THREE.RepeatWrapping
// cube.material.map.wrapT = THREE.RepeatWrapping
// wrapS 属性定义纹理沿X轴方向的行为，wrapT 属性定义纹理沿Y轴方向的行为。

// 这两个属性有两个选项：

// THREE.RepeatWrapping 允许纹理重复自己
// THREE.ClampToEdgeWrapping 属性的默认值，纹理整体不会重复，只会重复纹理边缘像素来填满剩余空间。
// 当设置为 THREE.RepeatWrapping 时，我们就可以用以下代码来设置repeat属性啦：

// cube.material.map.repeat.set(repeatX, repeatY)
// repeatX和repeatY为1时，不重复，大于1时，开始重复。小于1时纹理会被放大。负数时会产生纹理镜像。

// 加载纹理
const textureLoader = new THREE.TextureLoader();
const texture = textureLoader.load('img/textures/general/brick-wall.jpg');
const cubeMaterial = new THREE.MeshLambertMaterial({
  map: texture,
});
const cubeGeometry = new THREE.BoxGeometry(10, 10, 10);
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
cube.material.map.wrapS = THREE.RepeatWrapping;
cube.material.map.wrapT = THREE.RepeatWrapping;
cube.material.map.repeat.set(5, 5);
scene.add(cube);

// 注意：

// 如果你想动态修改 cube.material.map.wrapS 的值为THREE.ClampToEdgeWrapping时，你需要明确的更新纹理：

// cube.material.map.needsUpdate = true
```

- 将画布作为纹理

```js
// THREE.js也支持将HTML5画布作为纹理。

// 将canvas添加为材质即可：

// const texture = new THREE.Texture(canvas)
// 当然，我们也可以用canvas绘制灰度图，用作凹凸纹理（bumpMap）。
```

- 将视频输出为纹理

```js
// 我们开始我们最后一个知识点，将视频输出到纹理。
// three.js支持直接输出html5 video。

const video = document.createElement('video');
video.src = 'img/movie.ogv';
video.autoplay = true;
video.muted = true;
video.loop = true;
const texture = new THREE.VideoTexture(video);
texture.minFilter = THREE.LinearFilter;
texture.magFilter = THREE.LinearFilter;
texture.format = THREE.RGBAFormat;
const cubeMaterial = new THREE.MeshLambertMaterial({
  map: texture,
});
const cubeGeometry = new THREE.BoxGeometry(10, 10, 10);
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
scene.add(cube);
video.play();
```
