## glup 工具的使用

- 快速入门

```bash
# 安装
npm install --global gulp-cli (可以不用装)
npm install --save-dev gulp

# 根目录下创建一个名为 gulpfile.js 的文件
const gulp = require('gulp');
const imagemin = require('gulp-imagemin');

exports.default = () => {
  return gulp
    .src('src/images/*')
    .pipe(imagemin())
    .pipe(gulp.dest('dist/images'));
};

# 终端窗口执行命令
gulp

```

- 关于 gulpfile

```bash
# 支持使用不同语言编写gulpfile
在运行 gulp 命令时会被自动加载
对于js文件,文件名gulpfile.js
对于 TypeScript，重命名为 gulpfile.ts 并安装 ts-node 模块。
对于 Babel，重命名为 gulpfile.babel.js 并安装 @babel/register 模块。

# 允许对gulpfile文件进行分割
将 gulpfile.js文件替换为同样命名为 gulpfile.js 的目录，
该目录中包含了一个名为 index.js 的文件，该文件被当作 gulpfile.js 使用。
并且，该目录中还可以包含各个独立的任务（task）模块

# 推荐使用js进行编写gulpfile
```

- 创建任务

```bash
# 公开任务与私有任务
公开任务从gulpfile中被导出（export），可以通过 gulp 命令直接调用。
私有任务被设计为在内部使用，没有被导出的部分

# 任务只要被导出就会被执行(下面会执行build和default)
exports.build = build;
exports.default = series(clean, build);

# series() 让任务顺序执行
const { series } = require('gulp');

function transpile(cb) {
  cb();
}

function bundle(cb) {
  cb();
}
exports.build = series(transpile, bundle);

# parallel() 让任务并发执行
const { parallel } = require('gulp');
function javascript(cb) {
  cb();
}

function css(cb) {
  cb();
}
exports.build = parallel(javascript, css);

# series() 和 parallel() 可嵌套执行,同一个任务如果被嵌套多次会重复执行
const { series, parallel } = require('gulp');

function clean(cb) {
  cb();
}

function css(cb) {
  cb();
}

function javascript(cb) {
  cb();
}

exports.build = series(clean, parallel(css, javascript));
```

- 任务（task）完成通知(异步执行)

```bash
# 返回 stream
const { src, dest } = require('gulp');

function streamTask() {
  return src('*.js')
    .pipe(dest('output'));
}

exports.default = streamTask;

# 返回 promise
function promiseTask() {
  return Promise.resolve('the value is ignored');
}

exports.default = promiseTask;

# 返回 event emitter
const { EventEmitter } = require('events');

function eventEmitterTask() {
  const emitter = new EventEmitter();
  setTimeout(() => emitter.emit('finish'), 250);
  return emitter;
}

exports.default = eventEmitterTask;

# 返回 child process
const { exec } = require('child_process');

function childProcessTask() {
  return exec('date');
}

exports.default = childProcessTask;

# 返回 observable
const { Observable } = require('rxjs');

function observableTask() {
  return Observable.of(1, 2, 3);
}

exports.default = observableTask;

# 使用 callback
const fs = require('fs');

function passingCallback(cb) {
  fs.access('gulpfile.js', cb);
}

exports.default = passingCallback;

# 使用 async/await
const fs = require('fs');

async function asyncAwaitTask() {
  const { version } = fs.readFileSync('package.json');
  console.log(version);
  await Promise.resolve('some result');
}

exports.default = asyncAwaitTask;

```

## 处理文件

```bash
# gulp 暴露了 src() 和 dest() 方法用于处理计算机上存放的文件
# 利用 .pipe() 方法将插件放置在 src() 和 dest() 之间，并转换流（stream）中的文件
1.src() 接受 glob 参数，并从文件系统中读取文件然后生成一个 Node 流（stream）
2.pipe() 方法，用于连接转换流（Transform streams）或可写流（Writable streams）
3.dest() 接受一个输出目录作为参数，并且它还会产生一个 Node 流（stream），通常作为终止流（terminator stream）

# 向流（stream）中添加文件
# 分阶段输出
# 创建未压缩（unminified）和已压缩（minified）的文件
const { src, dest } = require('gulp');
const babel = require('gulp-babel');
const uglify = require('gulp-uglify');
const rename = require('gulp-rename');

exports.default = function() {
  return src('src/*.js')
    .pipe(babel())
    .pipe(src('vendor/*.js'))
    .pipe(dest('output/'))
    .pipe(uglify())
    .pipe(rename({ extname: '.min.js' }))
    .pipe(dest('output/'));
}

# 模式
1.缓冲（Buffering）模式是默认模式
2.流动（Streaming）模式的存在主要用于操作无法放入内存中的大文件
3.空（Empty）模式不包含任何内容，仅在处理文件元数据时有用
```

## Glob 详解 src 的匹配

```bash
# glob 用于匹配文件路径
# src() 方法接受一个 glob 字符串或由多个 glob 字符串组成的数组作为参数

# 转义
# * 将被作为一个普通字符使用，而不再是通配符了
'glob_with_uncommon_\\*_character.js'

# 避免使用 Node 的 path 类方法来创建 glob，例如 path.join

# 特殊字符： * (一个星号)
# 在一个字符串片段中匹配任意数量的字符，包括零个匹配 主要针对单级目录下的文件
'*.js'

# 特殊字符： ** (两个星号)
# 对于匹配嵌套目录下的文件很有用
# 它将匹配类似 scripts/index.js、scripts/nested/index.js 和 scripts/nested/twice/index.js 的文件。
'scripts/**/*.js'

# 特殊字符： ! (取反)
# 如果取反 glob 只是由普通字符组成的字符串，则执行效率是最高的(非目录结构)
# 第一个 glob 匹配到一组匹配项，然后后面的取反 glob 删除这些匹配项中的一部分
['script/**/*.js', '!scripts/vendor/']
# 高效匹配
['**/*.js', '!node_modules/']

```

## 插件

```bash
#  gulp-if 插件
const { src, dest } = require('gulp');
const gulpif = require('gulp-if');
const uglify = require('gulp-uglify');

function isJavaScript(file) {
  // 判断文件的扩展名是否是 '.js'
  return file.extname === '.js';
}

exports.default = function() {
  // 在同一个管道（pipeline）上处理 JavaScript 和 CSS 文件
  return src(['src/*.js', 'src/*.css'])
    // 只对 JavaScript 文件应用 gulp-uglify 插件
    .pipe(gulpif(isJavaScript, uglify()))
    .pipe(dest('output/'));
}

# 插件应当总是用来转换文件的。其他操作都应该使用（非插件的） Node 模块或库来实现
# 删除文件操作
const del = require('delete');

exports.default = function(cb) {
  // 直接使用 `delete` 模块，避免使用 gulp-rimraf 插件
  del(['output/*.js'], cb);
}

# 非插件的实现模式
const { rollup } = require('rollup');

// Rollup 提供了基于 promise 的 API，在 `async` 任务（task）中工作的很好
exports.default = async function() {
  const bundle = await rollup.rollup({
    input: 'src/index.js'
  });

  return bundle.write({
    file: 'output/bundle.js',
    format: 'iife'
  });
}

```

## 文件监控

```bash
# 默认情况下，只要创建、更改或删除文件，文件监控程序就会执行关联的任务（task）

通过 events 参数进行指定监控的事件
可用的事件有 'add'、'addDir'、'change'、'unlink'、'unlinkDir'、'ready'、'error'。
此外，还有一个 'all' 事件，它表示除 'ready' 和 'error' 之外的所有事件。
const { watch } = require('gulp');

# 所有事件都将被监控
watch('src/*.js', { events: 'all' }, function(cb) {
  cb();
});

# 调用 watch() 之后，关联的任务（task）是不会被立即执行的，而是要等到第一次文件修之后才执行
# 如需在第一次文件修改之前执行，也就是调用 watch() 之后立即执行，请将 ignoreInitial 参数设置为 false
const { watch } = require('gulp');

// 关联的任务（task）将在启动时执行
watch('src/*.js', { ignoreInitial: false }, function(cb) {
  cb();
});

# 禁用队列
const { watch } = require('gulp');

// 每次文件修改之后关联任务都将执行（有可能并发执行）
watch('src/*.js', { queue: false }, function(cb) {
  // body omitted
  cb();
});

# 调整延迟
const { watch } = require('gulp');

// 文件第一次修改之后要等待 500 毫秒才执行关联的任务
watch('src/*.js', { delay: 500 }, function(cb) {
  // body omitted
  cb();
});
```
