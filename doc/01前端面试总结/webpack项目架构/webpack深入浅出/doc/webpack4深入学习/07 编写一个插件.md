# 编写一个插件

## 编写一个简单的 webpack 插件

- 插件编写原理

```js
// 开发者可以引入它们自己的行为到 webpack 构建流程中。
// 一个插件的组成:
// 一个 JavaScript 命名函数。
// 在插件函数的 prototype 上定义一个 apply 方法。
// 指定一个绑定到 webpack 自身的事件钩子。
// 处理 webpack 内部实例的特定数据。
// 功能完成后调用 webpack 提供的回调

// 一个 JavaScript 命名函数。
function MyExampleWebpackPlugin() {}

// 在插件函数的 prototype 上定义一个 `apply` 方法。
MyExampleWebpackPlugin.prototype.apply = function(compiler) {
  // 指定一个挂载到 webpack 自身的事件钩子。
  compiler.plugin('webpacksEventHook', function(
    compilation /* 处理 webpack 内部实例的特定数据。*/,
    callback
  ) {
    console.log('This is an example plugin!!!');

    // 功能完成后调用 webpack 提供的回调。
    callback();
  });
};
```

- 基本插件架构

```js
// 插件是由「具有 apply 方法的 prototype 对象」所实例化出来的。
// 这个 apply 方法在安装插件时，会被 webpack compiler 调用一次。

function HelloWorldPlugin(options) {
  // 使用 options 设置插件实例……
}

HelloWorldPlugin.prototype.apply = function(compiler) {
  compiler.plugin('done', function() {
    console.log('Hello World!');
  });
};

module.exports = HelloWorldPlugin;

// 插件的安装及使用
var HelloWorldPlugin = require('hello-world');

var webpackConfig = {
  // ... 这里是其他配置 ...
  plugins: [new HelloWorldPlugin({ options: true })]
};
```

## Compiler 和 Compilation 对象

```js
// compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，
// 包括 options，loader 和 plugin。
// 当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。

// compilation 对象代表了一次资源版本构建。
// 当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。
// 一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。

// 访问 compilation 对象
// 绑定提供了编译 compilation 引用的回调函数，然后拿到每次新的 compilation 对象
function HelloCompilationPlugin(options) {}

HelloCompilationPlugin.prototype.apply = function(compiler) {
  // 设置回调来访问 compilation 对象：
  compiler.plugin('compilation', function(compilation) {
    // 现在，设置回调来访问 compilation 中的步骤：
    compilation.plugin('optimize', function() {
      console.log('Assets are being optimized.');
    });
  });
};

module.exports = HelloCompilationPlugin;
```

## 异步编译插件

```js
// 额外传入一个 callback 回调函数，并且在插件运行结束时，_必须_调用这个回调函数。
function HelloAsyncPlugin(options) {}

HelloAsyncPlugin.prototype.apply = function(compiler) {
  compiler.plugin('emit', function(compilation, callback) {
    // 做一些异步处理……
    setTimeout(function() {
      console.log('Done with async work...');
      callback();
    }, 1000);
  });
};

module.exports = HelloAsyncPlugin;
```

- 生成一个叫做 filelist.md 的新文件；文件内容是所有构建生成的文件的列表

```js
function FileListPlugin(options) {}

FileListPlugin.prototype.apply = function(compiler) {
  compiler.plugin('emit', function(compilation, callback) {
    // 在生成文件中，创建一个头部字符串：
    var filelist = 'In this build:\n\n';

    // 遍历所有编译过的资源文件，
    // 对于每个文件名称，都添加一行内容。
    for (var filename in compilation.assets) {
      filelist += '- ' + filename + '\n';
    }

    // 将这个列表作为一个新的文件资源，插入到 webpack 构建中：
    compilation.assets['filelist.md'] = {
      source: function() {
        return filelist;
      },
      size: function() {
        return filelist.length;
      }
    };

    callback();
  });
};

module.exports = FileListPlugin;
```

## compiler 钩子

```js
// 通过 CLI 或 Node API 传递的所有选项，创建出一个 compilation 实例
// 它扩展(extend)自 Tapable 类，以便注册和调用插件。大多数面向用户的插件首，会先在 Compiler 上注册
// 此模块会暴露在 webpack.Compiler，可以直接通过这种方式使用
```

- 相关钩子

```js
// 生命周期钩子函数，是由 compiler 暴露
// 可以通过如下方式访问
// compiler.hooks.someHook.tap(...)

// entryOption
// 在 entry 配置项处理过之后，执行插件

// afterPlugins
// 设置完初始插件之后，执行插件

// afterResolvers
// resolver 安装完成之后，执行插件

// environment
// environment 准备好之后，执行插件

// afterEnvironment
// environment 安装完成之后，执行插件

// beforeRun
// compiler.run() 执行之前，添加一个钩子。

// run
// 开始读取 records 之前，钩入(hook into) compiler

// watchRun
// 监听模式下，一个新的编译(compilation)触发之后，执行一个插件，但是是在实际编译开始之前

// normalModuleFactory
// NormalModuleFactory 创建之后，执行插件

// contextModuleFactory
// ContextModuleFactory 创建之后，执行插件

// beforeCompile
// 编译(compilation)参数创建之后，执行插件

// compile
// 一个新的编译(compilation)创建之后，钩入(hook into) compiler

// thisCompilation
// 触发 compilation 事件之前执行

// compilation
// 编译(compilation)创建之后，执行插件

// make
// afterCompile
// shouldEmit
// needAdditionalPass

// emit
// 生成资源到 output 目录之前。

// afterEmit
// 生成资源到 output 目录之后

// done
// 编译(compilation)完成。

// failed
// 编译(compilation)失败。

// invalid
// 监听模式下，编译无效时

// watchClose
// 监听模式停止
```
