# webpack 配置

## 配置文件选项

```js
const path = require('path');

module.exports = {
  mode: "production", // "production" | "development" | "none"
  mode: "production", // enable many optimizations for production builds
  mode: "development", // enabled useful tools for development
  mode: "none", // no defaults
  // Chosen mode tells webpack to use its built-in optimizations accordingly.

  entry: "./app/entry", // string | object | array
  entry: ["./app/entry1", "./app/entry2"],
  entry: {
    a: "./app/entry-a",
    b: ["./app/entry-b1", "./app/entry-b2"]
  },
  // 这里应用程序开始执行
  // webpack 开始打包

  output: {
    // webpack 如何输出结果的相关选项

    path: path.resolve(__dirname, "dist"), // string
    // 所有输出文件的目标路径
    // 必须是绝对路径（使用 Node.js 的 path 模块）

    filename: "bundle.js", // string
    filename: "[name].js", // 用于多个入口点(entry point)（出口点？）
    filename: "[chunkhash].js", // 用于长效缓存
    // 「入口分块(entry chunk)」的文件名模板（出口分块？）

    publicPath: "/assets/", // string
    publicPath: "",
    publicPath: "https://cdn.example.com/",
    // 输出解析文件的目录，url 相对于 HTML 页面

    library: "MyLibrary", // string,
    // 导出库(exported library)的名称

    libraryTarget: "umd", // 通用模块定义
        libraryTarget: "umd2", // 通用模块定义
        libraryTarget: "commonjs2", // exported with module.exports
        libraryTarget: "commonjs-module", // 使用 module.exports 导出
        libraryTarget: "commonjs", // 作为 exports 的属性导出
        libraryTarget: "amd", // 使用 AMD 定义方法来定义
        libraryTarget: "this", // 在 this 上设置属性
        libraryTarget: "var", // 变量定义于根作用域下
        libraryTarget: "assign", // 盲分配(blind assignment)
        libraryTarget: "window", // 在 window 对象上设置属性
        libraryTarget: "global", // property set to global object
        libraryTarget: "jsonp", // jsonp wrapper
    // 导出库(exported library)的类型

    /* 高级输出配置（点击显示） */

    pathinfo: true, // boolean
    // 在生成代码时，引入相关的模块、导出、请求等有帮助的路径信息。

    chunkFilename: "[id].js",
    chunkFilename: "[chunkhash].js", // 长效缓存(/guides/caching)
    // 「附加分块(additional chunk)」的文件名模板

    jsonpFunction: "myWebpackJsonp", // string
    // 用于加载分块的 JSONP 函数名

    sourceMapFilename: "[file].map", // string
    sourceMapFilename: "sourcemaps/[file].map", // string
    // 「source map 位置」的文件名模板

    devtoolModuleFilenameTemplate: "webpack:///[resource-path]", // string
    // 「devtool 中模块」的文件名模板

    devtoolFallbackModuleFilenameTemplate: "webpack:///[resource-path]?[hash]", // string
    // 「devtool 中模块」的文件名模板（用于冲突）

    umdNamedDefine: true, // boolean
    // 在 UMD 库中使用命名的 AMD 模块

    crossOriginLoading: "use-credentials", // 枚举
    crossOriginLoading: "anonymous",
    crossOriginLoading: false,
    // 指定运行时如何发出跨域请求问题

    /* 专家级输出配置（自行承担风险） */

    devtoolLineToLine: {
      test: /\.jsx$/
    },
    // 为这些模块使用 1:1 映射 SourceMaps（快速）

    hotUpdateMainFilename: "[hash].hot-update.json", // string
    // 「HMR 清单」的文件名模板

    hotUpdateChunkFilename: "[id].[hash].hot-update.js", // string
    // 「HMR 分块」的文件名模板

    sourcePrefix: "\t", // string
    // 包内前置式模块资源具有更好可读性
  },

  module: {
    // 关于模块配置

    rules: [
      // 模块规则（配置 loader、解析器等选项）

      {
        test: /\.jsx?$/,
        include: [
          path.resolve(__dirname, "app")
        ],
        exclude: [
          path.resolve(__dirname, "app/demo-files")
        ],
        // 这里是匹配条件，每个选项都接收一个正则表达式或字符串
        // test 和 include 具有相同的作用，都是必须匹配选项
        // exclude 是必不匹配选项（优先于 test 和 include）
        // 最佳实践：
        // - 只在 test 和 文件名匹配 中使用正则表达式
        // - 在 include 和 exclude 中使用绝对路径数组
        // - 尽量避免 exclude，更倾向于使用 include

        issuer: { test, include, exclude },
        // issuer 条件（导入源）

        enforce: "pre",
        enforce: "post",
        // 标识应用这些规则，即使规则覆盖（高级选项）

        loader: "babel-loader",
        // 应该应用的 loader，它相对上下文解析
        // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的
        // 查看 webpack 1 升级指南。

        options: {
          presets: ["es2015"]
        },
        // loader 的可选项
      },

      {
        test: /\.html$/,
        test: "\.html$"

        use: [
          // 应用多个 loader 和选项
          "htmllint-loader",
          {
            loader: "html-loader",
            options: {
              /* ... */
            }
          }
        ]
      },

      { oneOf: [ /* rules */ ] },
      // 只使用这些嵌套规则之一

      { rules: [ /* rules */ ] },
      // 使用所有这些嵌套规则（合并可用条件）

      { resource: { and: [ /* 条件 */ ] } },
      // 仅当所有条件都匹配时才匹配

      { resource: { or: [ /* 条件 */ ] } },
      { resource: [ /* 条件 */ ] },
      // 任意条件匹配时匹配（默认为数组）

      { resource: { not: /* 条件 */ } }
      // 条件不匹配时匹配
    ],

    /* 高级模块配置（点击展示） */

    noParse: [
      /special-library\.js$/
    ],
    // 不解析这里的模块

    unknownContextRequest: ".",
    unknownContextRecursive: true,
    unknownContextRegExp: /^\.\/.*$/,
    unknownContextCritical: true,
    exprContextRequest: ".",
    exprContextRegExp: /^\.\/.*$/,
    exprContextRecursive: true,
    exprContextCritical: true,
    wrappedContextRegExp: /.*/,
    wrappedContextRecursive: true,
    wrappedContextCritical: false,
    // specifies default behavior for dynamic requests
  },

  resolve: {
    // 解析模块请求的选项
    // （不适用于对 loader 解析）

    modules: [
      "node_modules",
      path.resolve(__dirname, "app")
    ],
    // 用于查找模块的目录

    extensions: [".js", ".json", ".jsx", ".css"],
    // 使用的扩展名

    alias: {
      // 模块别名列表

      "module": "new-module",
      // 起别名："module" -> "new-module" 和 "module/path/file" -> "new-module/path/file"

      "only-module$": "new-module",
      // 起别名 "only-module" -> "new-module"，但不匹配 "only-module/path/file" -> "new-module/path/file"

      "module": path.resolve(__dirname, "app/third/module.js"),
      // 起别名 "module" -> "./app/third/module.js" 和 "module/file" 会导致错误
      // 模块别名相对于当前上下文导入
    },
    /* 可供选择的别名语法（点击展示） */
    alias: [
      {
        name: "module",
        // 旧的请求

        alias: "new-module",
        // 新的请求

        onlyModule: true
        // 如果为 true，只有 "module" 是别名
        // 如果为 false，"module/inner/path" 也是别名
      }
    ],

    /* 高级解析选项（点击展示） */

    symlinks: true,
    // 遵循符号链接(symlinks)到新位置

    descriptionFiles: ["package.json"],
    // 从 package 描述中读取的文件

    mainFields: ["main"],
    // 从描述文件中读取的属性
    // 当请求文件夹时

    aliasFields: ["browser"],
    // 从描述文件中读取的属性
    // 以对此 package 的请求起别名

    enforceExtension: false,
    // 如果为 true，请求必不包括扩展名
    // 如果为 false，请求可以包括扩展名

    moduleExtensions: ["-module"],
    enforceModuleExtension: false,
    // 类似 extensions/enforceExtension，但是用模块名替换文件

    unsafeCache: true,
    unsafeCache: {},
    // 为解析的请求启用缓存
    // 这是不安全，因为文件夹结构可能会改动
    // 但是性能改善是很大的

    cachePredicate: (path, request) => true,
    // predicate function which selects requests for caching

    plugins: [
      // ...
    ]
    // 应用于解析器的附加插件
  },

  performance: {
    hints: "warning", // 枚举
    hints: "error", // 性能提示中抛出错误
    hints: false, // 关闭性能提示
    maxAssetSize: 200000, // 整数类型（以字节为单位）
    maxEntrypointSize: 400000, // 整数类型（以字节为单位）
    assetFilter: function(assetFilename) {
      // 提供资源文件名的断言函数
      return assetFilename.endsWith('.css') || assetFilename.endsWith('.js');
    }
  },

  devtool: "source-map", // enum
  devtool: "inline-source-map", // 嵌入到源文件中
  devtool: "eval-source-map", // 将 SourceMap 嵌入到每个模块中
  devtool: "hidden-source-map", // SourceMap 不在源文件中引用
  devtool: "cheap-source-map", // 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant)
  devtool: "cheap-module-source-map", // 有模块映射(module mappings)的 SourceMap 低级变体
  devtool: "eval", // 没有模块映射，而是命名模块。以牺牲细节达到最快。
  // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试
  // 牺牲了构建速度的 `source-map' 是最详细的。

  context: __dirname, // string（绝对路径！）
  // webpack 的主目录
  // entry 和 module.rules.loader 选项
  // 相对于此目录解析

  target: "web", // 枚举  // 包(bundle)应该运行的环境
  // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module)

  externals: ["react", /^@angular\//],  // 不要遵循/打包这些模块，而是在运行时从环境中请求他们

  stats: "errors-only",
  stats: { //object
    assets: true,
    colors: true,
    errors: true,
    errorDetails: true,
    hash: true,
    // ...
  },
  // 精确控制要显示的 bundle 信息

  devServer: {
    proxy: { // proxy URLs to backend development server
      '/api': 'http://localhost:3000'
    },
    contentBase: path.join(__dirname, 'public'), // boolean | string | array, static file location
    compress: true, // enable gzip compression
    historyApiFallback: true, // true for index.html upon 404, object for multiple paths
    hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin
    https: false, // true for self-signed, object for cert authority
    noInfo: true, // only errors & warns on hot reload
    // ...
  },

  plugins: [
    // ...
  ],
  // 附加插件列表


  /* 高级配置（点击展示） */

  resolveLoader: { /* 等同于 resolve */ }
  // 独立解析选项的 loader

  parallelism: 1, // number
  // 限制并行处理模块的数量

  profile: true, // boolean
  // 捕获时机信息

  bail: true, //boolean
  // 在第一个错误出错时抛出，而不是无视错误。

  cache: false, // boolean
  // 禁用/启用缓存

  watch: true, // boolean
  // 启用观察

  watchOptions: {
    aggregateTimeout: 1000, // in ms
    // 将多个更改聚合到单个重构建(rebuild)

    poll: true,
    poll: 500, // 间隔单位 ms
    // 启用轮询观察模式
    // 必须用在不通知更改的文件系统中
    // 即 nfs shares（译者注：Network FileSystem，最大的功能就是可以透過網路，讓不同的機器、不同的作業系統、可以彼此分享個別的檔案 ( share file )）
  },

  node: {
    // Polyfills and mocks to run Node.js-
    // environment code in non-Node environments.

    console: false, // boolean | "mock"
    global: true, // boolean | "mock"
    process: true, // boolean
    __filename: "mock", // boolean | "mock"
    __dirname: "mock", // boolean | "mock"
    Buffer: true, // boolean | "mock"
    setImmediate: true // boolean | "mock" | "empty"
  },

  recordsPath: path.resolve(__dirname, "build/records.json"),
  recordsInputPath: path.resolve(__dirname, "build/records.json"),
  recordsOutputPath: path.resolve(__dirname, "build/records.json"),
  // TODO

}
```

## 使用不同语言进行配置(configuration languages)

- TypeScript

```js
/**
 * 先安装相关依赖
 * npm install --save-dev typescript ts-node @types/node @types/webpack

 * 在 tsconfig.json 文件中，具有 esModuleInterop 和 allowSyntheticDefaultImports 
 * tsconfig.json 中的 compilerOptions 中的 module 字段是 commonjs ，则配置是正确的，否则 webpack 将因为错误而构建失败
 */

// webpack.config.ts
import path from 'path';
import webpack from 'webpack';

const config: webpack.Configuration = {
  mode: 'production',
  entry: './foo.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'foo.bundle.js'
  }
};

export default config;
```

## 多种配置类型(configuration types)

- 导出为一个函数

```js
/**
 * 环境对象(environment)作为第一个参数
 * 一个选项 map 对象（argv）作为第二个参数。这个对象描述了传递给 webpack 的选项，
 * 并且具有 output-filename 和 optimize-minimize 等 key。
 */
module.exports = function(env, argv) {
  return {
    mode: env.production ? 'production' : 'development',
    devtool: env.production ? 'source-maps' : 'eval',
    plugins: [
      new webpack.optimize.UglifyJsPlugin({
        compress: argv['optimize-minimize'] // 只有传入 -p 或 --optimize-minimize
      })
    ]
  };
};
```

- 导出一个 Promise

```js
/**
 * webpack 将运行由配置文件导出的函数，并且等待 Promise 返回。便于需要异步地加载所需的配置变量
 */
module.exports = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve({
        entry: './app.js'
        /* ... */
      });
    }, 5000);
  });
};
```

- 导出多个配置对象

```js
/**
 * 对于针对多个构建目标（例如 AMD 和 CommonJS）打包一个 library 非常有用。
 */
module.exports = [
  {
    output: {
      filename: './dist-amd.js',
      libraryTarget: 'amd'
    },
    entry: './app.js',
    mode: 'production'
  },
  {
    output: {
      filename: './dist-commonjs.js',
      libraryTarget: 'commonjs'
    },
    entry: './app.js',
    mode: 'production'
  }
];
```

## 入口和上下文(entry and context)

```js
/**
 * context
 * 基础目录，绝对路径，用于从配置中解析入口起点(entry point)和 loader
 * 默认使用当前目录
 * context: path.resolve(__dirname, "app")

 * entry
 * 起点或是应用程序的起点入口。从这个起点开始，应用程序启动执行
 * 如果传递一个数组，那么数组的每一项都会执行。

 * 如果传入一个字符串或字符串数组，chunk 会被命名为 main
 * 如果传入一个对象，则每个键(key)会是 chunk 的名称，该值描述了 chunk 的入口起点。

 * 动态入口
 * entry: () => './demo'
 * entry: () => new Promise((resolve) => resolve(['./demo', './demo2']))
 * 当结合 output.library 选项时：如果传入数组，则只导出最后一项。
 */
entry: {
  home: "./home.js",
  about: "./about.js",
  contact: "./contact.js"
}
```

## 输出(output)

- output.auxiliaryComment

```js
/**
 * 在和 output.library 和 output.libraryTarget 一起使用时，此选项允许用户向导出容器(export wrapper)中插入注释。
 * 要为 libraryTarget 每种类型都插入相同的注释，将 auxiliaryComment 设置为一个字符串
 */
output: {
  library: "someLibName",
  libraryTarget: "umd",
  filename: "someLibName.js",
  auxiliaryComment: "Test Comment"
}

// 将生成如下内容
(function webpackUniversalModuleDefinition(root, factory) {
  // Test Comment
  if(typeof exports === 'object' && typeof module === 'object')
    module.exports = factory(require("lodash"));
  // Test Comment
  else if(typeof define === 'function' && define.amd)
    define(["lodash"], factory);
  // Test Comment
  else if(typeof exports === 'object')
    exports["someLibName"] = factory(require("lodash"));
  // Test Comment
  else
    root["someLibName"] = factory(root["_"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
  // ...
});

// 对于 libraryTarget 每种类型的注释进行更细粒度地控制，请传入一个对象
auxiliaryComment: {
  root: "Root Comment",
  commonjs: "CommonJS Comment",
  commonjs2: "CommonJS2 Comment",
  amd: "AMD Comment"
}
```

- output.chunkFilename

```js
/**
 * 此选项决定了非入口(non-entry) chunk 文件的名称
 * 需要在 webpack runtime 输出 bundle 值时，将 chunk id 的值对应映射到占位符(如 [name] 和 [chunkhash])
 * 这会增加文件大小，并且在任何 chunk 的占位符值修改后，都会使 bundle 失效。
 * 默认使用 [id].js 或从 output.filename 中推断出的值（[name] 会被预先替换为 [id] 或 [id].）
 */
```

- output.chunkLoadTimeout

```js
/**
 * chunk 请求到期之前的毫秒数，默认为 120 000。
 */
```

- output.crossOriginLoading

```js
/**
 * 只用于 target 是 web，使用了通过 script 标签的 JSONP 来按需加载 chunk。
 * crossOriginLoading: false - 禁用跨域加载（默认）
 * crossOriginLoading: "anonymous" - 不带凭据(credential)启用跨域加载
 * crossOriginLoading: "use-credentials" - 带凭据(credential)启用跨域加载 with credentials
 */
```

- output.jsonpScriptType

```js
/**
 * 允许自定义 script 的类型，webpack 会将 script 标签注入到 DOM 中以下载异步 chunk
 * "text/javascript"（默认）
 * "module"：与 ES6 就绪代码一起使用。
 */
```

- output.devtoolFallbackModuleFilenameTemplate

```js
/**
 * 当上面的模板字符串或函数产生重复时使用的备用内容
 */
```

- output.devtoolModuleFilenameTemplate

```js
/**
 * 此选项仅在 「devtool 使用了需要模块名称的选项」时使用。
 * 自定义每个 source map 的 sources 数组中使用的名称
 * 当使用 devtool: 'eval'，默认值是
 * devtoolModuleFilenameTemplate: "webpack://[namespace]/[resource-path]?[loaders]"
  [absolute-resource-path]
  绝对路径文件名
  [all-loaders]
  自动和显式的 loader，并且参数取决于第一个 loader 名称
  [hash]
  模块标识符的 hash
  [id]
  模块标识符
  [loaders]
  显式的 loader，并且参数取决于第一个 loader 名称
  [resource]
  用于解析文件的路径和用于第一个 loader 的任意查询参数
  [resource-path]
  不带任何查询参数，用于解析文件的路径
  [namespace]
  模块命名空间。在构建成为一个 library 之后，通常也是 library 名称，否则为空

  * 当使用一个函数，同样的选项要通过 info 参数并使用驼峰式(camel-cased)
 */

devtoolModuleFilenameTemplate: info => {
  return `webpack:///${info.resourcePath}?${info.loaders}`;
};
```

- output.devtoolNamespace

```js
/**
 * 此选项确定 output.devtoolModuleFilenameTemplate 使用的模块名称空间。未指定时的默认值为：output.library。
 * 在加载多个通过 webpack 构建的 library 时，用于防止 sourcemap 中源文件路径冲突
 * 将这些文件暴露为 webpack://library1/./src/index.js 和 webpack://library2/./src/index.js。
 */
```

- output.filename

```js
/**
 * 此选项决定了每个输出 bundle 的名称。这些 bundle 将写入到 output.path 选项指定的目录下。
 * 此选项被称为文件名，但是你还是可以使用像 "js/[name]/bundle.js" 这样的文件夹结构
 * 此选项不会影响那些「按需加载 chunk」的输出文件。对于这些文件，请使用 output.chunkFilename 选项来控制输出。
 * 通过 loader 创建的文件也不受影响。

 * 使用入口名称：filename: "[name].bundle.js"
 * 使用内部 chunk id:filename: "[id].bundle.js"
 * 使用每次构建过程中，唯一的 hash 生成: filename: "[name].[hash].bundle.js"
 * 使用基于每个 chunk 内容的 hash：filename: "[chunkhash].bundle.js"

 * 可以使用以下替换模板字符串（通过 webpack 内部的[TemplatedPathPlugin]TemplatedPathPlugin）
 * [hash] 和 [chunkhash] 的长度可以使用 [hash:16]（默认为20）来指定。
 * 或者，通过指定output.hashDigestLength 在全局配置长度。
  [hash]
  模块标识符(module identifier)的 hash
  [chunkhash]
  chunk 内容的 hash
  [name]
  模块名称
  [id]
  模块标识符(module identifier)
  [query]
  模块的 query，例如，文件名 ? 后面的字符串
 */
```

- output.hashDigest

```js
/**
 * 在生成 hash 时使用的编码方式，默认为 'hex'。支持 Node.js hash.digest 的所有编码。
 */
```

- output.hashDigestLength

```js
/**
 * 散列摘要的前缀长度，默认为 20
 */
```

- output.hashFunction

```js
/**
 * 散列算法，默认为 'md5'。
 * 支持 Node.JS crypto.createHash 的所有功能
 */
```

- output.hashSalt

```js
/**
 * 一个可选的加盐值，通过 Node.JS hash.update 来更新哈希。
 */
```

- output.hotUpdateChunkFilename

```js
/**
 * 自定义热更新 chunk 的文件名。
 * 占位符只能是 [id] 和 [hash]，默认值是：
 * hotUpdateChunkFilename: "[id].[hash].hot-update.js"
 */
```

- output.hotUpdateFunction

```js
/**
 * 只在 target 是 web 时使用，用于加载热更新(hot update)的 JSONP 函数。
 */
```

- output.hotUpdateMainFilename

```js
/**
 * 自定义热更新的主文件名(main filename)。
 * 占位符只能是 [hash]，默认值是：
 * hotUpdateMainFilename: "[hash].hot-update.json"
 */
```

- output.jsonpFunction

```js
/**
 * 只在 target 是 web 时使用，用于按需加载(load on-demand) chunk 的 JSONP 函数。
 */
```

- output.library

```js
/**
 * output.library 的值的作用，取决于output.libraryTarget 选项的值；
 * 注意，output.libraryTarget 的默认选项是 var
 * 如果生成的输出文件，是在 HTML 页面中作为一个 script 标签引入，则变量 MyLibrary 将与入口文件的返回值绑定。
 */

output: {
  library: 'MyLibrary';
}
```

- output.libraryExport

```js
/**
 *
 */
```

- output.libraryTarget

```js
/**
 * 配置如何暴露 library。
 * 假定将 output.library 的值配置为 MyLibrary

 * 如果 MyLibrary 在作用域中未在前面代码进行定义，则你的 library 将被设置在全局作用域内。
 * 当使用此选项时，将 output.library 设置为空，将产生一个破损的输出 bundle。
 */

// libraryTarget: "var" - （默认值）当 library 加载完成，入口起点的返回值将分配给一个变量：
var MyLibrary = _entry_return_;
// 在一个单独的 script……
MyLibrary.doSomething();

/**
 * libraryTarget: "assign" - 这将产生一个隐含的全局变量，可能会潜在地重新分配到全局中已存在的值（谨慎使用）。.
 */

MyLibrary = _entry_return_;

/**
 * 通过在对象上赋值暴露
 * 如果 output.library 未赋值为一个非空字符串，则默认行为是，
 * 将入口起点返回的所有属性都赋值给一个对象（此对象由 output.libraryTarget 特定）

 * 不设置 output.library 将导致由入口起点返回的所有属性，都会被赋值给给定的对象；这里并不会检查现有的属性名是否存在。
 */
(function(e, a) { for(var i in a) e[i] = a[i]; }(${output.libraryTarget}, _entry_return_)

/**
 * ibraryTarget: "this" - 入口起点的返回值将分配给 this 的一个属性（此名称由 output.library 定义）下，this 的含义取决于你：
 */
this["MyLibrary"] = _entry_return_;

// 在一个单独的 script……
this.MyLibrary.doSomething();
MyLibrary.doSomething(); // 如果 this 是 window

/**
  * libraryTarget: "window" - 入口起点的返回值将使用 output.library 中定义的值，分配给 window 对象的这个属性下。
  */
window["MyLibrary"] = _entry_return_;
window.MyLibrary.doSomething();

/**
  * libraryTarget: "global" - 入口起点的返回值将使用 output.library 中定义的值，分配给 global 对象的这个属性下。
  */
global["MyLibrary"] = _entry_return_;
global.MyLibrary.doSomething();

/**
* libraryTarget: "commonjs" - 入口起点的返回值将使用 output.library 中定义的值，分配给 exports 对象。这个名称也意味着，模块用于 CommonJS 环境：
  */
exports["MyLibrary"] = _entry_return_;
require("MyLibrary").doSomething();
```

- 模块定义系统

```js
/**
 * libraryTarget: "commonjs2" - 入口起点的返回值将分配给 module.exports 对象。这个名称也意味着模块用于 CommonJS 环境：
 * 注意，output.library 会被省略，因此对于此特定的 output.libraryTarget，无需再设置 output.library
 */
module.exports = _entry_return_;
require('MyLibrary').doSomething();

/**
 * libraryTarget: "amd" - 将你的 library 暴露为 AMD 模块。
 * 生成的 output 将会使用 "MyLibrary" 作为模块名定义
 */
output: {
  library: "MyLibrary",
  libraryTarget: "amd"
}

define("MyLibrary", [], function() {
  return _entry_return_; // 此模块返回值，是入口 chunk 返回的值
});

// 可以在 script 标签中，将 bundle 作为一个模块整体引入，并且可以像这样调用 bundle：
require(['MyLibrary'], function(MyLibrary) {
  // 使用 library 做一些事……
});

/**
  * 如果 output.library 未定义，将会生成以下内容。
  */
define([], function() {
  return _entry_return_; // 此模块返回值，是入口 chunk 返回的值
});


/**
  * libraryTarget: "umd" - 将你的 library 暴露为所有的模块定义下都可运行的方式。
  */
output: {
  library: "MyLibrary",
  libraryTarget: "umd"
}

// 最终输出如下：

(function webpackUniversalModuleDefinition(root, factory) {
  if(typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if(typeof define === 'function' && define.amd)
    define([], factory);
  else if(typeof exports === 'object')
    exports["MyLibrary"] = factory();
  else
    root["MyLibrary"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
  return _entry_return_; // 此模块返回值，是入口 chunk 返回的值
});

/**
  * 省略 library 会导致将入口起点返回的所有属性，直接赋值给 root 对象
  */
// 输出结果如下：
(function webpackUniversalModuleDefinition(root, factory) {
  if(typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if(typeof define === 'function' && define.amd)
    define([], factory);
  else {
    var a = factory();
    for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
  }
})(typeof self !== 'undefined' ? self : this, function() {
  return _entry_return_; // 此模块返回值，是入口 chunk 返回的值
});

/**
  * 将 library 指定为一个对象，用于给每个 target 起不同的名称
  */
output: {
  library: {
    root: "MyLibrary",
    amd: "my-library",
    commonjs: "my-common-library"
  },
  libraryTarget: "umd"
}

/**
  * libraryTarget: "jsonp" - 这将把入口起点的返回值，包裹到一个 jsonp 包装容器中
  */
MyLibrary(_entry_return_);
```

- output.path

```js
/**
 * output 目录对应一个绝对路径。
 */
path: path.resolve(__dirname, 'dist/assets');
```

- output.pathinfo

```js
/**
 * 告诉 webpack 在 bundle 中引入「所包含模块信息」的相关注释。
 * 此选项默认值是 false，并且不应该用于生产环境(production)，但是对阅读开发环境(development)中的生成代码(generated code)极其有用
 * 注意，这些注释也会被添加至经过 tree shaking 后生成的 bundle 中。
 */
pathinfo: true;
```

- output.publicPath

```js
/**
 * 对于按需加载(on-demand-load)或加载外部资源(external resources)（如图片、文件等）来说，
 * output.publicPath 是很重要的选项。如果指定了一个错误的值，则在加载这些资源时会收到 404 错误。

 * 此选项指定在浏览器中所引用的「此输出目录对应的公开 URL」。
 * 相对 URL(relative URL) 会被相对于 HTML 页面（或 <base> 标签）解析。
 * 该选项的值是以 runtime(运行时) 或 loader(载入时) 所创建的每个 URL 为前缀。因此，在多数情况下，此选项的值都会以/结束。

 * 默认值是一个空字符串 ""。
 */

// output.path 中的 URL 以 HTML 页面为基准
path: path.resolve(__dirname, "public/assets"),
publicPath: "https://cdn.example.com/assets/"

// 对于一个 chunk 请求，看起来像这样 /assets/4.chunk.js。
publicPath: "/assets/",
chunkFilename: "[id].chunk.js"

// 对于一个输出 HTML 的 loader 可能会像这样输出：
<link href="/assets/spinner.gif" />

// webpack-dev-server 也会默认从 publicPath 为基准，使用它来决定在哪个目录下启用服务，来访问 webpack 输出的文件。


publicPath: "https://cdn.example.com/assets/", // CDN（总是 HTTPS 协议）
publicPath: "//cdn.example.com/assets/", // CDN (协议相同)
publicPath: "/assets/", // 相对于服务(server-relative)
publicPath: "assets/", // 相对于 HTML 页面
publicPath: "../assets/", // 相对于 HTML 页面
publicPath: "", // 相对于 HTML 页面（目录相同）

/**
  * 在编译时(compile time)无法知道输出文件的 publicPath 的情况下，可以留空，
  * 然后在入口文件(entry file)处使用自由变量(free variable) __webpack_public_path__，以便在运行时(runtime)进行动态设置。
  */

// 应用程序入口的其他部分
__webpack_public_path__ = myRuntimePublicPath

```

- output.sourceMapFilename

```js
/**
 * 此选项会向硬盘写入一个输出文件，只在 devtool 启用了 SourceMap 选项时才使用。
 */
```

- output.sourcePrefix

```js
/**
 * 修改输出 bundle 中每行的前缀。
 */
```

- output.strictModuleExceptionHandling

```js
/**
 * 如果一个模块是在 require 时抛出异常，告诉 webpack 从模块实例缓存(require.cache)中删除这个模块。
 * 出于性能原因，默认为 false。
 * strictModuleExceptionHandling 设置为 true，这个模块所有的 require 都抛出异常
 */
```

- output.umdNamedDefine

```js
/**
 * 当使用了 libraryTarget: "umd"，设置：
 * 会对 UMD 的构建过程中的 AMD 模块进行命名。否则就使用匿名的 define。
 */
umdNamedDefine: true;
```

## 模块(module)

- module.noParse

```js
/**
 * 防止 webpack 解析那些任何与给定正则表达式相匹配的文件
 */
// 从 webpack 3.0.0 开始
noParse: function(content) {
  return /jquery|lodash/.test(content);
}
```

- module.rules

```js
/**
 * 对模块(module)应用 loader，或者修改解析器(parser)。

 * Rule.exclude
 * Rule.exclude 是 Rule.resource.exclude 的简写。如果你提供了 Rule.exclude 选项，就不能再提供 Rule.resource。

 * Rule.parser
 parser: {
  amd: false, // 禁用 AMD
  commonjs: false, // 禁用 CommonJS
  system: false, // 禁用 SystemJS
  harmony: false, // 禁用 ES2015 Harmony import/export
  requireInclude: false, // 禁用 require.include
  requireEnsure: false, // 禁用 require.ensure
  requireContext: false, // 禁用 require.context
  browserify: false, // 禁用特殊处理的 browserify bundle
  requireJs: false, // 禁用 requirejs.*
  node: false, // 禁用 __dirname, __filename, module, require.extensions, require.main 等。
  node: {...} // 在模块级别(module level)上重新配置 node 层(layer)
}
 */
use: [
  'style-loader',
  {
    loader: 'css-loader',
    options: {
      importLoaders: 1
    }
  },
  {
    loader: 'less-loader',
    options: {
      noIeCompat: true
    }
  }
];
```

- 条件

```js
/**
 *
 { test: Condition }：匹配特定条件。一般是提供一个正则表达式或正则表达式的数组，但这不是强制的。
 { include: Condition }：匹配特定条件。一般是提供一个字符串或者字符串数组，但这不是强制的。
 { exclude: Condition }：排除特定条件。一般是提供一个字符串或字符串数组，但这不是强制的。
 { and: [Condition] }：必须匹配数组中的所有条件
 { or: [Condition] }：匹配数组中任何一个条件
 { not: [Condition] }：必须排除这个条件
 */
{
  test: /\.css$/,
  include: [
    path.resolve(__dirname, "app/styles"),
    path.resolve(__dirname, "vendor/styles")
  ]
}
```

## 解析(resolve)

- resolve

```js
/**
 * 配置模块如何解析。
 * 这些选项能设置模块如何被解析。webpack 提供合理的默认值，但是还是可能会修改一些解析的细节
 */
```

- resolve.alias

```js
/**
 * 创建 import 或 require 的别名，来确保模块引入变得更简单。
 */
alias: {
  Utilities: path.resolve(__dirname, 'src/utilities/'),
  Templates: path.resolve(__dirname, 'src/templates/')
}

// 导入
import Utility from '../../utilities/utility';
// 也可以使用别名
import Utility from 'Utilities/utility';

/**
  * 末尾添加 $，以表示精准匹配
  */
alias: {
  xyz$: path.resolve(__dirname, 'path/to/file.js')
}
import Test1 from 'xyz'; // 精确匹配，所以 path/to/file.js 被解析和导入
import Test2 from 'xyz/file.js'; // 非精确匹配，触发普通解析
```

- resolve.aliasFields

```js
/**
 * 指定一个字段，例如 browser，根据此规范进行解析。默认：
 * aliasFields: ["browser"]
 */
```

- resolve.cacheWithContext

```js
/**
 * 解析缓存(resolve caching)中的上下文(context)会被忽略。这解决了性能衰退的问题。
 */
```

- resolve.descriptionFiles

```js
/**
 * 用于描述的 JSON 文件。默认
 * descriptionFiles: ["package.json"]
 */
```

- resolve.enforceExtension

```js
/**
 * 如果是 true，将不允许无扩展名(extension-less)文件。
 */
```

- resolve.enforceModuleExtension

```js
/**
 * 对模块是否需要使用的扩展（例如 loader）。
 */
```

- resolve.extensions

```js
/**
 * 自动解析确定的扩展。默认值为
 * extensions: [".js", ".json"]
 */
```

- resolve.extensions

```js
/**
 * 自动解析确定的扩展。默认值为
 * extensions: [".js", ".json"]

 * 能够使用户在引入模块时不带扩展：
 * import File from '../path/to/file'
 */
```

- resolve.mainFields

```js
/**
 * 当 target 属性设置为 webworker, web 或者没有指定，默认值为：
 * mainFields: ["browser", "module", "main"]

 * 对于其他任意的 target（包括 node），默认值为：
 * mainFields: ["module", "main"]

 * 例如，D3 的 package.json 含有这些字段：
 * 当我们 import * as D3 from "d3"，实际从 browser 属性解析文件。在这里 browser 属性是最优先选择的，
 * 因为它是 mainFields 的第一项。
 * 由 webpack 打包的 Node.js 应用程序默认会从 module 字段中解析文件。
 {
  ...
  main: 'build/d3.Node.js',
  browser: 'build/d3.js',
  module: 'index',
  ...
}
 */
```

- resolve.mainFiles

```js
/**
 * 解析目录时要使用的文件名。默认：
 * mainFiles: ["index"]
 */
```

- resolve.modules

```js
/**
 * 告诉 webpack 解析模块时应该搜索的目录
 * 使用绝对路径，将只在给定目录中搜索。
 * modules: ["node_modules"]

 * 如果你想要添加一个目录到模块搜索目录，此目录优先于 node_modules/ 搜索：
 * modules: [path.resolve(__dirname, "src"), "node_modules"]
 */
```

- resolve.unsafeCache

```js
/**
 * 启用，会主动缓存模块，但并不安全。传递 true 将缓存一切。
 * 默认：unsafeCache: true

 * 只缓存 utilities 模块：
 * unsafeCache: /src\/utilities/
 */
```

- resolve.plugins

```js
/**
 * 应该使用的额外的解析插件列表。它允许插件，如 DirectoryNamedWebpackPlugin。
 */
plugins: [new DirectoryNamedWebpackPlugin()];
```

- resolve.symlinks

```js
/**
 * 是否将符号链接(symlink)解析到它们的符号链接位置(symlink location)
 * 启用时，符号链接(symlink)的资源，将解析为其_真实_路径，而不是其符号链接(symlink)位置。
 */
```

- resolve.cachePredicate

```js
/**
 * 决定请求是否应该被缓存的函数。函数传入一个带有 path 和 request 属性的对象
 */
cachePredicate: function() { return true }
```

- resolveLoader

```js
/**
 * 这组选项与上面的 resolve 对象的属性集合相同，但仅用于解析 webpack 的 loader 包
 */
{
  modules: [ 'node_modules' ],
  extensions: [ '.js', '.json' ],
  mainFields: [ 'loader', 'main' ]
}
```

- resolveLoader.moduleExtensions

```js
/**
 * 解析 loader 时，用到扩展名(extensions)/后缀(suffixes)。
 * 如果你确实想省略 -loader，也就是说只使用 example，则可以使用此选项来实现：
 * moduleExtensions: [ '-loader' ]
 */
```

## 插件(plugins)

- 插件配置使用样例

```js
var webpack = require('webpack');
// 导入非 webpack 自带默认插件
var ExtractTextPlugin = require('extract-text-webpack-plugin');
var DashboardPlugin = require('webpack-dashboard/plugin');

// 在配置中添加插件
plugins: [
  // 构建优化插件
  new webpack.optimize.CommonsChunkPlugin({
    name: 'vendor',
    filename: 'vendor-[hash].min.js'
  }),
  new webpack.optimize.UglifyJsPlugin({
    compress: {
      warnings: false,
      drop_console: false
    }
  }),
  new ExtractTextPlugin({
    filename: 'build.min.css',
    allChunks: true
  }),
  new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/),
  // 编译时(compile time)插件
  new webpack.DefinePlugin({
    'process.env.NODE_ENV': '"production"'
  }),
  // webpack-dev-server 强化插件
  new DashboardPlugin(),
  new webpack.HotModuleReplacementPlugin()
];
```

## 开发中 Server(devServer)

- devServer

```js
/**
 * 所有来自 dist/ 目录的文件都做 gzip 压缩和提供为服务
 */
devServer: {
  contentBase: path.join(__dirname, "dist"),
  compress: true,
  port: 9000
}
```

- devServer.after

```js
/**
 * 提供在服务器内部所有其他中间件之后执行自定义中间件的能力。
 */
after(app){
  // do fancy stuff
}
```

- devServer.allowedHosts

```js
/**
 * 此选项允许您列出允许访问开发服务器的白名单服务。
 */
allowedHosts: [
  'host.com',
  'subdomain.host.com',
  'subdomain2.host.com',
  'host2.com'
];

// 可以匹配host.com下面所有的子域
allowedHosts: ['.host.com', 'host2.com'];
```

- devServer.before

```js
/**
 * 提供在服务器内部所有其他中间件之前执行自定义中间件的能力。这可以用来定义自定义处理程序
 */
before(app){
  app.get('/some/path', function(req, res) {
    res.json({ custom: 'response' });
  });
}
```

- devServer.bonjour

```js
/**
 * 此选项在启动时通过ZeroConf网络广播服务器
 */
bonjour: true;
```

- devServer.clientLogLevel

```js
/**
 * 在重新加载之前，在一个错误之前，或者模块热替换(Hot Module Replacement)启用时控制台打印的信息
 * 阻止在开发工具(DevTools)的控制台(console)将显示消息
 */
clientLogLevel: 'none';
```

- devServer.color - CLI only

```js
/**
 * 控制台是否显示颜色标识
 */
webpack-dev-server --color
```

- devServer.compress

```js
/**
 * 一切服务都启用gzip 压缩：
 */
compress: true;
```

- devServer.contentBase

```js
/**
 * 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要
 * devServer.publicPath 将用于确定应该从哪里提供 bundle，并且此选项优先
 */
contentBase: path.join(__dirname, 'public');

// 但是也可以从多个目录提供内容
contentBase: [path.join(__dirname, 'public'), path.join(__dirname, 'assets')];

// 禁用 contentBase：
contentBase: false;
```

- devServer.disableHostCheck

```js
/**
 * 当设置为true时，此选项绕过主机检查。不推荐这样做，因为不检查主机的应用程序很容易受到DNS重新绑定攻击。
 */
disableHostCheck: true;
```

- devServer.filename

```js
/**
 * filename 在不使用惰性加载时没有效果。
 * 在惰性模式中，此选项可减少编译。 默认在惰性模式，每个请求结果都会产生全新的编译。
 * 使用 filename，可以只在某个文件被请求时编译。
 */

// 如果 output.filename 设置为 bundle.js ，filename 使用如下：
// 只有在请求 /bundle.js 时候，才会编译 bundle。
lazy: true,
filename: "bundle.js"
```

- devServer.headers

```js
/**
 * 在所有响应中添加首部内容
 */
headers: {
  "X-Custom-Foo": "bar"
}
```

- devServer.historyApiFallback

```js
/**
 * 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html
 */

historyApiFallback: true;

// 通过传入配置对象可以进一步控制
historyApiFallback: {
  rewrites: [
    { from: /^\/$/, to: '/views/landing.html' },
    { from: /^\/subpage/, to: '/views/subpage.html' },
    { from: /./, to: '/views/404.html' }
  ];
}

// 当路径中使用点(dot)（常见于 Angular），你可能需要使用 disableDotRule
historyApiFallback: {
  disableDotRule: true;
}
```

- devServer.host

```js
/**
 * 指定使用一个 host。默认是 localhost。如果你希望服务器外部可访问，指定如下：
 */
host: '0.0.0.0';
```

- devServer.hot

```js
/**
 * 启用 webpack 的模块热替换特性
 */
hot: true;
```

- devServer.hotOnly

```js
/**
 * 启用热模块替换(请参阅devServer.hot)，在构建失败时不刷新页面作为回退。
 */
hotOnly: true;
```

- devServer.https

```js
/**
 * 默认情况下，dev-server 通过 HTTP 提供服务。也可以选择带有 HTTPS 的 HTTP/2 提供服务
 */
https: true;

// 以上设置使用了自签名证书，但是你可以提供自己的：
https: {
  key: fs.readFileSync("/path/to/server.key"),
  cert: fs.readFileSync("/path/to/server.crt"),
  ca: fs.readFileSync("/path/to/ca.pem"),
}
```

- devServer.index

```js
/**
 * 被认为是索引文件的文件名。
 */
index: 'index.htm';
```

- devServer.info - CLI only

```js
/**
 * cli信息输出。它是默认启用的
 */
webpack-dev-server --info=false
```

- devServer.inline

```js
/**
 * 默认情况下，应用程序启用内联模式(inline mode)。
 * 这意味着一段处理实时重载的脚本被插入到你的包(bundle)中，并且构建消息将会出现在浏览器控制台

 * 推荐使用模块热替换的内联模式，因为它包含来自 websocket 的 HMR 触发器。
 * 轮询模式可以作为替代方案，但需要一个额外的入口点：'webpack/hot/poll?1000'。

 * 使用 iframe 模式
 * 它在通知栏下面使用 <iframe> 标签，包含了关于构建的消息。
 */

// 使用 iframe 模式
inline: false;
```

- devServer.lazy

```js
/**
 * 当启用 lazy 时，dev-server 只有在请求时才编译包(bundle)。
 * 这意味着 webpack 不会监视任何文件改动。我们称之为“惰性模式”。
 */
lazy: true;
```

- devServer.noInfo

```js
/**
 * 启用 noInfo 后，诸如「启动时和每次保存之后，那些显示的 webpack 包(bundle)信息」的消息将被隐藏。
 * 错误和警告仍然会显示。
 */
noInfo: true;
```

- devServer.open

```js
/**
 * 当启用open时，开发服务器将打开浏览器。
 * 如果没有提供浏览器(如上所示)，则使用默认浏览器。要指定不同的浏览器，只需传递它的名称:
 */
open: true;
webpack-dev-server --open 'Google Chrome'
```

- devServer.openPage

```js
/**
 * 指定打开浏览器时要导航到的页面
 */
openPage: '/different/page';
```

- devServer.overlay

```js
/**
 * 当存在编译器错误或警告时，在浏览器中显示全屏覆盖。默认情况下禁用。如果只想显示编译器错误:
 */
overlay: true;

// 如果你想显示警告和错误:
overlay: {
  warnings: true,
  errors: true
}
```

- devServer.pfx

```js
/**
 * 通过CLI使用SSL .pfx文件的路径。如果在选项中使用，它应该是.pfx文件的字节流。
 */
pfx: '/path/to/file.pfx';
```

- devServer.pfxPassphrase

```js
/**
 * 将密码转换为SSL PFX文件。
 */
pfxPassphrase: 'passphrase';
```

- devServer.port

```js
/**
 * 指定要监听请求的端口号
 */
port: 8080;
```

- devServer.proxy

```js
/**
 * 启用代理服务
 * dev-server 使用了非常强大的 http-proxy-middleware 包
 */

// 在 localhost:3000 上有后端服务的话，你可以这样启用代理
// 请求到 /api/users 现在会被代理到请求 http://localhost:3000/api/users
proxy: {
  "/api": "http://localhost:3000"
}

// 如果你不想始终传递 /api ，则需要重写路径
proxy: {
  "/api": {
    target: "http://localhost:3000",
    pathRewrite: {"^/api" : ""}
  }
}

// 默认情况下，不接受运行在 HTTPS 上，且使用了无效证书的后端服务器。如果你想要接受，修改配置如下：
proxy: {
  "/api": {
    target: "https://other-server.example.com",
    secure: false
  }
}

// 有时你不想代理所有的请求。可以基于一个函数的返回值绕过代理。
// 在函数中你可以访问请求体、响应体和代理选项。必须返回 false 或路径，来跳过代理请求
// 对于浏览器请求，你想要提供一个 HTML 页面，但是对于 API 请求则保持代理
proxy: {
  "/api": {
    target: "http://localhost:3000",
    bypass: function(req, res, proxyOptions) {
      if (req.headers.accept.indexOf("html") !== -1) {
        console.log("Skipping proxy for browser request.");
        return "/index.html";
      }
    }
  }
}

// 如果你想代理多个特定的路径到同一个目标，你可以使用一个数组的一个或多个对象与上下文属性:
proxy: [{
  context: ["/auth", "/api"],
  target: "http://localhost:3000",
}]
```

- devServer.progress - 只用于命令行工具(CLI)

```js
/**
 * 将运行进度输出到控制台
 */
 webpack-dev-server --progress
```

- devServer.public

```js
/**
 * 当使用内联模式(inline mode)并代理 dev-server 时，内联的客户端脚本并不总是知道要连接到什么地方。
 * 它会尝试根据 window.location 来猜测服务器的 URL，但是如果失败，你需要这样
 * 例如，dev-server 被代理到 nginx，并且在 myapp.test 上可用
 */
public: 'myapp.test:80';
```

- devServer.publicPath

```js
/**
 * 确保 publicPath 总是以斜杠(/)开头和结尾。
 * 默认 publicPath 是 "/"，所以你的包(bundle)可以通过 http://localhost:8080/bundle.js 访问
 */

// 可以修改 publicPath，将 bundle 放在一个目录
// 你的包现在可以通过 http://localhost:8080/assets/bundle.js 访问
publicPath: '/assets/';

// 也可以使用一个完整的 URL。这是模块热替换所必需的。
publicPath: 'http://localhost:8080/assets/';
```

- devServer.quiet

```js
/**
 * 启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。
 * 这也意味着来自 webpack 的错误或警告在控制台不可见。
 */
quiet: true;
```

- devServer.socket

```js
/**
 * 要监听的Unix套接字(而不是主机)。
 */
socket: 'socket';
```

- devServer.staticOptions

```js
/**
 * 可以为contentBase中的静态文件配置高级选项。
 * 这只在使用contentBase作为字符串时有效。
 */
staticOptions: {
  redirect: false;
}
```

- devServer.stats

```js
/**
 * 此选项允许您精确地控制显示哪些bundle信息。如果你想要一些捆绑信息，这是一个不错的中间地带，但不是所有的。
 * 当与quiet或noInfo一起使用时，此选项没有效果。
 */

// 只显示包中的错误:
stats: 'errors-only';
```

- devServer.stdin - CLI only

```js
/**
 * 此选项在stdin结束时关闭服务器。
 */
webpack-dev-server --stdin
```

- devServer.useLocalIp

```js
/**
 * 此选项允许浏览器使用本地IP打开
 */
useLocalIp: true;
```

- devServer.watchContentBase

```js
/**
 * 此选项允许浏览器使用本地IP打开
 */
```

- devServer.watchContentBase

```js
/**
 * 告诉服务器查看由devServer提供的文件。contentBase选项。文件更改将触发重新加载整个页面。
 * 默认情况下是禁用的
 */
watchContentBase: true;
```

- devServer.watchOptions

```js
/**
 * 与监视文件相关的控制选项
 * webpack 使用文件系统(file system)获取文件改动的通知。
 * 在某些情况下，不会正常工作。
 */

// 例如，当使用 Network File System (NFS) 时。Vagrant 也有很多问题。在这些情况下，请使用轮询：
watchOptions: {
  poll: true;
}
```

## devtool

```js
/**
 * 此选项控制是否生成，以及如何生成 source map。
 * 使用 SourceMapDevToolPlugin 进行更细粒度的配置。
 * 查看 source-map-loader 来处理已有的 source map

 * 你可以直接使用 SourceMapDevToolPlugin/EvalSourceMapDevToolPlugin 来替代使用 devtool 选项，
 * 因为它有更多的选项。切勿同时使用 devtool 选项和 SourceMapDevToolPlugin/EvalSourceMapDevToolPlugin 插件。
 * devtool 选项在内部添加过这些插件，所以你最终将应用两次插件。
 */
```

- 对于开发环境

```js
/**
 * eval - 此选项会非常快地构建。主要缺点是不能正确的显示行数。
 * eval-source-map 初始化 source map 时比较慢，但是会在重新构建时提供比较快的速度，
   行数能够正确映射，因为会映射到原始代码中。(开发环境推荐使用)
 * cheap-eval-source-map 它没有生成列映射(column mapping)，只是映射行数。
 * cheap-module-eval-source-map 类似 cheap-eval-source-map
 */
```

- 对于生产环境

```js
/**
 * (none)（省略 devtool 选项） - 不生成 source map。这是一个不错的选择。
 * source-map - 整个 source map 作为一个单独的文件生成。
   它为 bundle 添加了一个引用注释，以便开发工具知道在哪里可以找到它。
   你应该将你的服务器配置为，不允许普通用户访问 source map 文件！
 * hidden-source-map 不会为 bundle 添加引用注释
 * nosources-source-map 创建的 source map 不包含 sourcesContent(源代码内容) 
   这仍然会暴露反编译后的文件名和结构，但它不会暴露原始代码。
 */
```

## 构建目标(targets)

- 基本使用

```js
/**
 * 告知 webpack 为目标(target)指定一个环境
 * web编译为类浏览器环境里可用（默认）
 */
module.exports = {
  target: 'node'
};

// 如果传入一个函数，此函数调用时会传入一个 compiler 作为参数
// 如果你不需要使用以上任何插件
const options = {
  target: () => undefined
};

// 或者可以使用你想要指定的插件
const webpack = require('webpack');

const options = {
  target: compiler => {
    compiler.apply(
      new webpack.JsonpTemplatePlugin(options.output),
      new webpack.LoaderTargetPlugin('web')
    );
  }
};
```

## watch 和 watchOptions

- watch

```js
/**
 * 启用 Watch 模式。这意味着在初始构建之后，webpack 将继续监听任何已解析文件的更改。
 * Watch 模式默认关闭。

 * webpack-dev-server 和 webpack-dev-middleware 里 Watch 模式默认开启
 */
watch: false;
```

- watchOptions

```js
/**
 * 一组用来定制 Watch 模式的选项：
 */

watchOptions: {
  aggregateTimeout: 300,
  poll: 1000
}
```

- watchOptions.aggregateTimeout

```js
/**
 * 当第一个文件更改，会在重新构建前增加延迟。这个选项允许 webpack 将这段时间内进行的任何其他更改都聚合到一次重新构建里。
 * 以毫秒为单位：
 */
aggregateTimeout: 300; // 默认值
```

- watchOptions.ignored

```js
/**
 * 这个选项可以排除监控一些巨大的文件夹
 */
ignored: /node_modules/;

// 也可以使用 anymatch 模式：
ignored: 'files/**/*.js';
```

- watchOptions.poll

```js
/**
 * 通过传递 true 开启 polling，或者指定毫秒为单位进行轮询。
 */
poll: 1000; // 每秒检查一次变动
```

- info-verbosity

```js
/**
 * info-verbosity 默认设置为 info。
 * 设置为 verbose，会额外在增量构建的开始和结束时，向控制台发送消息
 * webpack --watch --info-verbosity verbose
 */
```

## 外部扩展(externals)

- externals

```js
/**
 * 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖

 * root：可以通过一个全局变量访问 library（例如，通过 script 标签）。
 * commonjs：可以将 library 作为一个 CommonJS 模块访问。
 * commonjs2：和上面的类似，但导出的是 module.exports.default.
 * amd：类似于 commonjs，但使用 AMD 模块系统。
 */

// 例如，从 CDN 引入 jQuery，而不是把它打包：
// index.html
<script
  src="https://code.jquery.com/jquery-3.1.0.js"
  integrity="sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk="
  crossorigin="anonymous">
</script>

// webpack.config.js
externals: {
  jquery: 'jQuery'
}

// index.js
import $ from 'jquery';
$('.my-element').animate(...);
```

- string

```js
/**
 * 属性名称是 jquery，表示应该排除 import $ from 'jquery' 中的 jquery 模块。
 * jQuery 的值将被用来检索一个全局的 jQuery 变量。
 * 换句话说，当设置为一个字符串时，它将被视为全局的（定义在上面和下面）
 */
// webpack.config.js
externals: {
  jquery: 'jQuery';
}
```

- array

```js
/**
 * subtract: ['./math', 'subtract'] 转换为父子结构，其中 ./math 是父模块，而 bundle 只引用 subtract 变量下的子集。
 */
externals: {
  subtract: ['./math', 'subtract'];
}
```

- object

```js
/**
 * 此语法用于描述外部 library 所有可用的访问方式。
 * 这里 lodash 这个外部 library 可以在 AMD 和 CommonJS 模块系统中通过 lodash 访问，
 * 但在全局变量形式下用 _ 访问。

 * subtract 可以通过全局 math 对象下的属性 subtract 访问（例如 window['math']['subtract']）。
 */
externals : {
  react: 'react'
}

// 或者

externals : {
  lodash : {
    commonjs: "lodash",
    amd: "lodash",
    root: "_" // 指向全局变量
  }
}

// 或者

externals : {
  subtract : {
    root: ["math", "subtract"]
  }
}
```

- function

```js
/**
 * 定义自己的函数来控制想要从webpack外部化的行为可能会很有用。
 * 例如，webpack-node-externals将node_modules目录中的所有模块排除在外，并为(例如)白名单包提供一些选项。
 */
externals: [
  function(context, request, callback) {
    if (/^yourregex$/.test(request)){
      return callback(null, 'commonjs ' + request);
    }
    callback();
  }
],
```

- regex

```js
/**
 * externals: /^(jquery|\$)$/i
 */
```

## 性能(performance)

- performance

```js
/**
 * 配置如何展示性能提示。例如，如果一个资源超过 250kb，webpack 会对此输出一个警告来通知你。
 */
```

- performance.hints

```js
/**
 * 打开/关闭提示。
 */

// 不展示警告或错误提示
performance: {
  hints: false;
}

// 将展示一条警告 开发环境推荐设置
performance: {
  hints: 'warning';
}

//将展示一条错误 生产环境推荐配置
performance: {
  hints: 'error';
}
```

- performance.maxEntrypointSize

```js
/**
 * 此选项根据入口起点的最大体积，控制 webpack 何时生成性能提示。默认值是：250000 (bytes)。
 */
performance: {
  maxEntrypointSize: 400000;
}
```

- performance.maxAssetSize

```js
/**
 * 根据单个资源体积，控制 webpack 何时生成性能提示。默认值是：250000 (bytes)。
 */
performance: {
  maxAssetSize: 100000;
}
```

- performance.assetFilter

```js
/**
 * 允许 webpack 控制用于计算性能提示的文件
 */
function(assetFilename) {
    return !(/\.map$/.test(assetFilename))
};

// 通过传递自己的函数来覆盖此属
// 只给出 .js 文件的性能提示
performance: {
  assetFilter: function(assetFilename) {
    return assetFilename.endsWith('.js');
  }
}
```

## Node

```js
/**
 * 使Node.js 环境编写的代码，在其他环境（如浏览器）中运行
 * 此功能由 webpack 内部的 NodeStuffPlugin 插件提供。
 * 如果 target 是 "web"（默认）或 "webworker"，那么 NodeSourcePlugin 插件也会被激活。
 */
```

- node

```js
/**
*
 * 从 webpack 3.0.0 开始，node 选项可能被设置为 false，以完全关闭 NodeStuffPlugin 和 NodeSourcePlugin 插件。
 */

// 默认配置
node: {
  console: false,
  global: true,
  process: true,
  __filename: "mock",
  __dirname: "mock",
  Buffer: true,
  setImmediate: true

  // 更多选项，请查看“其他 Node.js 核心库”
}
```

- node.console

```js
/**
 * 默认值：false
 * 浏览器提供一个 console 对象，具有非常类似 Node.js console 的接口，所以通常不需要 polyfill。
 */
```

- node.process

```js
/**
 * boolean | "mock"
 * 默认值：true
 */
```

- node.global

```js
/**
 * 默认值：true
 */
```

- node.\_\_filename

```js
/**
 * 默认值："mock"
 * true: 输入文件的文件名，是相对于 context 选项。
 * false: 常规的 Node.js __filename 行为。在 Node.js 环境中运行时，输出文件的文件名。
 * "mock": value 填充为 "index.js".
 */
```

- node.\_\_dirname

```js
/**
 * 默认值："mock"
 * true: 输入文件的目录名，是相对于 context 选项。
 * false: 常规的 Node.js __dirname 行为。在 Node.js 环境中运行时，输出文件的目录名。
 * "mock": value 填充为 "/"。
 */
```

- node.Buffer

```js
/**
 * boolean | "mock"
 * 默认值：true
 */
```

- node.setImmediate

```js
/**
 * boolean | "mock" | "empty"
 * 默认值：true
 */
```

- 其他 Node.js 核心库(Node.js core libraries)

```js
/**
 * boolean | "mock" | "empty"
 * 只有当 target 是未指定、"web" 或 "webworker" 这三种情况时，此选项才会被激活（通过 NodeSourcePlugin）。
 * 当 NodeSourcePlugin 插件启用时，则会使用 node-libs-browser 来对 Node.js 核心库 polyfill
 */
node: {
  dns: "mock",
  fs: "empty",
  path: true,
  url: false
}
```

## 统计信息(stats)

- stats

```js
/**
 * 如果你不希望使用 quiet 或 noInfo 这样的不显示信息，而是又不想得到全部的信息，
 * 只是想要获取某部分 bundle 的信息，使用 stats 选项是比较好的折衷方式。
 * 在使用 Node.js API 时，此选项无效。
 * 对于 webpack-dev-server，这个属性要放在 devServer 对象里。
 */
stats: 'errors-only';

// 更加精细的配置信息，下列的配置项都是可选的
stats: {

  // 未定义选项时，stats 选项的备用值(fallback value)（优先级高于 webpack 本地默认值）
  all: undefined,

  // 添加资源信息
  assets: true,

  // 对资源按指定的字段进行排序
  // 你可以使用 `!field` 来反转排序。
  assetsSort: "field",

  // 添加构建日期和构建时间信息
  builtAt: true,

  // 添加缓存（但未构建）模块的信息
  cached: true,

  // 显示缓存的资源（将其设置为 `false` 则仅显示输出的文件）
  cachedAssets: true,

  // 添加 children 信息
  children: true,

  // 添加 chunk 信息（设置为 `false` 能允许较少的冗长输出）
  chunks: true,

  // 将构建模块信息添加到 chunk 信息
  chunkModules: true,

  // 添加 chunk 和 chunk merge 来源的信息
  chunkOrigins: true,

  // 按指定的字段，对 chunk 进行排序
  // 你可以使用 `!field` 来反转排序。默认是按照 `id` 排序。
  chunksSort: "field",

  // 用于缩短 request 的上下文目录
  context: "../src/",

  // `webpack --colors` 等同于
  colors: false,

  // 显示每个模块到入口起点的距离(distance)
  depth: false,

  // 通过对应的 bundle 显示入口起点
  entrypoints: false,

  // 添加 --env information
  env: false,

  // 添加错误信息
  errors: true,

  // 添加错误的详细信息（就像解析日志一样）
  errorDetails: true,

  // 将资源显示在 stats 中的情况排除
  // 这可以通过 String, RegExp, 获取 assetName 的函数来实现
  // 并返回一个布尔值或如下所述的数组。
  excludeAssets: "filter" | /filter/ | (assetName) => ... return true|false |
    ["filter"] | [/filter/] | [(assetName) => ... return true|false],

  // 将模块显示在 stats 中的情况排除
  // 这可以通过 String, RegExp, 获取 moduleSource 的函数来实现
  // 并返回一个布尔值或如下所述的数组。
  excludeModules: "filter" | /filter/ | (moduleSource) => ... return true|false |
    ["filter"] | [/filter/] | [(moduleSource) => ... return true|false],

  // 和 excludeModules 相同
  exclude: "filter" | /filter/ | (moduleSource) => ... return true|false |
    ["filter"] | [/filter/] | [(moduleSource) => ... return true|false],

  // 添加 compilation 的哈希值
  hash: true,

  // 设置要显示的模块的最大数量
  maxModules: 15,

  // 添加构建模块信息
  modules: true,

  // 按指定的字段，对模块进行排序
  // 你可以使用 `!field` 来反转排序。默认是按照 `id` 排序。
  modulesSort: "field",

  // 显示警告/错误的依赖和来源（从 webpack 2.5.0 开始）
  moduleTrace: true,

  // 当文件大小超过 `performance.maxAssetSize` 时显示性能提示
  performance: true,

  // 显示模块的导出
  providedExports: false,

  // 添加 public path 的信息
  publicPath: true,

  // 添加模块被引入的原因
  reasons: true,

  // 添加模块的源码
  source: true,

  // 添加时间信息
  timings: true,

  // 显示哪个模块导出被用到
  usedExports: false,

  // 添加 webpack 版本信息
  version: true,

  // 添加警告
  warnings: true,

  // 过滤警告显示（从 webpack 2.4.0 开始），
  // 可以是 String, Regexp, 一个获取 warning 的函数
  // 并返回一个布尔值或上述组合的数组。第一个匹配到的为胜(First match wins.)。
  warningsFilter: "filter" | /filter/ | ["filter", /filter/] | (warning) => ... return true|false
};
```

## 其它选项(other options)

- amd

```js
/**
 * 设置 require.amd 或 define.amd 的值：
 */
amd: {
  jQuery: true;
}
```

- amd

```js
/**
 * 在第一个错误出现时抛出失败结果，而不是容忍它。
 * 默认情况下，当使用 HMR 时，webpack 会将在终端以及浏览器控制台中，以红色文字记录这些错误，但仍然继续进行打包。
 * 要启用它：
 * bail: true
 * 这将迫使 webpack 退出其打包过程。
 */
```

- cache

```js
/**
 * 缓存生成的 webpack 模块和 chunk，来改善构建速度。
 * 缓存默认在观察模式(watch mode)启用。禁用缓存只需简单传入：
 */
cache: false;

// 如果传递一个对象，webpack 将使用这个对象进行缓存。保持对此对象的引用，将可以在 compiler 调用之间共享同一缓存：
let SharedCache = {};

export default {
  ...,
  cache: SharedCache
}
```

- loader

```js
/**
 * 在 loader 上下文中暴露自定义值
 */
```

- parallelism

```js
/**
 * 限制并行处理模块的数量。可用于微调性能或获得更可靠的分析结果。
 */
```

- profile

```js
/**
 * 捕获一个应用程序"配置文件"，包括统计和提示，然后可以使用 Analyze 分析工具进行详细分析
 */
```

- recordsPath

```js
/**
 * 开启这个选项可以生成一个 JSON 文件，其中含有 webpack 的 "records" 记录
 * 即「用于存储跨多次构建(across multiple builds)的模块标识符」的数据片段。
 * 如果你使用了代码分离(code splittnig)这样的复杂配置，records 会特别有用。这些数据用于确保拆分 bundle，以便实现你需要的缓存(caching)行为。
 */
recordsPath: path.join(__dirname, 'records.json');
```

- recordsInputPath

```js
/**
 * 指定读取最后一条记录的文件的名称。这可以用来重命名一个记录文件，
 */
```

- recordsOutputPath

```js
/**
 * 指定记录要写入的位置。以下示例描述了如何用这个选项和 recordsInptuPaht 来重命名一个记录文件
 */
recordsInputPath: path.join(__dirname, 'records.json'),
recordsOutputPath: path.join(__dirname, 'newRecords.json')
```
