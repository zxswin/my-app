# 创建 library

## 预期设计

```bash
# 库的设计
# 不打包 lodash，而是使用 externals 来 require 用户加载好的 lodash。
# 设置 library 的名称为 webpack-numbers.
# 将 library 暴露为一个名为 webpackNumbers的变量。
# 能够访问其他 Node.js 中的 library。

# 库的引用方式
# ES2015 模块。例如 import webpackNumbers from 'webpack-numbers'。
# CommonJS 模块。例如 require('webpack-numbers').
# 全局变量，当通过 script 脚本引入时
```

- 使用方法

```js
// ES2015 模块引入
import webpackNumbers from 'webpack-numbers';

// CommonJS 模块引入
var webpackNumbers = require('webpack-numbers');

// ...
// ES2015 和 CommonJS 模块调用
webpackNumbers.wordToNum('Two');

// ...
// AMD 模块引入
require(['webpackNumbers'], function(webpackNumbers) {
  // ...
  // AMD 模块调用
  webpackNumbers.wordToNum('Two');
  // ...
});
```

- 用户还可以通过 script 标签来加载和使用此 library

```html
<!DOCTYPE html>
<html>
  ...
  <script src="https://unpkg.com/webpack-numbers"></script>
  <script>
    // ...
    // 全局变量
    webpackNumbers.wordToNum('Five');
    // window 对象中的属性
    window.webpackNumbers.wordToNum('Five');
    // ...
  </script>
</html>
```

## 具体实现步骤

- 一个简单 npm 模块的创建

```bash
# 创建zxstestnpm文件夹

# 创建package.json文件
{
  "name": "zxstestnpm",
  "version": "1.0.0",
  "description": "my first npm module",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "zxswin",
  "license": "ISC"
}

# 创建index.js文件
module.exports = function() {
  console.log('我的第一个npm模块！');
};

```

- npm 发包流程(假设模块已经创建好了)

```bash
# 第一步注册npm账号
# npm账号注册地址：https://www.npmjs.com/signup。

# 第二步登录
# 命令行中输入 npm login

# 发布 npm publish
# 命令行在当前文件夹中，直接输入npm publish既可发布模块
# 若不在当前文件夹中，则需要输入npm publish 你的文件夹名字
npm publish testnpm

# 删除模块
# npm --force unpublish 你的模块名，来删除发布的模块（超过24小时就不能删除了）

## 更新模块
## 可以通过修改package文件中的版本好
## 通过npm publish 命令更新

# 注意要点
# 包的名字被占用了，可以通过访问npm的网站来进行包的搜索该模块是否存在
# npm view 你的模块名，来查看模块是否发布成功
# 登录失败的原因1,修改镜像地址
# npm config set registry https://registry.npmjs.org/

## 关于npm 包的更新问题
## 使用npm update <packName> -S 更新包
## package.json文件中的版本好也会同步更新

## 通过npm i <packName>  重新安装会同时更新package.json文件中的版本号
## 通过npm install 安装依赖的时候会把库中所引用的依赖也一并下载

```

- 使用 npm 包

```bash
# 创建项目
npm init -y
# 安装 npm包
npm i zxstestnpm -S

# 在index.js文件中使用
const zxswin = require('zxstestnpm');
zxswin();

```

## 使用 webpack 创建 npm 模块

- 目录及文件

```bash
# 基本项目结构
+  |- webpack.config.js
+  |- package.json
+  |- /src
+    |- index.js
+    |- ref.json

# 初始化 npm，安装 webpack 和 lodash
npm init -y
npm install --save-dev webpack-cli webpack webpack-dev-server lodash

# src/ref.json
[{
  "num": 1,
  "word": "One"
}, {
  "num": 2,
  "word": "Two"
}, {
  "num": 3,
  "word": "Three"
}, {
  "num": 4,
  "word": "Four"
}, {
  "num": 5,
  "word": "Five"
}, {
  "num": 0,
  "word": "Zero"
}]

# src/index.js
import _ from 'lodash';
import numRef from './ref.json';

export function numToWord(num) {
  return _.reduce(numRef, (accum, ref) => {
    return ref.num === num ? ref.word : accum;
  }, '');
};

export function wordToNum(word) {
  return _.reduce(numRef, (accum, ref) => {
    return ref.word === word && word.toLowerCase() ? ref.num : accum;
  }, -1);
};

```

- 基本配置

```bash
# 不打包 lodash，而是使用 externals 来 require 用户加载好的 lodash。

# webpack.config.js 中的配置
var path = require('path');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'webpack-numbers.js',
    library: 'webpackNumbers',
    libraryTarget: 'umd'
  },
  plugins: [new CleanWebpackPlugin()],

  // 放弃对外部 library 的控制 不打包 lodash
  externals: {
    lodash: {
      commonjs: 'lodash',
      commonjs2: 'lodash',
      amd: 'lodash',
      root: '_'
    }
  }
};

# package.json文件
{
  "name": "zxswin-webpack-numbers",
  "version": "1.0.0",
  "description": "zxswinlibrary cmd and commonjs",
  "main": "dist/webpack-numbers.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "clean-webpack-plugin": "^3.0.0",
    "webpack": "^4.34.0",
    "webpack-cli": "^3.3.4",
    "webpack-dev-server": "^3.7.1"
  },
  "dependencies": {
    "lodash": "^4.17.11"
  }
}

```

## 关于模块化

- CommonJS 规范

```js
/**
 * 它采用同步步方式加载模块，必须等模块加载完才会执行后面的语句。
 * 所有代码都运行在模块作用域，不会污染全局作用域。
 * 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
 * 模块加载的顺序，按照其在代码中出现的顺序。
 * 通过require来加载模块；
 * 通过exports和module.exports来暴露模块中的内容；

 * CommonJS模块的加载机制是，输入的是被输出的值的拷贝。
 * 也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。

 * 为了方便，Node为每个模块提供一个exports变量，指向module.exports。
 * var exports = module.exports;

 * 模块的循环加载
 * 如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。
 */
var math = require('sum');
var x = 5;
var addX = math.add();
module.exports.x = x;
module.exports.addX = addX;
```

- AMD 规范

```js
/**
 * AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。
 * 采用异步方式加载模块，模块的加载不影响它后面语句的运行。
 * 所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。
 * 反复 require 相同的模块，它只加载一次

 * AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：
 * require([module], callback);
 * 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；
 * 第二个参数callback，则是加载成功之后的回调函数。
 */

// math.js
define(function() {
  var add = function(x, y) {
    return x + y;
  };
  return {
    add: add
  };
});

// main.js 中使用
require(['math'], function(math) {
  alert(math.add(1, 1));
});
```

- UMD 规范

```js
/**
 * 兼容AMD和CommonJS的规范，还兼容全局引用的方式。因此在浏览器和服务器的环境都可以应用此规范。
 * 实际上就是一个兼容性的写法
 */
(function(name, definition) {
  // 检测上下文环境是否为AMD或CMD
  if (typeof define === 'function' && (define.amd || define.cmd)) {
    define(definition);

    // 检测上下文环境是否为Node
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = definition();
  } else {
    // 将模块的执行结果在window变量中，在浏览器中this指向window对象
    this[name] = definition();
  }
})('hello', function() {
  var hello = function() {};
  return hello;
});
```

- CMD 规范

```js
/**
 * 执行时机处理不同
 * CMD是在AMD基础上改进的一种规范，和AMD不同在于对依赖模块的执行时机处理不同，
 * CMD是就近依赖，而AMD是前置依赖。也就是说AMD要在一开始就加载所有的依赖，而CMD是一级一级的加载。
 * SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行
 * SeaJS只会在真正需要使用(依赖)模块时才执行该模块
 * SeaJS是异步加载模块的没错, 但执行模块的顺序也是严格按照模块在代码中出现(require)的顺序,
 * 模块的加载都是并行的, 没有区别, 区别在于执行模块的时机, 或者说是解析.


 * RequireJS的做法是并行加载所有依赖的模块, 并完成解析后, 再开始执行其他代码, 因此执行结果只会"停顿"1次, 完成整个过程是会比SeaJS要快.
 * SeaJS一样是并行加载所有依赖的模块, 但不会立即执行模块, 等到真正需要(require)的时候才开始解析, 这里耗费了时间, 因为这个特例中的模块巨大, 因此造成"停顿"2次的现象, 这就是我所说的SeaJS中的"懒执行".
  */
```

## ES6 的模块化

- ES6 的模块化 与 CommonJS 规范的区别

```js
/**
 * 主要区别
 * import是ES6标准中的模块化解决方案，require是node中遵循CommonJS规范的模块化解决方案
 *
 * import 不支持动态引入但是已经有提案
 * require支持动态引入，也就是require(${path}/xx.js)
 *
 * import是关键词，require不是
 *
 * import是编译时加载，必须放在模块顶部，在性能上会比后者好一些，
 * require是运行时加载，理论上来说放在哪里都可以
 *
 * import采用的是实时绑定方式，即导入和导出的值都指向同一个内存地址，所以导入值会随着导出值变化。
 * require在导出时是值的拷贝，就算导出的值变化了，导入的值也不会变化，如果想要更新值就要重新导入
 *
 * import会编译成require/exports来执行

 * 代码是在模块作用域,模块内部的顶层变量，外部不可见。
 * 模块脚本自动采用严格模式，不管有没有声明use strict。
 * 模块之中，可以使用import命令加载其他模块 .js后缀不可省略
 * 也可以使用export命令输出对外接口
 * 模块之中，顶层的this关键字返回undefined，而不是指向window。
 * 同一个模块如果加载多次，将只执行一次。
 */
```

- ES6 模块化的优势

```js
/**
 * CommonJS 和 AMD 模块，都只能在运行时确定依赖关系
 * CommonJS 模块就是对象，输入时必须查找对象属性。
 * 导致完全没办法在编译时做“静态优化”。

 * ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
 * ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。
 */

// ES6模块
// 实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载
import { stat, exists, readFile } from 'fs';
```

- export 命令

```js
/**
 * export 命令
 * export命令用于规定模块的对外接口
 * import命令用于输入其他模块提供的功能(接口)
 */

// 使用export命令输出变量
export var firstName = 'Michael';

// export命令除了输出变量，还可以输出函数或类（class）
export function multiply(x, y) {
  return x * y;
}

// 使用as关键字重命名
function v1() { ... }
function v2() { ... }

export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};


/**
  * export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系
  */
// 报错
// 第一种写法直接输出 1，
export 1;

// 报错
// 通过变量m，还是直接输出 1。1只是一个值，不是接口。
var m = 1;
export m;

/**
 * 正确的写法
 * 下面三种写法都是正确的，规定了对外的接口m。
 * 其他脚本可以通过这个接口，取到值1。
 * 它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。
 */


// 写法一
export var m = 1;

// 写法二
var m = 1;
export {m};

// 写法三
var n = 1;
export {n as m};


/**
 * 输出class
  */
// 报错
function f() {}
export f;

// 正确
export function f() {};

// 正确
function f() {}
export {f};

/**
 * export语句输出的接口，与其对应的值是动态绑定关系，
 * 即通过该接口，可以取到模块内部实时的值。
 * 输出变量foo，值为bar，500 毫秒之后变成baz
 * CommonJS 模块输出的是值的缓存，不存在动态更新
 */
export var foo = 'bar';
setTimeout(() => foo = 'baz', 500);


// export命令可以出现在模块的任何位置，只要处于模块顶层就可以。
// 如果处于块级作用域内，就会报错，
// 这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。
function foo() {
  export default 'bar' // SyntaxError
}
foo()

```

- import 命令

```js
/**
 * 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。
 * import命令是编译阶段执行的，在代码运行之前。
 * import语句会执行所加载的模块
 */
import { firstName, lastName, year } from './profile.js';

function setName(element) {
  element.textContent = firstName + ' ' + lastName;
}

/** 使用as关键字，将输入的变量重命名。  */
import { lastName as surname } from './profile.js';

/**
 * import命令输入的变量都是只读的，因为它的本质是输入接口。
 * 不允许在加载模块的脚本里面，改写接口
 */
import { a } from './xxx.js';
a = {}; // Syntax Error : 'a' is read-only;

// 如果a是一个对象，改写a的属性是允许的。
// a的属性可以成功改写，并且其他模块也可以读到改写后的值。
import { a } from './xxx.js';
a.foo = 'hello'; // 合法操作

/**
 * import命令具有提升效果，会提升到整个模块的头部，首先执行。
 * import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，
 * .js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。
 */
foo();
import { foo } from 'my_module';

/**
 * 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构
 * 表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。
 */
 // 报错
import { 'f' + 'oo' } from 'my_module';

// 报错
let module = 'my_module';
import { foo } from module;

// 报错
if (x === 1) {
  import { foo } from 'module1';
} else {
  import { foo } from 'module2';
}

/**
  * import语句会执行所加载的模块
  * 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。
  */
import 'lodash';

// 虽然foo和bar在两个语句中加载
import { foo } from 'my_module';
import { bar } from 'my_module';

// 等同于
import { foo, bar } from 'my_module';
```

- 仅为副作用而导入一个模块

```js
/**
 * 不导入模块中的任何内容（接口）。 这将运行模块中的全局代码, 但实际上不导入任何值。
 */
import '/modules/my-module.js';
```

- import 之 模块的整体加载

```js
/**
 * 用星号（*）指定一个对象，所有输出值都加载在这个对象上面
 */
import * as circle from './circle';

console.log('圆面积：' + circle.area(4));
console.log('圆周长：' + circle.circumference(14));

/**
 * 模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。
 */
import * as circle from './circle';

// 下面两行都是不允许的
circle.foo = 'hello';
circle.area = function() {};
```

- export default 命令

```js
/**
 * export default命令，为模块指定默认输出。
 */

// 默认输出是一个函数
export default function() {
  console.log('foo');
}

// 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。
// 这时import命令后面，不使用大括号。
import customName from './export-default';
customName(); // 'foo'

/**
 * export default命令其实只是输出一个叫做default的变量
 * 它后面不能跟变量声明语句。
 */
// 正确
export var a = 1;

// 正确
var a = 1;
export default a; // export default a的含义是将变量a的值赋给变量default。

// 错误
export default var a = 1;

// 可以直接将一个值写在export default之后。
// export default命令的本质是将后面的值，赋给default变量
// 指定对外接口为default。
// 正确
export default 42;
// 报错
export 42;

/**
  * 一条import语句中，同时输入默认方法和其他接口
  */
import _, { each, forEach } from 'lodash';

export default function (obj) {
  // ···
}

export function each(obj, iterator, context) {
  // 暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法。
}

export { each as forEach };

/**
 * export default也可以用来输出类。
 */
export default class { ... }

// main.js
import MyClass from 'MyClass';
let o = new MyClass();
```

- export 与 import 的复合写法

```js
/**
 * 在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。
 * foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。
 */
export { foo, bar } from 'my_module';

// 可以简单理解为
import { foo, bar } from 'my_module';
export { foo, bar };


/**
 * 模块的接口改名和整体输出
 */
// 接口改名
export { foo as myFoo } from 'my_module';

// 整体输出
export * from 'my_module';

// 默认接口
export { default } from 'foo';

// 具名接口改为默认接口的写法
export { es6 as default } from './someModule';

// 等同于
import { es6 } from './someModule';
export default es6;

// 默认接口也可以改名为具名接口
export { default as es6 } from './someModule';

/**
 * 下面三种import语句，没有对应的复合写法。
 */
import * as someIdentifier from "someModule";
import someIdentifier from "someModule";
import someIdentifier, { namedIdentifier } from "someModule";
```

- 模块的继承

```js
/**
 * circleplus模块，继承了circle模块
 */

// export *，表示再输出circle模块的所有属性和方法。
// export *命令会忽略circle模块的default方法。
export * from 'circle';
export var e = 2.71828182846;
export default function(x) {
  return Math.exp(x);
}

// 以将circle的属性或方法，改名后再输出
// 只输出circle模块的area方法，且将其改名为circleArea。
export { area as circleArea } from 'circle';

// 加载上面模块的写法
import * as math from 'circleplus';
import exp from 'circleplus';
console.log(exp(math.e));
```

- 跨模块常量(转发模块)

```js
/**
 * 常规写法
 */
// constants.js 模块
export const A = 1;
export const B = 3;
export const C = 4;

// test1.js 模块
import * as constants from './constants';
console.log(constants.A); // 1
console.log(constants.B); // 3

// test2.js 模块
import { A, B } from './constants';
console.log(A); // 1
console.log(B); // 3

/**
 * 如果要使用的常量非常多，可以建一个专门的constants目录，
 * 将各种常量写在不同的文件里面，保存在该目录下。
 */
// constants/db.js
export const db = {
  url: 'http://my.couchdbserver.local:5984',
  admin_username: 'admin',
  admin_password: 'admin password'
};

// constants/user.js
export const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];

// constants/index.js 合并在index.js文件里面 对外转发模块
export {db} from './db';
export {users} from './users';

// script.js 使用的时候，直接加载index.js
import {db, users} from './constants/index';
```

## 不同模块规范的加载

```js
/**
 * ES6的模块必须使用import命令加载，不能使用require命令加载
 * CommonJS规范的模块必须使用require命令加载，而不能使用import命令加载

 * ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。
 * ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。
 *
 * 某些顶层变量在 ES6 模块之中都是不存在的
 * arguments require module exports __filename __dirname
 */
```

- ES6 模块加载 CommonJS 模块

```js
/**
 * Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，
 * 即等同于export default xxx。
 * module.exports会被视为默认输出，即import命令实际上输入的是这样一个对象{ default: module.exports }
 */
// a.js
module.exports = {
  foo: 'hello',
  bar: 'world'
};

// 等同于
export default {
  foo: 'hello',
  bar: 'world'
};

/** 拿到 CommonJS 模块的module.exports。  */
// 写法一
import baz from './a';
// baz = {foo: 'hello', bar: 'world'};

// 写法二
import { default as baz } from './a';
// baz = {foo: 'hello', bar: 'world'};

// 写法三
// 可以通过baz.default拿到module.exports。
import * as baz from './a';
// baz = {
//   get default() {return module.exports;},
//   get foo() {return this.default.foo}.bind(baz),
//   get bar() {return this.default.bar}.bind(baz)
// }

/** CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。  */
// foo.js
// module.exports将一直是123，而不会变成null。
module.exports = 123;
setTimeout(_ => (module.exports = null));

/** CommonJS 模块是运行时确定输出接口，所以采用import命令加载 CommonJS 模块时，不允许采用下面的写法。  */
// 不正确
import { readFile } from 'fs';

// 正确的写法一
import * as express from 'express';
const app = express.default();

// 正确的写法二
import express from 'express';
const app = express();
```

- CommonJS 模块加载 ES6 模块

```js
/**
 * CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。
 * ES6 模块的所有输出接口，会成为输入对象的属性。
 */

/** 示例一  */
// es.js
export let foo = { bar: 'my-default' };
export { foo as bar };
export function f() {}
export class c {}

// cjs.js
const es_namespace = await import('./es');
// es_namespace = {
//   get foo() {return foo;}
//   get bar() {return foo;}
//   get f() {return f;}
//   get c() {return c;}
// }

/** 示例二  */
// es.mjs
let foo = { bar: 'my-default' };
export default foo;

// cjs.js
const es_namespace = await import('./es.mjs');
// es_namespace = {
//   get default() {
//     ...
//   }
// }
console.log(es_namespace.default);
// { bar:'my-default' }
```

## 循环加载

- CommonJS 模块的循环加载

```js
/**
 * 一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。
 * CommonJS 输入的是被输出值的拷贝，不是引用
 */

/** a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。  */
exports.done = false;
var b = require('./b.js');
console.log('在 a.js 之中，b.done = %j', b.done);
exports.done = true;
console.log('a.js 执行完毕');

/**  b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，
 * 因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。 即exports.done = false;
 * 对于b.js来说，它从a.js只输入一个变量done，值为false。
 * 然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。
 * a.js接着往下执行，直到执行完毕。
 */
exports.done = false;
var a = require('./a.js');
console.log('在 b.js 之中，a.done = %j', a.done);
exports.done = true;
console.log('b.js 执行完毕');

/** 在main.js中执行  */

var a = require('./a.js');
var b = require('./b.js');
console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done);

// 输出结果
// 在 b.js 之中，a.done = false
// b.js 执行完毕
// 在 a.js 之中，b.done = true
// a.js 执行完毕
// 在 main.js 之中, a.done=true, b.done=true

/**
 * CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。
 * require('a').foo的值很可能后面会被改写，改用require('a')会更保险一点。
 */

var a = require('a'); // 安全的写法
var foo = require('a').foo; // 危险的写法
```

- ES6 模块的循环加载

```js
/**
 * ES6 模块是动态引用
 * 而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。
 */

// a.mjs
import { bar } from './b';
console.log('a.mjs');
console.log(bar);
export let foo = 'foo';

// b.mjs
import { foo } from './a';
console.log('b.mjs');
console.log(foo);
export let bar = 'bar';

/** 执行a.mjs，结果如下。
 * 执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。
 * 执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。
 * 执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。
 */

$ node --experimental-modules a.mjs
b.mjs
ReferenceError: foo is not defined

/**
 * 这可以通过将foo写成函数来解决报错问题
 * 因为函数具有提升作用，在执行import {bar} from './b'时，函数foo就已经有定义了，
 */
// a.mjs
import {bar} from './b';
console.log('a.mjs');
console.log(bar());
function foo() { return 'foo' }
export {foo};

// b.mjs
import {foo} from './a';
console.log('b.mjs');
console.log(foo());
function bar() { return 'bar' }
export {bar};

// $ node --experimental-modules a.mjs
// b.mjs
// foo
// a.mjs
// bar
```
