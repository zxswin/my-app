## TS 的工具类型

- 类型别名

```ts
type Pet = 'cat' | 'dog';
let pet: Pet;

pet = 'cat'; // Ok
pet = 'dog'; // Ok
pet = 'zebra'; // Compiler error
```

- typeof 操作符获取一个变量声明或对象的类型

```ts
interface Person {
  name: string;
  age: number;
}

const sem: Person = { name: 'semlinker', age: 30 };
type Sem = typeof sem; // -> Person

function toArray(x: number): Array<number> {
  return [x];
}

type Func = typeof toArray; // -> (x: number) => number[]
```

- keyof 操作符可以用来一个对象中的所有 key 值

```ts
interface Person {
  name: string;
  age: number;
}

type K1 = keyof Person; // "name" | "age"
type K2 = keyof Person[]; // "length" | "toString" | "pop" | "push" | "concat" | "join"
type K3 = keyof { [x: string]: Person }; // string | number
```

- in 用来遍历枚举类型：

```ts
type Keys = 'a' | 'b' | 'c';

type Obj = {
  [p in Keys]: any;
}; // -> { a: any, b: any, c: any }
```

- 通过 extends 关键字添加泛型约束。

```ts
interface ILengthwise {
  length: number;
}

function loggingIdentity<T extends ILengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}
```

## 内置类型别名

- Partial<T> 的作用就是将某个类型里的属性全部变为可选项 ?

```ts
// 源码解析
type Partial<T> = {
  [P in keyof T]?: T[P];
};

// 代码示例
interface Todo {
  title: string;
  description: string;
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
  return { ...todo, ...fieldsToUpdate };
}

const todo1 = {
  title: 'organize desk',
  description: 'clear clutter',
};

const todo2 = updateTodo(todo1, {
  description: 'throw out trash',
});
```

- Required<T> 的作用就是将某个类型里的属性全部变为必选项

```ts
// 源码解析
// -? 的作用就是移除可选项 ?
type Required<T> = {
  [P in keyof T]-?: T[P];
};

// 代码示例
interface Props {
  a?: number;
  b?: string;
}

const obj: Props = { a: 5 }; // OK
const obj2: Required<Props> = { a: 5 }; // Error: property 'b' missing
```

- Readonly<T> 的作用是将某个类型所有属性变为只读属性，也就意味着这些属性不能被重新赋值

```ts
// 源码解析
// 如果将上面的 readonly 改成 -readonly， 就是移除子属性的 readonly 标识
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

// 代码示例
interface Todo {
  title: string;
}

const todo: Readonly<Todo> = {
  title: 'Delete inactive users',
};

todo.title = 'Hello'; // Error: cannot reassign a readonly property
```

- Record<K extends keyof any, T> 的作用是将 K 中所有的属性的值转化为 T 类型。

```ts
// 源码解析
type Record<K extends keyof any, T> = {
  [P in K]: T;
};

// 代码示例
interface PageInfo {
  title: string;
}

type Page = 'home' | 'about' | 'contact';

const x: Record<Page, PageInfo> = {
  about: { title: 'about' },
  contact: { title: 'contact' },
  home: { title: 'home' },
};
```

- Pick<T, K extends keyof T> 的作用是将某个类型中的子属性挑出来，变成包含这个类型部分属性的子类型。

```ts
// 源码解析
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

// 代码示例
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type TodoPreview = Pick<Todo, 'title' | 'completed'>;

const todo: TodoPreview = {
  title: 'Clean room',
  completed: false,
};
```

- Exclude<T, U> 的作用是将某个类型中属于另一个的类型移除掉

```ts
// 源码解析
type Exclude<T, U> = T extends U ? never : T;

// 代码示例
type T0 = Exclude<'a' | 'b' | 'c', 'a'>; // "b" | "c"
type T1 = Exclude<'a' | 'b' | 'c', 'a' | 'b'>; // "c"
type T2 = Exclude<string | number | (() => void), Function>; // string | number
```

- Extract<T, U> 的作用是从 T 中提取出 U

```ts
// 源码解析
type Extract<T, U> = T extends U ? T : never;

// 代码示例
type T0 = Extract<'a' | 'b' | 'c', 'a' | 'f'>; // "a"
type T1 = Extract<string | number | (() => void), Function>; // () => void
```

- Omit<T, K extends keyof any> 的作用是使用 T 类型中除了 K 类型的所有属性，来构造一个新的类型。

```ts
// 源码解析
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

// 代码示例
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type TodoPreview = Omit<Todo, 'description'>;

const todo: TodoPreview = {
  title: 'Clean room',
  completed: false,
};
```

- NonNullable<T> 的作用是用来过滤类型中的 null 及 undefined 类型

```ts
// 源码解析
type NonNullable<T> = T extends null | undefined ? never : T;

// 代码示例
type T0 = NonNullable<string | number | undefined>; // string | number
type T1 = NonNullable<string[] | null | undefined>; // string[]
```

- ReturnType<T> 的作用是用于获取函数 T 的返回类型

```ts
// 源码解析
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;

// 代码示例
type T0 = ReturnType<() => string>; // string
type T1 = ReturnType<(s: string) => void>; // void
type T2 = ReturnType<<T>() => T>; // {}
type T3 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]
type T4 = ReturnType<any>; // any
type T5 = ReturnType<never>; // any
type T6 = ReturnType<string>; // Error
type T7 = ReturnType<Function>; // Error
```

- InstanceType 的作用是获取构造函数类型的实例类型

```ts
// 源码解析
type InstanceType<T extends new (...args: any) => any> = T extends new (...args: any) => infer R ? R : any;

// 代码示例
class C {
  x = 0;
  y = 0;
}

type T0 = InstanceType<typeof C>; // C
type T1 = InstanceType<any>; // any
type T2 = InstanceType<never>; // any
type T3 = InstanceType<string>; // Error
type T4 = InstanceType<Function>; // Error
```

- ThisType<T> 的作用是用于指定上下文对象的类

```ts
// 源码解析
interface ThisType<T> {}

// 代码示例
// 必须确保 --noImplicitThis 标志设置为 true
interface Person {
  name: string;
  age: number;
}

const obj: ThisType<Person> = {
  dosth() {
    this.name; // string
  },
};
```

- Parameters<T> 的作用是用于获得函数的参数类型组成的元组类型

```ts
// 源码解析
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;

// 代码示例
type A = Parameters<() => void>; // []
type B = Parameters<typeof Array.isArray>; // [any]
type C = Parameters<typeof parseInt>; // [string, (number | undefined)?]
type D = Parameters<typeof Math.max>; // number[]
```

- ConstructorParameters<T> 的作用是提取构造函数类型的所有参数类型。

```ts
// 它会生成具有所有参数类型的元组类型（如果 T 不是函数，则返回的是 never 类型）

// 源码解析
type ConstructorParameters<T extends new (...args: any) => any> = T extends new (...args: infer P) => any ? P : never;

// 代码示例
type A = ConstructorParameters<ErrorConstructor>; // [(string | undefined)?]
type B = ConstructorParameters<FunctionConstructor>; // string[]
type C = ConstructorParameters<RegExpConstructor>; // [string, (string | undefined)?]
```
