## infer 关键字

```ts
/**
 * 类型提取
 * infer 关键字和条件类型
 * 条件类型，使得我们可以根据某些条件得到不同的类型
 * 用 infer 声明一个类型变量并且对它进行使用
 */

interface Dictionary<T = any> {
  [key: string]: T;
}

type StrDict = Dictionary<string>;

type DictMember<T> = T extends Dictionary<infer V> ? V : never;
type StrDictMember = DictMember<StrDict>; // string
```

- Promise 的返回值类型

```ts
async function stringPromise() {
  return 'Hello, Semlinker!';
}

interface Person {
  name: string;
  age: number;
}

async function personPromise() {
  return { name: 'Semlinker', age: 30 } as Person;
}

type PromiseType<T> = (args: any[]) => Promise<T>;
type UnPromisify<T> = T extends PromiseType<infer U> ? U : never;

type extractStringPromise = UnPromisify<typeof stringPromise>; // string
type extractPersonPromise = UnPromisify<typeof personPromise>; // Person
```

- 一个简单的例子

```ts
/**
 * 1.定义了一个名为 extractArrayType 的条件类型，该条件类型会判断是否类型 T 是属于数组类型
 * 2.如果满足条件的话，我们使用 infer 关键字来声明一个新的类型变量 U 并返回该类型 否则返回 never 类型
 */

type extractArrayType<T> = T extends (infer U)[] ? U : never;
let stringType: extractArrayType<['test']> = 'test';

// Type '"test"' is not assignable to type 'never'.
let stringTypeNoArray: extractArrayType<'test'> = 'test'; // Error
```

- 一个复杂一点的例子

```ts
/**
 * 使用泛型语法定义了一个名为 InferredAb 的条件类型
 * 该条件类型会判断是否类型 T 是否包含 a 和 b 属性，
 * 如果满足条件的话，我们使用 infer 关键字来声明一个新的类型变量 U 并返回该类型，否则返回原有的类型 T。
 */

type InferredAb<T> = T extends { a: infer U; b: infer U } ? U : T;
type abInferredNumber = InferredAb<{ a: number; b: number }>; // 返回类型是数值类型
let abinf: abInferredNumber = 1;

type abInferredNumberString = InferredAb<{ a: number; b: string }>; // 返回类型是联合类型 number | string。
let abinfstr: abInferredNumberString = 1;
abinfstr = 'test';
```

- RetrunType 可获取方法的返回类型

```ts
/**
 * 为什么 ReturnType<string> 和 ReturnType<Function> 会抛出上述的异常
 */

type T0 = ReturnType<() => string>; // string
type T1 = ReturnType<(s: string) => void>; // void
type T2 = ReturnType<<T>() => T>; // {}
type T3 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]
type T4 = ReturnType<any>; // any
type T5 = ReturnType<never>; // any

// Type 'string' does not satisfy the constraint '(...args: any) => any'.
type T6 = ReturnType<string>; // Error
// Type 'Function' does not satisfy the constraint '(...args: any) => any'.
// Type 'Function' provides no match for the signature '(...args: any): any'.
type T7 = ReturnType<Function>; // Error
```

- 通过 infer 关键字来获取方法的返回类型

```ts
type Fn1 = (a: number) => string;
type ArgType<T> = T extends (a: infer U) => any ? U : never;

type Fn1Arg = ArgType<Fn1>; // number
```

- 获取元组类型所有参数的类型

```ts
type VariadicFn<A extends any[]> = (...args: A) => any;
type ArgsType<T> = T extends VariadicFn<infer A> ? A : never;

type Fn2 = (a: number, b: string) => string;
type Fn2Args = ArgsType<Fn2>; // [number, string]
```
