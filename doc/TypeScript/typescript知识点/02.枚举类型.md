## 枚举类型

```ts
/**
 * 使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。
 * TypeScript支持数字的和基于字符串的枚举。
 */
```

- 数字枚举

```ts
/** 数字枚举可以实现反向映射  */
enum RequestMethod {
  Get,
  Post,
  Put,
  Delete,
  Options,
  Head,
  Patch,
}

let requestMethod = RequestMethod.Get;
console.log(requestMethod); // 0

/** 被编译后 */
'use strict';
var RequestMethod;
(function (RequestMethod) {
  RequestMethod[(RequestMethod['Get'] = 0)] = 'Get';
  RequestMethod[(RequestMethod['Post'] = 1)] = 'Post';
  RequestMethod[(RequestMethod['Put'] = 2)] = 'Put';
  RequestMethod[(RequestMethod['Delete'] = 3)] = 'Delete';
  RequestMethod[(RequestMethod['Options'] = 4)] = 'Options';
  RequestMethod[(RequestMethod['Head'] = 5)] = 'Head';
  RequestMethod[(RequestMethod['Patch'] = 6)] = 'Patch';
})(RequestMethod || (RequestMethod = {}));

console.log(requestMethod);
```

- 字符串枚举

```ts
/** 字符串枚举不可以实现反向映射 */
enum MediaTypes {
  JSON = 'application/json',
  XML = 'application/xml',
}

// 编译后
var MediaTypes;
(function (MediaTypes) {
  MediaTypes['JSON'] = 'application/json';
  MediaTypes['XML'] = 'application/xml';
})(MediaTypes || (MediaTypes = {}));
```

- 常量枚举

```ts
/**
 * 默认情况下常量枚举是不会生成任何映射代码的
 */
const enum RequestMethod {
  Get,
  Post,
  Put,
  Delete,
  Options,
  Head,
  Patch,
}

let methods = [RequestMethod.Get, RequestMethod.Post, RequestMethod.Put];

// 编译后
'use strict';
var methods = [0 /* Get */, 1 /* Post */, 2 /* Put */];

/**
 * 如果希望生成映射地面 我们可以设置preserveConstEnums 编译器选项为 true
 */
{
  "compilerOptions": {
    "target": "es5",
    "preserveConstEnums": true
  }
}

```

- 枚举成员的引用

```ts
/**
 * 枚举成员默认使用大写字母开头的命名方式
 * 也可以使用方括号来引用包含非法字符的枚举成员
 */

enum HttpRequestField {
  'Accept',
  'Accept-Charset',
  'Accept-Datetime',
  'Accept-Encoding',
  'Accept-Language',
}

assert.equal(HttpRequestField['Accept-Charset'], 1);
```

- 一个简单的枚举使用案例

```ts
enum NoYes {
  No,
  Yes,
}

function toChinese(value: NoYes) {
  switch (value) {
    case NoYes.No:
      return '否';
    case NoYes.Yes:
      return '是';
  }
}

assert.equal(toChinese(NoYes.No), '否');
assert.equal(toChinese(NoYes.Yes), '是');
```
