## TypeScript 入门

- TypeScript 基础类型

```ts
/** 1.Boolean 类型 */
let isDone: boolean = false;

/** 2. Number 类型 */
let count: number = 10;

/** 3.String 类型 */
let name: string = 'Semliker';

/** 4.Array 类型 */
let list: number[] = [1, 2, 3];
let list: Array<number> = [1, 2, 3]; // Array<number>泛型语法

/**
 * 5.Enum 类型
 * 数字枚举相对字符串枚举多了 “反向映射”
 */

// === 数字枚举
enum Direction {
  NORTH,
  SOUTH,
  EAST,
  WEST,
}

let dir: Direction = Direction.NORTH;

// === 字符串枚举
enum Direction {
  NORTH = 'NORTH',
  SOUTH = 'SOUTH',
  EAST = 'EAST',
  WEST = 'WEST',
}

// === 异构枚举
enum Enum {
  A,
  B,
  C = 'C',
  D = 'D',
  E = 8,
  F,
}

/**
 * 6.Any 类型
 * 任何类型都可以被归为 any 类型 也被称为全局超级类型
 */
let value: any;

value.foo.bar; // OK
value.trim(); // OK
value(); // OK
new value(); // OK
value[0][1]; // OK

/**
 * 7.Unknown 类型
 */

// === 所有类型都可以赋值给unknown

let value: unknown;

value = true; // OK
value = 42; // OK
value = 'Hello World'; // OK
value = []; // OK
value = {}; // OK
value = Math.random; // OK
value = null; // OK
value = undefined; // OK
value = new TypeError(); // OK
value = Symbol('type'); // OK

// === unknown类型的只能赋值给unknow或any类型
let value: unknown;
let value1: unknown = value; // OK
let value2: any = value; // OK
let value3: boolean = value; // Error
let value4: number = value; // Error
let value5: string = value; // Error
let value6: object = value; // Error
let value7: any[] = value; // Error
let value8: Function = value; // Error

// === 一下操作会被认为是类型不正确的
let value: unknown;

value.foo.bar; // Error
value.trim(); // Error
value(); // Error
new value(); // Error
value[0][1]; // Error

/**
 * 8.Tuple 类型
 * 数组中可以存储不同类型的值
 */
let tupleType: [string, boolean];
tupleType = ['Semlinker', true];

/**
 * 9.Void类型 表示没有任何类型 例如当一个函数没有返回值的时候
 * Void类型的值只能是undefined 或null;
 */
function warnUser(): void {
  console.log('This is my warning message');
}

/**
 * 10.Null 和 Undefined 类型
 * 默认Null 和 Undefined是所有类型的子类型 可以赋值给任何类型的变量
 * 如果编译选项指定了 --strictNullChecks表示 则null和underfined只能赋值给它们各自的类型或void
 */

let u: undefined = undefined;
let n: null = null;

/**
 * 11.Never类型
 * never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。
 *  返回never的函数必须存在无法达到的终点
 */

function error(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}

// === 可以利用 never 类型的特性来实现全面性检查
// === 使用Never避免出现新增了联合类型没有对应的实现 目的就是写出类型绝对安全的代码
type Foo = string | number;

function controlFlowAnalysisWithNever(foo: Foo) {
  if (typeof foo === 'string') {
    // 这里 foo 被收窄为 string 类型
  } else if (typeof foo === 'number') {
    // 这里 foo 被收窄为 number 类型
  } else {
    // foo 在这里是 never
    const check: never = foo;
  }
}
```

- TypeScript 断言

```ts
/** 尖括号语法  */
let someValue: any = 'this is a string';
let strLength: number = (<string>someValue).length;

/** as 语法  */
let someValue: any = 'this is a string';
let strLength: number = (someValue as string).length;
```

- 类型守卫

```ts
/**
 * 尝试检测属性,方法,或原型,以确定如何处理值
 */

// === in 关键字
interface Admin {
  name: string;
  privileges: string[];
}

interface Employee {
  name: string;
  startDate: Date;
}

type UnknownEmployee = Employee | Admin;

function printEmployeeInformation(emp: UnknownEmployee) {
  console.log('Name: ' + emp.name);
  if ('privileges' in emp) {
    console.log('Privileges: ' + emp.privileges);
  }
  if ('startDate' in emp) {
    console.log('Start Date: ' + emp.startDate);
  }
}

// === typeof 关键字
function padLeft(value: string, padding: string | number) {
  if (typeof padding === 'number') {
    return Array(padding + 1).join(' ') + value;
  }
  if (typeof padding === 'string') {
    return padding + value;
  }
  throw new Error(`Expected string or number, got '${padding}'.`);
}

// === instanceof 关键字
interface Padder {
  getPaddingString(): string;
}

class SpaceRepeatingPadder implements Padder {
  constructor(private numSpaces: number) {}
  getPaddingString() {
    return Array(this.numSpaces + 1).join(' ');
  }
}

class StringPadder implements Padder {
  constructor(private value: string) {}
  getPaddingString() {
    return this.value;
  }
}

let padder: Padder = new SpaceRepeatingPadder(6);

if (padder instanceof SpaceRepeatingPadder) {
  // padder的类型收窄为 'SpaceRepeatingPadder'
}

// === 自定义类型保护的类型谓语
function isNumber(x: any): x is number {
  return typeof x === 'number';
}

function isString(x: any): x is string {
  return typeof x === 'string';
}
```

- 联合类型和类型别名

```ts
// === 简单的联合类型
// 可以把string 或 undefined类型传递给sayHello函数
const sayHello = (name: string | undefined) => {
  /* ... */
};
sayHello('Semlinker');
sayHello(undefined);

// === 可辨识联合
enum CarTransmission {
  Automatic = 200,
  Manual = 300,
}

interface Motorcycle {
  vType: 'motorcycle'; // discriminant
  make: number; // year
}

interface Car {
  vType: 'car'; // discriminant
  transmission: CarTransmission;
}

interface Truck {
  vType: 'truck'; // discriminant
  capacity: number; // in tons
}

// 创建一个联合类型
type Vehicle = Motorcycle | Car | Truck;

// 实现类型守卫
const EVALUATION_FACTOR = Math.PI;
function evaluatePrice(vehicle: Vehicle) {
  switch (vehicle.vType) {
    case 'car':
      return vehicle.transmission * EVALUATION_FACTOR;
    case 'truck':
      return vehicle.capacity * EVALUATION_FACTOR;
    case 'motorcycle':
      return vehicle.make * EVALUATION_FACTOR;
  }
}

// === 类型别名用来给一个类型起一个新名字
type Message = string | string[];

let greet = (message: Message) => {
  // ...
};
```

- 交叉类型

```ts
/**
 * 把多个类型合为已个类型,包含所有类型的特性
 */

interface IPerson {
  id: string;
  age: number;
}

interface IWorker {
  companyId: string;
}

type IStaff = IPerson & IWorker;

const staff: IStaff = {
  id: 'E1006',
  age: 33,
  companyId: 'EFT',
};

console.dir(staff);
```

- TypeScript 函数

```ts
// === 参数类型和返回类型
function createUserId(name: string, id: number): string {
  return name + id;
}

// === 函数类型
let IdGenerator: (chars: string, nums: number) => string;

function createUserId(name: string, id: number): string {
  return name + id;
}

IdGenerator = createUserId;

// === 可选参数及默认参数
// 可选参数
// 可选参数必须要放在普通参数的后面
function createUserId(name: string, id: number, age?: number): string {
  return name + id;
}

// 默认参数
function createUserId(name: string = 'Semlinker', id: number, age?: number): string {
  return name + id;
}

// === 剩余参数
function push(array, ...items) {
  items.forEach(function (item) {
    array.push(item);
  });
}

let a = [];
push(a, 1, 2, 3);

// === 函数重载
// === 使用相同名称和不同参数数量或类型创建多个方法
function add(a: number, b: number): number;
function add(a: string, b: string): string;
function add(a: string, b: number): string;
function add(a: number, b: string): string;
function add(a: Combinable, b: Combinable) {
  if (typeof a === 'string' || typeof b === 'string') {
    return a.toString() + b.toString();
  }
  return a + b;
}

// === 方法的重载
class Calculator {
  add(a: number, b: number): number;
  add(a: string, b: string): string;
  add(a: string, b: number): string;
  add(a: number, b: string): string;
  add(a: Combinable, b: Combinable) {
    if (typeof a === 'string' || typeof b === 'string') {
      return a.toString() + b.toString();
    }
    return a + b;
  }
}

const calculator = new Calculator();
const result = calculator.add('Semlinker', ' Kakuqo');
```

- 数组

```ts
// === 数组解构
let x: number;
let y: number;
let z: number;
let five_array = [0, 1, 2, 3, 4];
[x, y, z] = five_array;

// === 数组展开运算符
let two_array = [0, 1];
let five_array = [...two_array, 2, 3, 4];

// === 数组遍历
let colors: string[] = ['red', 'green', 'blue'];
for (let i of colors) {
  console.log(i);
}
```

- TypeScript 对象

```ts
// === 对象解构
let person = {
  name: 'Semlinker',
  gender: 'Male',
};

let { name, gender } = person;

// === 对象展开运算符
let person = {
  name: 'Semlinker',
  gender: 'Male',
  address: 'Xiamen',
};

// 组装对象
let personWithAge = { ...person, age: 33 };

// 获取除了某些项外的其它项
let { name, ...rest } = person;
```

- TypeScript 接口

```ts
// === 描述对象的形状
interface Person {
  name: string;
  age: number;
}

let Semlinker: Person = {
  name: 'Semlinker',
  age: 33,
};

// === 可选 | 只读属性
interface Person {
  readonly name: string;
  age?: number;
}

// 确保数组被创建后不能被修改
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```

- TypeScript 类

```ts
// === 类的属性和方法
class Greeter {
  // 静态属性
  static cname: string = 'Greeter';
  // 成员属性
  greeting: string;

  // 构造函数 - 执行初始化操作
  constructor(message: string) {
    this.greeting = message;
  }

  // 静态方法
  static getClassName() {
    return 'Class name is Greeter';
  }

  // 成员方法
  greet() {
    return 'Hello, ' + this.greeting;
  }
}

let greeter = new Greeter('world');

// === 编译后的ES5方法
'use strict';
var Greeter = /** @class */ (function () {
  // 构造函数 - 执行初始化操作
  function Greeter(message) {
    this.greeting = message;
  }
  // 静态方法
  Greeter.getClassName = function () {
    return 'Class name is Greeter';
  };
  // 成员方法
  Greeter.prototype.greet = function () {
    return 'Hello, ' + this.greeting;
  };
  // 静态属性
  Greeter.cname = 'Greeter';
  return Greeter;
})();
var greeter = new Greeter('world');

// === 访问器
let passcode = 'Hello TypeScript';

class Employee {
  private _fullName: string;

  get fullName(): string {
    return this._fullName;
  }

  set fullName(newName: string) {
    if (passcode && passcode == 'Hello TypeScript') {
      this._fullName = newName;
    } else {
      console.log('Error: Unauthorized update of employee!');
    }
  }
}

let employee = new Employee();
employee.fullName = 'Semlinker';
if (employee.fullName) {
  console.log(employee.fullName);
}

// === 类的继承
// 通过使用extends关键字来实现继承
class Animal {
  name: string;

  constructor(theName: string) {
    this.name = theName;
  }

  move(distanceInMeters: number = 0) {
    console.log(`${this.name} moved ${distanceInMeters}m.`);
  }
}

class Snake extends Animal {
  constructor(name: string) {
    super(name);
  }

  move(distanceInMeters = 5) {
    console.log('Slithering...');
    super.move(distanceInMeters);
  }
}

let sam = new Snake('Sammy the Python');
sam.move();

// === ECMAScript 私有字段
// 私有字段以 # 字符开头，有时我们称之为私有名称；
// 每个私有字段名称都唯一地限定于其包含的类；
// 不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；
// 私有字段不能在包含的类之外访问，甚至不能被检测到。

class Person {
  #name: string;

  constructor(name: string) {
    this.#name = name;
  }

  greet() {
    console.log(`Hello, my name is ${this.#name}!`);
  }
}

let semlinker = new Person('Semlinker');

semlinker.#name;
// 在外部访问私有属性会报错
// Property '#name' is not accessible outside class 'Person'
// because it has a private identifier.
```

- TypeScript 泛型

```ts
/** 泛型接口  */
interface GenericIdentityFn<T> {
  (arg: T): T;
}

/** 泛型类  */
class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function (x, y) {
  return x + y;
};

/** 泛型变量  */
// T（Type）：表示一个 TypeScript 类型
// K（Key）：表示对象中的键类型
// V（Value）：表示对象中的值类型
// E（Element）：表示元素类型

// === 泛型工具类型

// typeof 操作符可以用来获取一个变量声明或对象的类型
interface Person {
  name: string;
  age: number;
}

const sem: Person = { name: 'semlinker', age: 30 };
type Sem = typeof sem; // -> Person

function toArray(x: number): Array<number> {
  return [x];
}

type Func = typeof toArray; // -> (x: number) => number[]

// === keyof 操作符可以用来一个对象中的所有 key 值
interface Person {
  name: string;
  age: number;
}

type K1 = keyof Person; // "name" | "age"
type K2 = keyof Person[]; // "length" | "toString" | "pop" | "push" | "concat" | "join"
type K3 = keyof { [x: string]: Person }; // string | number

// in 用来遍历枚举类型
type Keys = 'a' | 'b' | 'c';

type Obj = {
  [p in Keys]: any;
}; // -> { a: any, b: any, c: any }

// ==== infer
// 在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用
// infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

// 可以通过extends关键字添加类型约束
// 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型

interface ILengthwise {
  length: number;
}

function loggingIdentity<T extends ILengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}

// Partial<T> 的作用就是将某个类型里的属性全部变为可选项 ?
type Partial<T> = {
  [P in keyof T]?: T[P];
};

// 代码示例
interface Todo {
  title: string;
  description: string;
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
  return { ...todo, ...fieldsToUpdate };
}

const todo1 = {
  title: 'organize desk',
  description: 'clear clutter',
};

const todo2 = updateTodo(todo1, {
  description: 'throw out trash',
});
```

## TypeScript 装饰器

- 什么是装饰器

```ts
/**
 * 它是一个表达式
 * 该表达式被执行后，返回一个函数
 * 函数的入参分别为 target、name 和 descriptor
 * 执行该函数后，可能返回 descriptor 对象，用于配置 target 对象
 *
 * 装饰器的分类
 * 1.类装饰器
 * 2.属性装饰器
 * 3.方法装饰器
 * 4.参数装饰器
 */
```

- 类装饰器

```ts
/**
 * 类装饰器的声明
 * 它接收一个参数:target: TFunction - 被装饰的类
 */
declare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;

/** 简单的示例  */
function Greeter(target: Function): void {
  target.prototype.greet = function (): void {
    console.log('Hello Semlinker!');
  };
}

@Greeter
class Greeting {
  constructor() {
    // 内部实现
  }
}

let myGreeting = new Greeting();
myGreeting.greet();

/** 可添加参数的类装饰器  */
function Greeter(greeting: string) {
  return function (target: Function) {
    target.prototype.greet = function (): void {
      console.log(greeting);
    };
  };
}

@Greeter('Hello TS!')
class Greeting {
  constructor() {
    // 内部实现
  }
}

let myGreeting = new Greeting();
myGreeting.greet(); // console output: 'Hello TS!';
```

- 属性装饰器

```ts
/** 属性装饰器的声明 */

declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;

/**
 * 属性装饰器
 * 它接收两个参数：
 * target: Object - 被装饰的类。
 * propertyKey: string | symbol - 被装饰类的属性名
 */

function logProperty(target: any, key: string) {
  delete target[key];

  const backingField = '_' + key;

  Object.defineProperty(target, backingField, {
    writable: true,
    enumerable: true,
    configurable: true,
  });

  // property getter
  const getter = function (this: any) {
    const currVal = this[backingField];
    console.log(`Get: ${key} => ${currVal}`);
    return currVal;
  };

  // property setter
  const setter = function (this: any, newVal: any) {
    console.log(`Set: ${key} => ${newVal}`);
    this[backingField] = newVal;
  };

  // Create new property with getter and setter
  Object.defineProperty(target, key, {
    get: getter,
    set: setter,
    enumerable: true,
    configurable: true,
  });

  return target; // 最后需要把装饰类返回 也可以不需要这一步，待定
}

class Person {
  @logProperty
  public name: string;

  constructor(name: string) {
    this.name = name;
  }
}

const p1 = new Person('semlinker');
p1.name = 'kakuqo';
console.log(p1.name);
```

- 方法装饰器

```ts
/** 方法装饰器声明  */
declare type MethodDecorator = <T>(
  target: Object,
  propertyKey: string | symbol,
  descriptor: TypePropertyDescript<T>
) => TypedPropertyDescriptor<T> | void;

/**
 * 方法装饰器的参数
 * target: Object - 被装饰的类
 * propertyKey: string | symbol - 方法名
 * descriptor: TypePropertyDescript - 属性描述符
 */

function LogOutput(tarage: Function, key: string, descriptor: any) {
  let originalMethod = descriptor.value;
  let newMethod = function (...args: any[]): any {
    let result: any = originalMethod.apply(this, args);
    if (!this.loggedOutput) {
      this.loggedOutput = new Array<any>();
    }
    this.loggedOutput.push({
      method: key,
      parameters: args,
      output: result,
      timestamp: new Date(),
    });
    return result;
  };
  descriptor.value = newMethod;
}

class Calculator {
  @LogOutput
  double(num: number): number {
    return num * 2;
  }
}

let calc = new Calculator();
calc.double(11);
// console ouput: [{method: "double", output: 22, ...}]
console.log(calc.loggedOutput);
```

- 参数装饰器

```ts
/** 参数装饰器声明  */
declare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;

/**
 * 参数装饰器
 * 接收三个参数
 * target: Object - 被装饰的类
 * propertyKey: string | symbol - 方法名
 * parameterIndex: number - 方法中参数的索引值
 */

function Log(target: Function, key: string, parameterIndex: number) {
  let functionLogged = key || target.prototype.constructor.name;
  console.log(`The parameter in position ${parameterIndex} at ${functionLogged} has
    been decorated`);
}

class Greeter {
  greeting: string;
  constructor(@Log phrase: string) {
    this.greeting = phrase;
  }
}

// console output: The parameter in position 0
// at Greeter has been decorated
```

## 编译上下文

```ts
/**
 * tsconfig.json 的作用
 * 用于标识 TypeScript 项目的根路径；
 * 用于配置 TypeScript 编译器；
 * 用于指定编译的文件。

 * tsconfig.json 重要字段
 * files - 设置要编译的文件的名称；
 * include - 设置需要进行编译的文件，支持路径模式匹配；
 * exclude - 设置无需进行编译的文件，支持路径模式匹配；
 * compilerOptions - 设置与编译流程相关的选项。
 */
{
  "compilerOptions": {

    /* 基本选项 */
    "target": "es5",                       // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'
    "module": "commonjs",                  // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'
    "lib": [],                             // 指定要包含在编译中的库文件
    "allowJs": true,                       // 允许编译 javascript 文件
    "checkJs": true,                       // 报告 javascript 文件中的错误
    "jsx": "preserve",                     // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'
    "declaration": true,                   // 生成相应的 '.d.ts' 文件
    "sourceMap": true,                     // 生成相应的 '.map' 文件
    "outFile": "./",                       // 将输出文件合并为一个文件
    "outDir": "./",                        // 指定输出目录
    "rootDir": "./",                       // 用来控制输出目录结构 --outDir.
    "removeComments": true,                // 删除编译后的所有的注释
    "noEmit": true,                        // 不生成输出文件
    "importHelpers": true,                 // 从 tslib 导入辅助工具函数
    "isolatedModules": true,               // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.

    /* 严格的类型检查选项 */
    "strict": true,                        // 启用所有严格类型检查选项
    "noImplicitAny": true,                 // 在表达式和声明上有隐含的 any类型时报错
    "strictNullChecks": true,              // 启用严格的 null 检查
    "noImplicitThis": true,                // 当 this 表达式值为 any 类型的时候，生成一个错误
    "alwaysStrict": true,                  // 以严格模式检查每个模块，并在每个文件里加入 'use strict'

    /* 额外的检查 */
    "noUnusedLocals": true,                // 有未使用的变量时，抛出错误
    "noUnusedParameters": true,            // 有未使用的参数时，抛出错误
    "noImplicitReturns": true,             // 并不是所有函数里的代码都有返回值时，抛出错误
    "noFallthroughCasesInSwitch": true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）

    /* 模块解析选项 */
    "moduleResolution": "node",            // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)
    "baseUrl": "./",                       // 用于解析非相对模块名称的基目录
    "paths": {},                           // 模块名到基于 baseUrl 的路径映射的列表
    "rootDirs": [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容
    "typeRoots": [],                       // 包含类型声明的文件列表
    "types": [],                           // 需要包含的类型声明文件名列表
    "allowSyntheticDefaultImports": true,  // 允许从没有设置默认导出的模块中默认导入。

    /* Source Map Options */
    "sourceRoot": "./",                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置
    "mapRoot": "./",                       // 指定调试器应该找到映射文件而不是生成文件的位置
    "inlineSourceMap": true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件
    "inlineSources": true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性

    /* 其他选项 */
    "experimentalDecorators": true,        // 启用装饰器
    "emitDecoratorMetadata": true          // 为装饰器提供元数据的支持
  }
}
```
