## 使用 ES6 语言

- 安装及使用

```bash
# 安装
npm install -D babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime @babel/runtime
# 配置及使用
module: {
    rules: [
      {
        test: /\.js$/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env'],
            plugins: ['@babel/plugin-transform-runtime']
          }
        },
        exclude: /node_modules/
      }
    ]
  },
```

- .babelrc 配置相关说明

```bash
# rc结尾的文件通常代表运行时自动加载的文件
# 在.babelrc配置文件中，主要是对预设（presets）和插件（plugins）进行配置
# 如果在.babelrc文件中配置则不需要再在webpack.config文件中配置
# 推荐配置
{
  "presets": ["@babel/preset-env"],
  "plugins": ["@babel/plugin-transform-runtime"]
}
# plugins告诉Bable使用哪些插件去转换代码
# plugin-transform-runtime 插件用于减少冗余代码将公用部分抽离出来需要和babel-runtime配套使用

# presets告诉Bable转换源码使用来哪些新的语言特性
# env表示包含当前所有的ES标准的最新特性
# stage0,stage1,stage2,stage3,表示阶段数字越小表示涵盖范围越广泛
```

- 引入 @babel/polyfill

```bash
# babel只会转化新的 Javascript 语法，不会转化新的 api
# 例如：Generator / Set / Map 等
# @babel/polyfill 是修改全局的对象的原型，添加不兼容的 api 方法，或者修改不兼容的 api 方法。
# 安装
npm install --save @babel/polyfill

# 在入口文件中使用
import '@babel/polyfill';

```

## 使用 TypeScript 语言

- 安装

```bash
# 安装
npm i -D typescript ts-loader

# 在根目录下新建tsconfig.json文件
{
  "compilerOptions": {
    "noImplicitAny": false,
    "module": "CommonJS",
    "target": "ES5",
    "importHelpers": true,
    "sourceMap": true
  },
  "include": ["./src/*.ts"],
  "exclude": ["node_modules"]
}

# 在webpack中的配置
{
  test: /\.tsx?$/,
  use: 'ts-loader',
  include: path.resolve(__dirname, 'src'),
  exclude: /node_modules/
}
```

## 使用 web-webpack-plugin(推荐使用)

- 安装及简单使用

```bash
# 安装
npm i -D web-webpack-plugin

# 引入依赖
const { WebPlugin } = require('web-webpack-plugin');
# 入口文件配置
entry: {
  app: './src/index'
},

# 插件配置
plugins: [
  new WebPlugin({
    filename: 'index.html',
    template: './src/index.html',
    requires: ['app']
  })
]

```

- 推荐配置

```bash

const { WebPlugin, AutoWebPlugin } = require('web-webpack-plugin');

const autoPlugin = new AutoWebPlugin(
  // 所有页面的入口目录
  './src/',
  {
    // 所有页面采用的模版文件
    template: pageName => {
      return path.resolve('./src', pageName, 'index.html');
    }
  }
);

module.exports = {
  entry: autoPlugin.entry({
    app: './src/app',
  }),
  // 也可以直接
  entry: autoPlugin.entry(),
  plugins: [autoPlugin]
}

```

- 深入学习

```bash
# 一个很好的html-webpack-plugin替代品, 可以使 webpack 以 HTML 为入口和方便的管理多个页面。

# 配置一:自动生成html文件
module.exports = {
	entry: {
		A: './a',
		B: './b',
	},
	plugins: [
		new WebPlugin({
			// 输出的html文件名称或路径，必填，注意不要重名，重名会覆盖相互文件。
			filename: 'index.html',
			// 该html文件依赖的entry，必须是一个数组。依赖的资源的注入顺序按照数组的顺序。
			requires: ['A', 'B'],
		}),
	],
};

# 配置二：使用 html 模版
module.exports = {
	entry: {
		A: './a',
		B: './b',
	},
	plugins: [
		new WebPlugin({
			filename: 'index.html',
			// html模版文件路径（相对于webpack.config.js的完整路径）
			template: './template.html',
			requires: ['A', 'B'],
		}),
	],
};

## html模版文件及说明
<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
  <!--加载一个在webpack里配置输出的chunk文件-->
  <script src="B"></script>
  <!--直接加载一个本地的文件的原内容，不走webpack的打包逻辑-->
  <link rel="stylesheet" href="./reset.min.css?_inline">
  <!--直接加载一个本地的文件的原内容，不走webpack的打包逻辑-->
  <script src="./google-analyze.js"></script>
</head>
<body>
<!--SCRIPT-->
<footer>web-webpack-plugin</footer>
</body>
</html>

1.<script src="B"></script> 引入需要的 entry，src="B" 中的 B 为 chunk 配置的名称
2.注释<!--SCRIPT-->
除开通过<script src></script>引入的资源外，在 requires 里配置的剩下的依赖的资源应该被注入的地方，
如果模版没有出现<!--SCRIPT-->就放在body标签的最后


# 配置资源属性
针对每一个 html 依赖的资源，有如下属性可以配置：
1._dist 只有在生产环境下才引入该资源
2._dev 只有在开发环境下才引入该资源
3._inline 把该资源的内容潜入到 html 里
4._ie 只有 IE 浏览器才需要引入的资源，通过 [if IE]>resource<![endif] 注释实现

# 配置示例
module.exports = {
	entry: {
		'ie-polyfill': './ie-polyfill',
		inline: './inline',
		dev: './dev',
		googleAnalytics: './google-analytics',
	},
	plugins: [
		new WebPlugin({
			filename: 'index.html',
			template: './template.html',
		}),
	],
};

<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
  <script src="inline?_inline"></script>
  <script src="ie-polyfill?_ie"></script>
</head>
<body>
<script src="dev?_dev"></script>
<!--直接加载本地google analyze文件而不加载本地var webpack-->
<script async src="./google-analytics.js?_dist"></script>
</body>
</html>

# 给 HTML 标签注入属性
对于其它的非 _ 开头的属性，会认为这个属性是要被当作 HTML 标签属性注入到生产的 HTML 文件里去的，
例如在 script 资源后带上属性 ?crossorigin=anonymous 输出的 HTML 将会是 <script src="B.js" crossorigin="anonymous"></script>

# AutoWebPlugin 自动探测 html 入口(用于管理多个单页面运用)
# AutoWebPlugin 可以找到一个目录下所有的页面入口，
# 自动为所有的页面入口配置一个WebPlugin输出对应的 html
const autoPlugin = new AutoWebPlugin(
	// 所有页面的入口目录
	'./src/pages',
	{
		// 以下所有的属性都不是必须的，按照需要选填

		// {string,function}
		// 所有页面采用的模版文件
		// 如果 template 的类型是 string，template代表模版文件的相对于当前目录根目录的全文件路径
		// 如果 template 的类型是 function，template代表可自定义逻辑的函数 function(pageName)=>newFullPath，告诉你当前页面名称你返回一个新的路径代表当前页面的模版路径
		template: './src/template.html',

		// { function(pageName,templateFullPath)=>htmlString }
		// 如果提供了的话，在AutoWebPlugin使用这个模版先先用模版编译器（比如ejs）编译后再使用编译后的结果
		templateCompiler: (pageName, templateFullPath) => '',

		// 当前页面的javascript入口文件，如果为空就使用当前page目录下的 index.js 作为入口
		// 如果 entry 的类型是 string，entry代表入口文件的相对于当前目录根目录的全文件路径
		// 如果 entry 的类型是 function，entry代表可自定义逻辑的函数 function(pageName)=>newFullPath，告诉你当前页面名称你返回一个新的路径代表当前页面的入口路径
		entry: null,

		// {function}
		// 每个page输出的html的名称，默认按照文件夹名称作为html名称，
		// 设置 filename 为 function(pageName)=>filename 类型 可添加自定义逻辑
		filename: null,

		// 在所有入口页面的entry前插入
		preEntrys: ['./path/to/file1.js'],

		// 在所有入口页面的entry后插入
		postEntrys: ['./path/to/file2.js'],

		// {string} publicPath for css file,for js file will use webpack.publicPath
		stylePublicPath: null,

		// page name list will not ignore by AutoWebPlugin(Not output html file for this page name)
		ignorePages: ['pageName'],

		// 是否输出一个名叫 pagemap.json 的文件，这个文件包含所有被AutoWebPlugin解析到的2入口页面，文件格式如下
		// {"page name": "page url",}
		outputPagemap: true,
	}
);

module.exports = {
	// AutoWebPlugin 会为在 './src/pages' 目录下找到的每个目录生成一个 entry
	// autoPlugin.entry({}) 用来向webpack配置传入在线 AutoWebPlugin 找出的 entry，好让webpack知道它们
	entry: autoPlugin.entry({
		youAdditionalEntryName: 'you additional entry path',
	}),
};

# 效果说明

源代码目录结构
── src
│   ├── home
│   │   └── index.js
│   ├── ie_polyfill.js
│   ├── login
│   │   └── index.js
│   ├── polyfill.js
│   ├── signup
│   │   └── index.js
│   └── template.html

输出的目录结构
├── dist
│   ├── common.js
│   ├── home.html
│   ├── home.js
│   ├── ie_polyfill.js
│   ├── login.html
│   ├── login.js
│   ├── polyfill.js
│   ├── signup.html
│   └── signup.js

AutoWebPlugin 插件找出了./src/目录下所有的目录 home login signup:

针对这 3 个目录分别读取目录里的 index.js 作为入口生成三个 chunk home login signup
生成三个 html 文件 home.html login.html signup.html
在每个生成的 html 里自动注入了该 html 所依赖的资源（例如 home.html 会自动注入 home chunk）

## ignorePages 属性
ignorePages 被忽略的页面名称列表，被忽略的页面将不会被 AutoWebPlugin 处理产生对于的 html 文件，类型是元素为字符串的数组。

## template 属性
template 当 template 为字符串是，我看作为 html 模版文件的路径（相对于 webpack.config.js 的路径）。在复杂的情况下你可以设置 template 为一个函数，如下使用当前页面目录下的 index.html 文件作为当前页面的模版文件
new AutoWebPlugin('./src/', {
	// 所有页面采用的模版文件
	template: (pageName) => {
		return path.resolve('./src', pageName, 'index.html');
	},
});

## entry 属性
entry 属性 和 template 类似，同样也支持回调函数应对复杂情况。但是如果 entry 为空就使用当前页面目录下的 index.jsx? 作为入口


## 注意(必须要有一个index的文件夹不然开发模式下不能正常打开默认页面)


```

## 使用 html-webpack-plugin (选用)

- 多入口文件配置

```bash
const HtmlWebpackPlugin = require('html-webpack-plugin');

entry: {
  home: './src/app/home/index.ts',
  list: './src/app/list/index.ts'
},
plugins: [
  // 生成第一个html文件
  new HtmlWebpackPlugin({
    chunks: ['home'], //添加引入的js,也就是entry中的key
    filename: 'index.html',
    hash: true,
    title: 'home页面',
    template: './src/app/home/index.html' //模板地址
  }),
  // 生成第二个html文件
  new HtmlWebpackPlugin({
    chunks: ['list'], //添加引入的js,也就是entry中的key
    filename: 'list.html',
    // minify: {
    //   collapseWhitespace: true //折叠空白区域 也就是压缩代码
    // },
    hash: true,
    title: '第二个页面',
    template: './src/app/list/index.html' //模板地址
  }),
]

```

## 使用 html-loader 让 html 支持 src 及 attr-src 的图片引入

```bash
# 安装html-loader
npm i -D html-loader

# 配置 esModule: false 要记得设置为false
// 图片资源的解析
{
  test: /\.(png|jpg|gif)$/i,
  use: [
    {
      loader: 'url-loader',
      options: {
        limit: 8192,
        esModule: false // 这里设置为false 不然html-loader解析的图片是 [object Module]
      }
    },
    {
      loader: 'image-webpack-loader'
    }
  ],
  exclude: /node_modules/
},

// svg,字体等资源的解析
{
  test: /\.(woff|woff2|eot|ttf|otf|svg)$/i,
  use: [
    {
      loader: 'file-loader',
      options: {
        esModule: false // 这里设置为false 不然html-loader解析的图片是 [object Module]
      }
    },
    {
      loader: 'image-webpack-loader'
    }
  ],
  exclude: /node_modules/
},

// 解析html文件
{
  test: /\.(htm|html)$/,
  use: {
    loader: 'html-loader',
    options: {
      attrs: ['img:src', ':data-src']
    }
  }
},

```

## ExtractTextPlugin 分离 css 代码

```bash
# 安装style-loader插件
# 安装css-loader插件 新版本的css_loader不支持压缩
# 安装postcss-loader插件
# 安装postcss-cssnext插件
npm i -D style-loader css-loader postcss-loader postcss-cssnext

# 安装mini-css-extract-plugin用于分离css代码
npm install --save-dev mini-css-extract-plugin

# 安装对less的支持插件
npm i -D less-loader

# 安装对sass的支持插件
npm i -D sass-loader node-sass

# 配置
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

// 解析css文件
{
  test: /\.(less|css)$/,
  use: [
    {
      loader: MiniCssExtractPlugin.loader,
      options: {
        esModule: true
      }
    },
    {
      loader: 'css-loader',
      options: {
        sourceMap: true
      }
    },
    {
      loader: 'postcss-loader',
      options: {
        sourceMap: true,
        ident: 'postcss',
        plugins: [
          require('postcss-preset-env')({
            browsers: 'last 5 versions',
            autoprefixer: { grid: true }
          })
        ]
      }
    },
    {
      loader: 'less-loader',
      options: {
        sourceMap: true
      }
    }
  ],
  exclude: /node_modules/
}

plugins: [
  new MiniCssExtractPlugin({
    filename: '[name]_[hash:8].css'
  })
]

```

## 图片和 SVG 等资源的加载

- 加载图片

```bash
# 安装file-loader
# 可以将js和css中导入的图片语句替换成正确的地址,同时将文件输出到对应的位置
npm i -D file-loader

# 安装url-loader
# 可以将文件的内容经过base64编码后注入js和css中,适用于小图片的注入
# 通过limit选项控制文件大小小于limit才使用url-loader
# 超过限制大小的时候,默认会使用file-loader进行处理
npm i - D url-loader

# 处理后图片名称会更改为hash

# 让html文件引入图片资源能被识别并解析
# 通过web-webpack-plugin html中的图片可以被识别但名称没有进行hash处理

# 推荐配置

// 图片资源的解析
{
  test: /\.(png|jpg|gif)$/i,
  use: [
    {
      loader: 'url-loader',
      options: {
        limit: 8192
      }
    }
  ]
},

// svg,字体等资源的解析
{
  test: /\.(woff|woff2|eot|ttf|otf|svg)$/i,
  use: [
    {
      loader: 'file-loader'
    }
  ]
}

## 图片的压缩 image-webpack-loader
# 安装image-webpack-loader插件
npm install image-webpack-loader --save-dev
// 图片资源的解析
{
  test: /\.(png|jpg|gif)$/i,
  use: [
    {
      loader: 'url-loader',
      options: {
        limit: 8192
      }
    },
    {
      loader: 'image-webpack-loader'
    }
  ]
},

# 雪碧图的制作
# 安装 webpack-spritesmith
cnpm i webpack-spritesmith -D  安装
# 使用
plugins: [
  // 生成雪碧图
  new SpritesmithPlugin({
    src: {
      cwd: path.resolve(__dirname, 'src/asset/ico'),
      glob: '*.png'
    },
    target: {
      image: path.resolve(__dirname, 'src/asset/sprites/sprite.png'),
      css: path.resolve(__dirname, 'src/asset/sprites/sprite.css')
    },
    apiOptions: {
      cssImageRef: '../../asset/sprites/sprite.png'
    }
  })
]

```

## 数据的加载

- 加载数据

```bash
## JSON文件
## 仅读取了数据 并没有在dist目录下生成json文件
JSON 支持实际上是内置的，也就是说 import Data from './data.json' 默认将正常运行。

## 第一步需要配置tsconfig.json
"resolveJsonModule": true,
"allowSyntheticDefaultImports": true, // 支持没有默认导出的文件

## ts文件中的引入
import * as Data from '../../asset/data/data.json';
console.log(`json数据${JSON.stringify(Data)}`);

```

- CSV、TSV 和 XML 文件的导入

```bash
## 导入 CSV、TSV 和 XML
## 安装csv-loader xml-loader
## csv-loader 依赖于papaparse
npm i papaparse csv-loader xml-loader -D
import * as Data from './data.xml';
console.log(Data);
{
  test: /\.(csv|tsv)$/,
  use: ['csv-loader']
},
{
  test: /\.xml$/,
  use: ['xml-loader']
}
```

## 关于 Source Map devtool 选项的配置

- Source Map 原理

```bash
## 了解Source Map
1.Source map就是一个信息文件，里面储存着位置信息。转换后的代码的每一个位置，所对应的转换前的位置。

## 启用Source map
只要在转换后的代码尾部，加上一行就可以了。
//@ sourceMappingURL=/path/to/file.js.map

```

- Source Map devtool 选项的配置

```bash
# 空
不生成Source Map
# eval
每个module会封装到eval里包裹起来执行,并且会在每个eval语句的末尾追加注释
# source-map
会额外生成一个单独的source map文件,并且会在js的文件末尾追加注释
# hidden-source-map
不会在末尾追加注释
# inline-source-map
不会额外生成一个单独的sourc map文件,而是将source map转换成base64内嵌到js文件中
# eval-source-map
和eval类似但是每个模块的sourc map被装换成base64编码内嵌到eval语句的末尾
#cheap-source-map
和source-map类似,但是生成的文件没有列信息,因此生成速度更快
# cheap-module-source-map
和cheap-source-map类似,但包含Loader生成的source map

```

## 引入 jquery 等第三方库

- 引入 jquery

```bash
# 安装
npm i -S jquery @types/jquery

# 引入 index.ts 业务逻辑文件中,如果配置了ProvidePlugin则无效引入
import * as $ from 'jquery';

## 提取库文件 生成库文件和启动样板文件manifest
entry: {
  main: './src/app/index/index.ts',
  vendor: ['jquery', 'lodash'] // 需要提取的库文件列表
},
plugins: [
  // 当遇到了至少一处用到 lodash 变量的模块实例，自动lodash package包引入进来
  new webpack.ProvidePlugin({
    _: 'lodash',
    $: 'jquery'
  }),
]

optimization: {
  // 提取样板(boilerplate)文件
  runtimeChunk: {
    name: 'manifest'
  },
  splitChunks: {
    cacheGroups: {
      // 库文件提取
      vendor: {
        name: 'vendor', // 提取的chunk的名称
        chunks: 'initial',
        minChunks: 1 // 被多少个模块重复引用的时候进行提取操作
      }
    }
  }
},

```

## 生产环境构建主要要点

```bash
# 设置mode
mode: 'production',

# 文件名称使用hash,当存在模块热替换的情况下chunkhash不可用
output: {
  filename: '[name].[chunkhash:8].js',
  path: path.resolve(__dirname, 'dist')
}

## 抽离出单独的css文件,文件名称使用hash
new MiniCssExtractPlugin({
  filename: '[name].[chunkhash:8].css'
}),

# 清空dist文件夹
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
plugins: [
  // 清空dist文件夹
  new CleanWebpackPlugin(),
]

# 不引入sourcemap
// 生成map文件的形式
devtool: '',


# css文件的压缩优化并去重复
# 安装optimize-css-assets-webpack-plugin插件
npm install --save-dev optimize-css-assets-webpack-plugin

## 处理模块标识符(Module Identifiers)，使得未改动文件保持文件名
plugins: [
  new webpack.HashedModuleIdsPlugin()
]

# 处理模块标识符推荐配置
# NamedModulesPlugin插件，将使用模块的路径，而不是数字标识符
# 虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些
plugins: [
  new webpack.NamedModulesPlugin()
]

```

## 公用 webpack 配置部分的抽离

- 插件安装

```bash
# 安装插件 webpack-merge 用于合并其他的webpack配置文件
const merge = require('webpack-merge');
# 引入公用的webpack配置文件
const common = require('./webpack.common.js');
```

- webpack.common.js

```ts
const webpack = require('webpack');
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const SpritesmithPlugin = require('webpack-spritesmith');

module.exports = {
  entry: {
    main: './src/app/index/index.ts',
    vendor: ['jquery', 'lodash'] // 需要提取的库文件列表
  },
  plugins: [
    // 生成第一个html文件
    new HtmlWebpackPlugin({
      filename: 'index.html',
      title: 'index页面',
      minify: {
        // 压缩HTML文件
        removeComments: true, // 移除HTML中的注释
        collapseWhitespace: true, // 删除空白符与换行符
        minifyCSS: true // 压缩内联css
      },
      template: './src/app/index/index.html' //模板地址
    }),

    // 当遇到了至少一处用到 lodash 变量的模块实例，自动lodash package包引入进来
    new webpack.ProvidePlugin({
      _: 'lodash',
      $: 'jquery'
    }),
    // 生成雪碧图
    new SpritesmithPlugin({
      src: {
        cwd: path.resolve(__dirname, 'src/asset/ico'),
        glob: '*.png'
      },
      target: {
        image: path.resolve(__dirname, 'src/asset/sprites/sprite.png'),
        css: path.resolve(__dirname, 'src/asset/sprites/sprite.css')
      },
      apiOptions: {
        cssImageRef: '../../asset/sprites/sprite.png'
      }
    })
  ],
  module: {
    rules: [
      // 解析js文件
      {
        test: /\.jsx?$/,
        use: 'babel-loader',
        exclude: /node_modules/
      },
      // 解析ts文件
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        include: path.resolve(__dirname, 'src'),
        exclude: /node_modules/
      },
      // 解析less文件
      {
        test: /\.less$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              esModule: true
            }
          },
          {
            loader: 'css-loader',
            options: {
              sourceMap: true
            }
          },
          {
            loader: 'postcss-loader',
            options: {
              sourceMap: true,
              ident: 'postcss',
              plugins: [
                require('postcss-preset-env')({
                  browsers: 'last 5 versions',
                  autoprefixer: { grid: true }
                })
              ]
            }
          },
          {
            loader: 'less-loader',
            options: {
              sourceMap: true
            }
          }
        ]
      },

      // 解析css文件
      {
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              esModule: true
            }
          },
          {
            loader: 'css-loader',
            options: {
              sourceMap: true
            }
          }
        ]
      },
      // 图片资源的解析
      {
        test: /\.(png|jpg|gif)$/i,
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 8192,
              esModule: false // 这里设置为false 不然html-loader解析的图片是 [object Module]
            }
          },
          {
            loader: 'image-webpack-loader'
          }
        ],
        exclude: /node_modules/
      },

      // svg,字体等资源的解析
      {
        test: /\.(woff|woff2|eot|ttf|otf|svg)$/i,
        use: [
          {
            loader: 'file-loader',
            options: {
              esModule: false // 这里设置为false 不然html-loader解析的图片是 [object Module]
            }
          },
          {
            loader: 'image-webpack-loader'
          }
        ],
        exclude: /node_modules/
      },

      // 解析html文件
      {
        test: /\.(htm|html)$/,
        use: {
          loader: 'html-loader',
          options: {
            attrs: ['img:src', ':data-src']
          }
        }
      },

      // 解析csv|tsv|xml
      {
        test: /\.(csv|tsv)$/,
        use: ['csv-loader'],
        exclude: /node_modules/
      },
      {
        test: /\.xml$/,
        use: ['xml-loader'],
        exclude: /node_modules/
      }
    ]
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js']
  },
  optimization: {
    // 提取样板(boilerplate)文件
    runtimeChunk: {
      name: 'manifest'
    },
    splitChunks: {
      cacheGroups: {
        // 库文件提取
        vendor: {
          name: 'vendor', // 提取的chunk的名称
          chunks: 'initial',
          minChunks: 1 // 被多少个模块重复引用的时候进行提取操作
        }
      }
    }
  }
};
```

- webpack.dev.js

```ts
const webpack = require('webpack');
const path = require('path');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

// webpack-merge 用于合并其他的webpack配置文件
const merge = require('webpack-merge');
// 公用的webpack配置文件
const common = require('./webpack.common.js');

const DevConfig = {
  mode: 'development',
  // 生成map文件的形式
  devtool: 'inline-source-map',
  devServer: {
    contentBase: './dist',
    hot: true
  },
  plugins: [
    // 模块热替换 一般mode: 'development',的时候会自动配置
    new webpack.HotModuleReplacementPlugin(),
    // 抽离出单独的css文件
    new MiniCssExtractPlugin({
      filename: '[name].css'
    }),
    // 设置环境变量
    new webpack.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify('development')
    })
  ],
  output: {
    filename: '[name].js',
    path: path.resolve(__dirname, 'dist')
  }
};

module.exports = merge(common, DevConfig);
```

- webpack.prod.js

```ts
const webpack = require('webpack');
const path = require('path');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');
// webpack-merge 用于合并其他的webpack配置文件
const merge = require('webpack-merge');
// 公用的webpack配置文件
const common = require('./webpack.common.js');

const ProdConfig = {
  mode: 'production',
  // 生成map文件的形式
  devtool: '',
  plugins: [
    // 清空dist文件夹
    new CleanWebpackPlugin(),
    // 抽离出单独的css文件
    new MiniCssExtractPlugin({
      filename: '[name].[chunkhash:8].css'
    }),
    // 压缩和优化css文件
    new OptimizeCssAssetsPlugin(),
    // 处理模块标识符(Module Identifiers)，使得未改动文件保持文件名
    new webpack.NamedModulesPlugin(),
    // 设置环境变量
    new webpack.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify('production')
    })
  ],
  optimization: {
    // js代码的压缩和去重
    minimizer: [
      new UglifyJsPlugin({
        uglifyOptions: {
          warnings: false,
          compress: {
            drop_debugger: true, //去掉debugger
            drop_console: true // 去掉console
          }
        },
        sourceMap: false,
        parallel: true
      })
    ]
  },
  output: {
    filename: '[name].[chunkhash:8].js',
    path: path.resolve(__dirname, 'dist')
  }
};

module.exports = merge(common, ProdConfig);
```

## 本地测试服务器搭建

```bash
# 安装安装 http-server 搭建一个服务器
npm i http-server -D

# 在package.json文件中配置脚步 -c-1禁用缓存
"scripts": {
  "http": "http-server -c-1"
},

```

## 性能优化部分

- 缩小文件搜索范围

```bash
# loader中的路径处理
{
  test: /\.tsx?$/,
  use: 'ts-loader',
  include: path.resolve(__dirname, 'src')
},

# 使用绝对路径指明第三方模块的存放位置,已减少搜索步骤
resolve: {
  extensions: ['.tsx', '.ts', '.js'],
  // 使用绝对路径指明第三方模块的存放位置,已减少搜索步骤
  modules: [path.resolve(__dirname, 'node_modules')]
},

## 针对npm中的第三方模块优先采用jsnext:main中指向es6模块化语法的文件
resolve: {
  extensions: ['.tsx', '.ts', '.js'],
  // 使用绝对路径指明第三方模块的存放位置,已减少搜索步骤
  modules: [path.resolve(__dirname, 'node_modules')],
  // 针对npm中的第三方模块优先采用jsnext:main中指向es6模块化语法的文件
  mainFields: ['jsnext:main', 'main', 'browser']
},
```

- 自动刷新(用于开发模式下的优化)

```bash
# webapck模块负责监听文件,webpack-dev-server模块则负责刷新浏览器

// 开启文件监听模式
watch: true,
// 监听模式下运行时的参数
watchOptions: {
  // 不监听的文件或文件夹 支持正则匹配 默认为空
  ignored: /node_modules/,
  // 防止文件更新太快而导致重新编译频率太快,默认300ms
  aggregateTimeout: 300,
  // 询问文件是否变化 默认每秒询问1000次
  poll: 1000
},

```

- 压缩 js | css 代码

```bash
# 压缩js代码
optimization: {
  // js代码的压缩和去重
  minimizer: [
    new UglifyJsPlugin({
      uglifyOptions: {
        warnings: false,
        compress: {
          drop_debugger: true, //去掉debugger
          drop_console: true // 去掉console
        },
        output: {
          comments: false // 删除所有注释
        }
      },
      sourceMap: false,
      parallel: true
    })
  ]
},

# 压缩css代码(可选)
css-loader内置了css压缩插件cssnano
只需要开启minimize选项即可
```

- 开启 Tree Shaking 去除没有用的代码

```bash
# 某些库中通过 package.json 的 "sideEffects" 属性来实现
# 标记为 false，来告知 webpack，它可以安全地删除未用到的 export 导出

## 处理ts和js文件的loader需配置设置modules： false 不转换为CommonJS类型

# 开启Tree Shaking
usedExports: true,
sideEffects: true
```

- webpack 实现按需加载功能(懒加载)

```ts
/**
 * webpack代码配置
 */

optimization: {
  // 提取样板(boilerplate)文件
  runtimeChunk: {
    name: 'manifest'
  },
  splitChunks: {
    // 选择要进行分割的包 可选值： all（推荐）, async(默认，只分隔异步代码), and initial(只分割同步代码)
    // 还可以通过函数来过滤所需的 chunks , chunks (chunk) => chunk.name
    chunks: 'all',

    // 默认，大于30k的包才做代码分割
    minSize: 30000,
    // maxSize：表示抽取出来的文件在压缩前的最大大小，默认为 0，表示不限制最大大小；
    maxSize: 0,
    // 默认，至少被引入一次就进行代码分隔
    minChunks: 1,
    // 默认，浏览器最多并行请求5个js文件,也就是说，分割数量超过5个时，就会停止代码分割了
    maxAsyncRequests: 5,
    // 默认，对于入口文件最多只分割3个js包，超过3个就停止
    maxInitialRequests: 3,
    // 默认，文件名连接符 多个入口文件使用了同一个chunk
    automaticNameDelimiter: '~',
    // 默认，分割后的文件名将根据chunks和cacheGroups自动生成名称。
    name: true,

    // test、priorty和reuseExistingChunk只能用于配置缓存组,cacheGroups会继承上面的配置
    cacheGroups: {
      // 库文件提取
      vendor: {
        name: 'vendor', // 提取的chunk的名称
        test: /[\\/]node_modules[\\/]/,
        minChunks: 1, // 被多少个模块重复引用的时候进行提取操作
        // 默认缓存组的优先级(priotity)是负数 默认自定义缓存组优先级为0
        priority: -10
      },
      default: {
        // default是组名, 分隔不在node_modules里的代码
        minChunks: 2, // 默认
        // 复用已存在的chunk, 比如index.js里引入axios和test.jstest里也引入了axios，那么axios就会被复用
        reuseExistingChunk: true,
        priority: -20 // 默认
      }
    }
  }
},
output: {
  filename: '[name].js',
  path: path.resolve(__dirname, 'dist')
  // chunkFilename: '[name].bundle.js' 不需要配置chunkFilename
}

/**
 * index.ts
 */

function component() {
  var element = document.createElement('div');

  var button = document.createElement('button');
  var br = document.createElement('br');

  button.innerHTML = 'Click me and look at the console!';
  element.innerHTML = 'aaa';
  element.appendChild(br);
  element.appendChild(button);

  button.onclick = e =>
    import(/* webpackChunkName: "b" */ './b').then(module => {
      var print = module.default;

      print();
    });

  return element;
}

document.body.appendChild(component());

/**
 * b.ts
 * 必须使用export default导出
 */
export default () => {
  console.log('b.js文件被加载了');
};
```

- 开启 Scope Hoisting 功能

```bash
# Scope Hoisting 「作用域提升」
使用非 ES6 模块或使用异步 import() 时，不会应用作用域提升 否则会降级处理

# 作用原理
正常来说 webpack 的引入都是把各个模块分开，通过 __webpack_require__ 导入导出模块（对原理不熟悉的话可以看这里），但是使用 scope hoisting 后会把需要导入的文件直接移入导入者顶部，这就是所谓的 hoisting。

# 启用 Scope Hoisting的优点如下：
1. 代码体积会变小，因为函数声明语句会产生大量代码，但是第二个没有函数声明。
2. 代码在运行时因为创建的函数作用域减少了，所以内存开销就变小了。

plugins: [
  // 开启 Scope Hoisting 作用域提升功能
  new webpack.optimize.ModuleConcatenationPlugin()
]
```

## 输出分析

- 安装 webpack-bundle-analyzer

```bash
# 安装
npm i -D webpack-bundle-analyzer

# 使用
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
plugins: [
  // 打包输出分析
  new BundleAnalyzerPlugin()
],
```

## 使用 HappyPack 开启多进程模式提高构建速度(和新版本的 webpack 不兼容)

```bash
# HappyPack将任务分解给多个子进程去并发执行,子进程处理完成后再将结果发送给主进程

# 安装
cnpm install --save-dev happypack

# 使用
const HappyPack = require('happypack');
//构造出一个共享进程池，在进程池中包含5个子进程
const os = require('os');
const happyThreadPool = HappyPack.ThreadPool({
  size: os.cpus().length
});

plugins: [
  // 多进程处理ts文件
  new HappyPack({
    id: 'ts',
    loaders: ['ts-loader'],
    threadPool: happyThreadPool,
    verbose: true
  }),
]

module: {
  rules: [
    // 解析ts文件
    {
      test: /\.tsx?$/,
      use: ['happypack/loader?id=ts'],
      include: path.resolve(__dirname, 'src')
    },
  ]
}
```

## 备注

```bash
mac切换npm到淘宝源
sudo npm install -g cnpm --registry=https://registry.npm.taobao.org
```
