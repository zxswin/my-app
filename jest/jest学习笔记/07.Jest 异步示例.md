## Jest 异步示例


## 简单示例

- 需要被测试的文件

```js
// 首先, 像Jest 从安装开始里面所说的那样, 启用babel的支持
// 让我们实现一个从 API 获取用户数据并返回用户名的模块。

// user.js
import request from './request';
export function getUserName(userID) {
  return request('/users/' + userID).then(user => user.name);
}

// request.js
const http = require('http');
export default function request(url) {
  return new Promise(resolve => {
    // 这是一个HTTP请求的例子, 用来从API获取用户信息
    // This module is being mocked in __mocks__/request.js
    http.get({path: url}, response => {
      let data = '';
      response.on('data', _data => (data += _data));
      response.on('end', () => resolve(data));
    });
  });
}
```

- 对数据进行模拟

```js
// 因为我们在测试中不想去网络，所以我们将​request.js​在​__mocks__​文件夹中为我们的模块创建一个手动模拟（文件夹区分大小写，​__MOCKS__​将不起作用）。就像是这样：

// __mocks__/request.js
const users = {
  4: {name: 'Mark'},
  5: {name: 'Paul'},
};
export default function request(url) {
  return new Promise((resolve, reject) => {
    const userID = parseInt(url.substr('/users/'.length), 10);
    process.nextTick(() =>
      users[userID]
        ? resolve(users[userID])
        : reject({
            error: 'User with ' + userID + ' not found.',
          }),
    );
  });
}
```

- 编写异步测试代码

```js
// __tests__/user-test.js
jest.mock('../request');
import * as user from '../user';
//断言必须返回一个primose
it('works with promises', () => {
  expect.assertions(1);
  return user.getUserName(4).then(data => expect(data).toEqual('Mark'));
});

// .resolves
// 有一种不那么冗长的方法​resolves​用于将已履行的 Promise 的值与任何其他匹配器一起解包。如果 Promise 被拒绝，则断言将失败。
it('works with resolves', () => {
  expect.assertions(1);
  return expect(user.getUserName(5)).resolves.toEqual('Paul');
});
```


- async/await

```js
// 也可以使用​async​/​await​语法编写测试。以下是如何编写与之前相同的示例：
// 要在项目中启用 ​async​/​await​，请在你的​babel.config.js​文件中安装并启用@babel/preset-env功能。
// 使用async/await
it('works with async/await', async () => {
  expect.assertions(1);
  const data = await user.getUserName(4);
  expect(data).toEqual('Mark');
});
// async/await 也可以和 `.resolves` 一起使用.
it('works with async/await and resolves', async () => {
  expect.assertions(1);
  await expect(user.getUserName(5)).resolves.toEqual('Paul');
});


// 错误处理
// 可以使用​ .catch​ 方法处理错误。 请确保添加 ​expect.assertions​ 来验证一定数量的断言被调用。 否则一个fulfilled态的Promise 不会让测试失败︰

//用 Promise.catch 测试一个异步的错误
it('tests error with promises', () => {
  expect.assertions(1);
  return user.getUserName(2).catch(e =>
    expect(e).toEqual({
      error: 'User with 2 not found.',
    }),
  );
});
// Or using async/await.
it('tests error with async/await', async () => {
  expect.assertions(1);
  try {
    await user.getUserName(1);
  } catch (e) {
    expect(e).toEqual({
      error: 'User with 1 not found.',
    });
  }
});
```

- .rejects

```js
// 该​.rejects​助手的工作方式类似于​.resolves​帮手。如果 Promise 被拒绝，则测试将自动失败。​expect.assertions(number)​不是必需的，但建议验证在测试期间调用了一定数量的assertions。其实不然容易忘记​return​/​await​的​.resolves​ ​assertions​。

// 用`.rejects`.来测试一个异步的错误
it('tests error with rejects', () => {
  expect.assertions(1);
  return expect(user.getUserName(3)).rejects.toEqual({
    error: 'User with 3 not found.',
  });
});
// 或者与async/await 一起使用 `.rejects`.
it('tests error with async/await and rejects', async () => {
  expect.assertions(1);
  await expect(user.getUserName(3)).rejects.toEqual({
    error: 'User with 3 not found.',
  });
});

```