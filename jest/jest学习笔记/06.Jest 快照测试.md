## Jest 快照测试

```js
// 每当你想要确保你的UI不会有意外的改变，快照测试是非常有用的工具。
// 典型的快照测试用例呈现 UI 组件，拍摄快照，然后将其与存储在测试旁边的参考快照文件进行比较。如果两个快照不匹配，则测试将失败：更改是意外的，或者参考快照需要更新到新版本的 UI 组件。
```

## 使用 Jest 进行快照测试 案例

```js
// 在测试 React 组件时可以采用类似的方法。你可以使用测试渲染器为你的 React 树快速生成可序列化的值，
// 而不是渲染需要构建整个应用程序的图形 UI。考虑Link组件的这个例子测试：
import React from 'react';
import renderer from 'react-test-renderer';
import Link from '../Link.react';
it('renders correctly', () => {
  const tree = renderer
    .create(<Link page="http://www.facebook.com">Facebook</Link>)
    .toJSON();
  expect(tree).toMatchSnapshot();
});
```

- 第一次运行此测试时，Jest 创建一个如下所示的快照文件：

```js
// 快照工件应与代码更改一起提交，并作为代码审查过程的一部分进行审查。在代码审查期间，Jest 使用友好的格式使快照更易于阅读。在后续的测试运行中，Jest 会将渲染的输出与之前的快照进行比较。如果它们匹配，则测试将通过。如果它们不匹配，则测试运行程序在您的代码中发现了一个应该修复的错误（在本例中，它是​<Link>​组件），或者实现已更改并且快照需要更新。

//  注意：快照直接作用于呈现的数据——在我们的实例中，它是由​<Link />​的组件 page prop 传递给它。这也意味着即使任何其他文件在​<Link />​组件中缺少 props （比如：​App.js​）。它仍然可以通过测试，因为测试不知道​<Link />​组件的用法，并且它的范围仅限于 ​Link.react.js​。此外，在其他快照测试中使用不同的 props 渲染相同的组件是不会影响第一个，因为测试不知道彼此。
```
```html
exports[`renders correctly 1`] = `
<a
  className="normal"
  href="http://www.facebook.com" rel="external nofollow" target="_blank" 
  onMouseEnter={[Function]}
  onMouseLeave={[Function]}
>
  Facebook
</a>
`;
```

- 更新快照

```js
// 在引入错误后，快照测试什么时候失败是很容易被发现。发生这种情况时，请继续解决问题并确保你的快照测试再次通过。
// 现在，让我们谈谈快照测试由于有意的实现更改而失败的情况。
// 如果我们有意更改示例中的 Link 组件指向的地址，就会出现这样一种情况。


// jest --updateSnapshot

// 继续并通过运行上述命令接受更改。​-u​如果您愿意，您也可以使用等效的单字符标志来重新生成快照。这将为所有失败的快照测试重新生成快照工件。如果由于意外错误导致我们有任何其他失败的快照测试，我们需要在重新生成快照之前修复错误，以避免记录错误行为的快照。
// 如果你想限制重新生成哪些快照测试用例，可以传递一个额外的​--testNamePattern​标志来仅为那些与模式匹配的测试重新记录快照。
// 你可以通过克隆快照示例、修改​Link​组件和运行 Jest来尝试此功能。

// 这里的所有都是它的！甚至可以​--updateSnapshot​使用模式​u​键或使用键来更新快照​--watch​。
```


- 属性匹配器

```js
// jest 允许为任何属性提供非对称匹配器。在写入或测试快照之前检查这些匹配器，然后将其保存到快照文件而不是接收到的值：
it('will check the matchers and pass', () => {
  const user = {
    createdAt: new Date(),
    id: Math.floor(Math.random() * 20),
    name: 'LeBron James',
  };
  expect(user).toMatchSnapshot({
    createdAt: expect.any(Date),
    id: expect.any(Number),
  });
});


// Snapshot
exports[`will check the matchers and pass 1`] = `
Object {
  "createdAt": Any<Date>,
  "id": Any<Number>,
  "name": "LeBron James",
}
`;
```

- 任何不是匹配器的给定值都将被准确检查并保存到快照中：

```js
it('will check the values and pass', () => {
  const user = {
    createdAt: new Date(),
    name: 'Bond... James Bond',
  };
  expect(user).toMatchSnapshot({
    createdAt: expect.any(Date),
    name: 'Bond... James Bond',
  });
});
// Snapshot
exports[`will check the values and pass 1`] = `
Object {
  "createdAt": Any<Date>,
  "name": 'Bond... James Bond',
}
`;
```

## 最佳实践

```js
// 快照测试和视觉回归测试是测试 UI 的两种不同方式，它们用于不同的目的。视觉回归测试工具获取网页的屏幕截图并逐个像素地比较生成的图像。
// 使用 Snapshot 测试值被序列化，存储在文本文件中，并使用 diff 算法进行比较。需要考虑不同的权衡，我们在Jest 博客中列出了构建快照测试的原因。
```